<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Vite5基础进阶和原理剖析</title>
    <link href="/20250421/Vite5%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6%E5%92%8C%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    <url>/20250421/Vite5%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6%E5%92%8C%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="Vite5-的核心和基础使用"><a href="#Vite5-的核心和基础使用" class="headerlink" title="Vite5 的核心和基础使用"></a>Vite5 的核心和基础使用</h2><h3 id="核心设计"><a href="#核心设计" class="headerlink" title="核心设计"></a>核心设计</h3><ol><li>木块化规范演进：commonjs -&gt; amd -&gt; cmd -&gt; umd -&gt; esmodule</li><li><code>bundleless</code> 模式，取决于浏览器原生ESModule的支持</li><li>本地开发 esbuild，线上构建 rollup</li></ol><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ol><li>脚手架初始化项目</li><li>工程化、规范、自动化</li><li>配置 Vite 体系。哪些内容需要打包，需要编译什么内容<ol><li>react 项目：<code>@vitejs/plugin-react</code></li><li>vue 项目：<code>@vitejs/plugin-vue</code></li><li>官方文档，<code>@vitejs/plugin-xxx</code></li><li>unbundle</li><li>vite-awesome</li></ol></li></ol><h4 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h4><p><code>pnpm create vite 项目名 --template [react-ts/vue-ts]</code></p><h4 id="vite-config-ts配置"><a href="#vite-config-ts配置" class="headerlink" title="vite.config.ts配置"></a>vite.config.ts配置</h4><ol><li><p>plugins</p></li><li><p>resolve</p></li><li><p>server</p></li><li><p>build</p></li><li><p>manualChunks 静态拆包</p></li><li><p>模块懒加载</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./src/utils&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br>&#125;)<br></code></pre></td></tr></table></figure><p>上面代码会被单独打包成一个文件</p></li><li><p>define 配置项用于在编译时定义全局常量，它会在代码被打包构建的过程中，将你指定的标识符替换为对应的值。简单来说，就是让你可以在源代码中直接使用一些<br>“全局变量”，而这些变量会在构建阶段被静态替换为具体内容。</p><p><strong>核心作用</strong></p><ul><li>注入全局常量：在代码中直接使用预定义的常量（如环境标识、API 地址等），无需手动导入。</li><li>编译时替换：替换发生在构建阶段，而非运行时，不会增加运行时开销。</li><li>条件编译：可以根据不同环境定义不同的值，实现代码的条件执行（如开发环境打印日志，生产环境移除日志）。</li></ul></li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123;defineConfig&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite&#x27;</span><br><span class="hljs-keyword">import</span> react <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@vitejs/plugin-react&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>    <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">react</span>()],<br>    <span class="hljs-comment">// 模块化解析</span><br>    <span class="hljs-attr">resolve</span>: &#123;<br>        <span class="hljs-comment">// 别名</span><br>        <span class="hljs-attr">alias</span>: &#123;<br>            <span class="hljs-string">&quot;@&quot;</span>: <span class="hljs-string">&quot;src&quot;</span><br>        &#125;<br>    &#125;,<br>    <span class="hljs-comment">// 服务配置</span><br>    <span class="hljs-attr">server</span>: &#123;<br>        <span class="hljs-attr">port</span>: <span class="hljs-number">3000</span>,<br>        <span class="hljs-attr">open</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-comment">// 跨域配置</span><br>        <span class="hljs-attr">proxy</span>: &#123;<br>            <span class="hljs-string">&#x27;/api&#x27;</span>: &#123;<br>                <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;https://www.baidu.com&#x27;</span>,<br>                <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<br>                <span class="hljs-attr">rewrite</span>: <span class="hljs-function">(<span class="hljs-params">path</span>) =&gt;</span> path.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^\/api/</span>, <span class="hljs-string">&#x27;&#x27;</span>)<br>            &#125;<br>        &#125;<br>    &#125;,<br>    <span class="hljs-comment">// 构建配置</span><br>    <span class="hljs-attr">build</span>: &#123;<br>        <span class="hljs-attr">outDir</span>: <span class="hljs-string">&#x27;dist&#x27;</span>, <span class="hljs-comment">// 打包输出目录</span><br>        <span class="hljs-attr">assetsDir</span>: <span class="hljs-string">&#x27;assets&#x27;</span>, <span class="hljs-comment">// 静态资源输出目录</span><br>        <span class="hljs-attr">minify</span>: <span class="hljs-string">&#x27;terser&#x27;</span>, <span class="hljs-comment">// 压缩，默认是压缩的, 也可以设置为 &#x27;esbuild&#x27;</span><br>        <span class="hljs-attr">sourcemap</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 生成 sourcemap 文件，开发环境下使用。如果是生产环境的话，可以用@sentry/vite-plugin 插件上传 sourcemap 文件，在 sentry 平台查看源代码。</span><br>        <span class="hljs-attr">terserOptions</span>: &#123;<br>            <span class="hljs-comment">// 压缩选项</span><br>            <span class="hljs-attr">compress</span>: &#123;<br>                <span class="hljs-attr">drop_console</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 移除 console</span><br>                <span class="hljs-attr">drop_debugger</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 移除 debugger</span><br>            &#125;<br>        &#125;,<br>        <span class="hljs-comment">// 构建产物优化，代码分割</span><br>        <span class="hljs-attr">rollupOptions</span>: &#123;<br>            <span class="hljs-comment">// 入口文件配置</span><br>            <span class="hljs-attr">input</span>: &#123;<br>                <span class="hljs-attr">main</span>: <span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;index.html&#x27;</span>), <span class="hljs-comment">// 入口文件</span><br>                <span class="hljs-attr">nested</span>: <span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;nested/index.html&#x27;</span>), <span class="hljs-comment">// 嵌套入口文件</span><br>            &#125;,<br>            <span class="hljs-attr">output</span>: &#123;<br>                <span class="hljs-comment">// 手动代码分割</span><br>                <span class="hljs-comment">// manualChunks:&#123;</span><br>                <span class="hljs-comment">//     &#x27;react-vendor&#x27;: [&#x27;react&#x27;, &#x27;react-dom&#x27;], // 将 react 相关的都打到同一个包里</span><br>                <span class="hljs-comment">//     &#x27;antd-vendor&#x27;: [&#x27;antd&#x27;], // 将 antd 相关的都打到同一个包里</span><br>                <span class="hljs-comment">// &#125;</span><br>                <span class="hljs-title function_">manualChunks</span>(<span class="hljs-params">id</span>) &#123;<br>                    <span class="hljs-comment">// id 是模块的路径，根据路径匹配来代码分割</span><br>                    <span class="hljs-comment">// 比如：node_modules/react/index.js</span><br>                    <span class="hljs-keyword">if</span> (id.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;node_modules&#x27;</span>)) &#123;<br>                        <span class="hljs-keyword">return</span> id.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;node_modules/&#x27;</span>)[<span class="hljs-number">1</span>].<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;/&#x27;</span>)[<span class="hljs-number">0</span>].<span class="hljs-title function_">toString</span>()<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">css</span>: &#123;<br>        <span class="hljs-attr">modules</span>: &#123;<br>            <span class="hljs-comment">// 仅对 CSS Modules 有效：即文件名需包含 .module（如 xxx.module.css、xxx.module.scss）的样式文件才会应用此配置。</span><br>            <span class="hljs-attr">hashPrefix</span>: <span class="hljs-string">&#x27;hash&#x27;</span>,<br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">define</span>: &#123;<br>        <span class="hljs-attr">IS_PROD</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> === <span class="hljs-string">&#x27;production&#x27;</span>,<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        * 在 js 或者组件中可以直接使用这个变量：</span><br><span class="hljs-comment">        * if (IS_PROD) &#123;</span><br><span class="hljs-comment">        *      console.log(&#x27;生产环境&#x27;); // 生产环境构建时，这里会被替换为 true</span><br><span class="hljs-comment">        * &#125; else &#123;</span><br><span class="hljs-comment">        *      console.log(&#x27;开发环境&#x27;); // 开发环境构建时，这里会被替换为 false</span><br><span class="hljs-comment">        * &#125; </span><br><span class="hljs-comment">        */</span><br>    &#125;,<br>    <span class="hljs-attr">json</span>: &#123;<br>        <span class="hljs-attr">namedExports</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 禁用命名导出，默认是开启的</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        * // 1. 仅支持默认导出</span><br><span class="hljs-comment">        * import data from &#x27;./data.json&#x27;;</span><br><span class="hljs-comment">        * console.log(data.name); // 正常输出：&quot;Vite&quot;</span><br><span class="hljs-comment">        * </span><br><span class="hljs-comment">        * // 2. 具名导出会报错（Uncaught SyntaxError: The requested module &#x27;./data.json&#x27; does not provide an export named &#x27;name&#x27;）</span><br><span class="hljs-comment">        * import &#123; name &#125; from &#x27;./data.json&#x27;; // 错误！</span><br><span class="hljs-comment">        * </span><br><span class="hljs-comment">        * */</span><br>        <span class="hljs-attr">stringify</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        * 若设置为 true，导入的 JSON 会被转换为 export default JSON.parse(&quot;...&quot;)，</span><br><span class="hljs-comment">        * 这样会比转译成对象字面量性能更好，尤其是当 JSON 文件较大的时候。</span><br><span class="hljs-comment">        * 如果设置为 &#x27;auto&#x27;，只有当 数据大于 10kB 时，才会对数据进行字符串化处理。</span><br><span class="hljs-comment">        * */</span><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="vite-插件开发"><a href="#vite-插件开发" class="headerlink" title="vite 插件开发"></a>vite 插件开发</h3><p>前置准备：vite-plugin-inspect 插件</p><p><code>vite-plugin-inspect</code> 是 Vite 生态中的一个开发辅助插件，主要作用是可视化地查看 Vite 构建过程中的模块转换、插件执行流程和依赖关系，帮助开发者调试和理解<br>Vite 的内部工作机制。</p><p>Vite 为了将生态的扩充交给开发者，因此采用了插件化设计思想，定义了基础插件化协议，开发者可以根据协议开发自己的插件，以此来丰富<br>vite 生态。</p><p>Vite 插件的本质是函数，函数有返回值。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">viteHuaLuPlugin</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;vite-hua-lu-plugin&#x27;</span>, <span class="hljs-comment">// 插件名称</span><br><br>        <span class="hljs-comment">// 插件方法</span><br>        <span class="hljs-comment">// transform(source,id)&#123;&#125; 用于转换文件内容，id 是文件的路径，source 是文件的内容</span><br>        <span class="hljs-title function_">transform</span>(<span class="hljs-params">source, id</span>) &#123;<br>            <span class="hljs-keyword">return</span> source.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/hualu/g</span>, <span class="hljs-string">&#x27;HUALU&#x27;</span>)  <span class="hljs-comment">// 替换所有的 hualu 为 HUALU</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 配置自定义插件</span><br><span class="hljs-keyword">import</span> &#123;defineConfig&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite&#x27;</span><br><span class="hljs-keyword">import</span> viteHuaLuPlugin <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./viteHuaLuPlugin&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>    <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">viteHuaLuPlugin</span>()],<br>&#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工程化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工程化&#39;</tag>
      
      <tag>Vite</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React19新特性</title>
    <link href="/20250401/React19%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/20250401/React19%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="forwardRef的弃用"><a href="#forwardRef的弃用" class="headerlink" title="forwardRef的弃用"></a>forwardRef的弃用</h2><p>forwardRef 是一个高阶函数，主要用于让子组件能够接收并转发父组件传递过来的 ref，从而允许父组件直接访问子组件中的 DOM 元素或组件实例。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useRef, forwardRef &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-comment">// 子组件：使用 forwardRef 转发 ref</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ChildComponent</span> = <span class="hljs-title function_">forwardRef</span>(<span class="hljs-function">(<span class="hljs-params">props, ref</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> </span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;ref&#125;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入内容&quot;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">    /&gt;</span></span><br>  );<br>&#125;);<br><br><span class="hljs-comment">// 父组件：使用子组件并传递 ref</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">ParentComponent</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> inputRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">focusInput</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-comment">// 通过 ref 直接访问子组件中的 input 元素并调用其方法</span><br>    inputRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>();<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;inputRef&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;focusInput&#125;</span>&gt;</span>聚焦输入框<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">ParentComponent</span>;<br></code></pre></td></tr></table></figure><p><img src="/20250401/React19%E6%96%B0%E7%89%B9%E6%80%A7/forwardRef.png" alt="forwardRef 已废弃"></p><p>在最新的 React19中，官网显示 forwardRef 已废弃。</p><p>我们无需再用forwardRef 来封装子组件了，直接在子组件中的 props 中接收 ref 即可。</p><p><img src="/20250401/React19%E6%96%B0%E7%89%B9%E6%80%A7/ref.png" alt="ref 接收"></p><h2 id="新-API：use"><a href="#新-API：use" class="headerlink" title="新 API：use"></a>新 API：use</h2><p><img src="/20250401/React19%E6%96%B0%E7%89%B9%E6%80%A7/use.png" alt="use"></p><p>use 是一个 React API，它可以让你读取类似于 <code>Promise</code> 或 <code>context</code> 的资源的值。</p><p>他通常搭配 <code>Suspense</code> 组件和错误边界(ErrorBoundary)一起使用</p><h3 id="处理-context-的示例"><a href="#处理-context-的示例" class="headerlink" title="处理 context 的示例"></a>处理 context 的示例</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; createContext, use &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ThemeContext</span> = <span class="hljs-title function_">createContext</span>(<span class="hljs-literal">null</span>);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">MyApp</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ThemeContext</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;dark&quot;</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">Form</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">ThemeContext</span>&gt;</span></span><br>    )<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Form</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Panel</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;Welcome&quot;</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">show</span>=<span class="hljs-string">&#123;true&#125;</span>&gt;</span>Sign up<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">show</span>=<span class="hljs-string">&#123;false&#125;</span>&gt;</span>Log in<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">Panel</span>&gt;</span></span><br>    );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Panel</span>(<span class="hljs-params">&#123; title, children &#125;</span>) &#123;<br>    <span class="hljs-keyword">const</span> theme = <span class="hljs-title function_">use</span>(<span class="hljs-title class_">ThemeContext</span>);<br>    <span class="hljs-keyword">const</span> className = <span class="hljs-string">&#x27;panel-&#x27;</span> + theme;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;className&#125;</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;title&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">            &#123;children&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span></span><br>    )<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Button</span>(<span class="hljs-params">&#123; show, children &#125;</span>) &#123;<br>    <span class="hljs-keyword">if</span> (show) &#123;<br>        <span class="hljs-keyword">const</span> theme = <span class="hljs-title function_">use</span>(<span class="hljs-title class_">ThemeContext</span>);<br>        <span class="hljs-keyword">const</span> className = <span class="hljs-string">&#x27;button-&#x27;</span> + theme;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;className&#125;</span>&gt;</span></span><br><span class="language-xml">                &#123;children&#125;</span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>        );<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="与-Suspense-、ErrorBoundary-搭配使用的示例"><a href="#与-Suspense-、ErrorBoundary-搭配使用的示例" class="headerlink" title="与 Suspense 、ErrorBoundary 搭配使用的示例"></a>与 Suspense 、ErrorBoundary 搭配使用的示例</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><br><span class="hljs-keyword">import</span> &#123; use, <span class="hljs-title class_">Suspense</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ErrorBoundary</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-error-boundary&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Message</span>(<span class="hljs-params">&#123; messagePromise &#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> messageContent = <span class="hljs-title function_">use</span>(messagePromise);<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Here is the message: &#123;messageContent&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">MessageContainer</span>(<span class="hljs-params">&#123; messagePromise &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ErrorBoundary</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">p</span>&gt;</span>⚠️Something went wrong<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>&#125;&gt;</span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">p</span>&gt;</span>⌛Downloading message...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>&#125;&gt;</span><br><span class="language-xml">              <span class="hljs-tag">&lt;<span class="hljs-name">Message</span> <span class="hljs-attr">messagePromise</span>=<span class="hljs-string">&#123;messagePromise&#125;</span> /&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">ErrorBoundary</span>&gt;</span></span><br>  );<br>&#125;<br><br></code></pre></td></tr></table></figure><p>将调用 use API 的组件包装在错误边界中。如果传递给 use 的 Promise 被拒绝（rejected），将显示错误边界的后备方案。</p>]]></content>
    
    
    <categories>
      
      <category>技术类-React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react18剖析</title>
    <link href="/20250321/react18%E5%89%96%E6%9E%90/"/>
    <url>/20250321/react18%E5%89%96%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="react剖析"><a href="#react剖析" class="headerlink" title="react剖析"></a>react剖析</h1><h2 id="使用脚手架搭建-react-项目"><a href="#使用脚手架搭建-react-项目" class="headerlink" title="使用脚手架搭建 react 项目"></a>使用脚手架搭建 react 项目</h2><h3 id="vite"><a href="#vite" class="headerlink" title="vite"></a>vite</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">npm <span class="hljs-keyword">create</span> vite<span class="hljs-variable">@latest</span> my<span class="hljs-operator">-</span>react<span class="hljs-operator">-</span>app <span class="hljs-comment">--template react-ts</span><br></code></pre></td></tr></table></figure><h3 id="create-react-app"><a href="#create-react-app" class="headerlink" title="create-react-app"></a>create-react-app</h3><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">npx</span> <span class="hljs-built_in">create-react-app</span> <span class="hljs-string">my-react-app</span> <span class="hljs-built_in">--template</span> <span class="hljs-string">typescript</span><br></code></pre></td></tr></table></figure><h2 id="jsx"><a href="#jsx" class="headerlink" title="jsx"></a>jsx</h2><p>jsx 是在 javascript 代码中编写 html 代码的一种规范。</p><p>jsx 通过编译器进行转换，babel(@babel/preset-react、plugin-transform-react-jsx)</p><p>转换后变成可以执行的代码</p><p>在线转换地址：<a href="https://babeljs.io/repl#?config_lz=N4IgZglgNgpgdgQwLYxALhAJxgBygOgCsBnADxABoQdtiYAXY9AbWZHgDdLR6FMBzBkwwATGGAQBXKIwoACOAHt6ciDDkBGDfKUq1AfSSKARpo2UQRkdJjCJUOlWOT-kUrfT1MkmAF8AuhRs2AgAxvTcWJJw9BAo6CBS9IpICLGhIAFBIMS8ggC0AEyRYqGKmGnlxABqMJjEEIpwCYUADIUAzPlaFjgQODBQEHAwAAqYijiKxAhQCQAWYQDWmf6BOYqSmKEwACoAngMJVjaZQA&lineWrap=true&version=7.28.3">babel在线转换</a></p><p>再在 react 运行时，通过 react 定义的 jsx 创建出 ReactElement</p><h2 id="hooks"><a href="#hooks" class="headerlink" title="hooks"></a>hooks</h2><ul><li>useState</li><li>useReducer</li><li>useRef</li><li>useMemo</li><li>useCallback</li><li>useContext</li></ul><h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><p>不仅仅可以作为 dom 的引用，还可以作为不需要引起视图更新的数据存储</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> ref = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>)<br>    <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ref.<span class="hljs-property">current</span>)<br>    &#125;, []);<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;ref&#125;</span>&gt;</span></span><br><span class="language-xml">                Ref demo</span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/&gt;</span></span><br>    )<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="forwardRef"><a href="#forwardRef" class="headerlink" title="forwardRef"></a>forwardRef</h2><h2 id="Suspense"><a href="#Suspense" class="headerlink" title="Suspense"></a>Suspense</h2><h2 id="lazy"><a href="#lazy" class="headerlink" title="lazy"></a>lazy</h2><h2 id="memo"><a href="#memo" class="headerlink" title="memo"></a>memo</h2>]]></content>
    
    
    <categories>
      
      <category>技术类-React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3源码剖析</title>
    <link href="/20241215/vue3%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    <url>/20241215/vue3%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文对应的Vue3源码版本：<a href="https://github.com/vuejs/core/blob/main/CHANGELOG.md#3513-2024-11-15">3.5.13</a></p></blockquote><h2 id="工程架构设计"><a href="#工程架构设计" class="headerlink" title="工程架构设计"></a>工程架构设计</h2><ul><li>【编译处理】将 vue 文件编译为函数或者对象<ul><li>compiler-core</li><li>compiler-dom</li><li>compiler-sfc</li><li>compiler-ssr</li></ul></li><li>【响应式系统】将状态数据与视图更新链接起来<ul><li>reactivity</li></ul></li><li>【运行时渲染】数据更新时需要重新渲染到页面中<ul><li>runtime-core</li><li>runtime-dom</li><li>runtime-test // 用于测试</li></ul></li><li>shared 文件夹下的代码是全局共享的，比如一些工具函数、常量等等</li><li>【入口包】vue 文件夹下的代码是入口文件，提供开发者使用的内容</li></ul><h2 id="compiler-core、compiler-dom、compiler-sfc"><a href="#compiler-core、compiler-dom、compiler-sfc" class="headerlink" title="compiler-core、compiler-dom、compiler-sfc"></a>compiler-core、compiler-dom、compiler-sfc</h2><h3 id="compiler-core"><a href="#compiler-core" class="headerlink" title="compiler-core"></a>compiler-core</h3><p>compiler-core 是 Vue 3 的编译器核心，它负责将 Vue 模板编译为 JavaScript 渲染函数。</p><p>它是底层通用模块，不直接处理 .vue 文件，而是为各种 Vue 相关的编译场景提供基础能力（例如：在非 SFC 场景下编译纯模板字符串）。</p><ul><li>parser 解析器（Parser 负责 “读懂” 模板结构）<ul><li>解析器的作用是将 Vue 模板字符串解析为 AST（抽象语法树）</li><li>解析器的输出结果是一个 AST，AST 中包含了模板的结构信息</li></ul></li><li>transformer 转换器（Transformer 负责 “理解” 模板语义）<ul><li>转换器的作用是对 AST 进行转换，将 AST 转换为一个更优化的 AST</li><li>转换器的输出结果是一个优化后的 AST，优化后的 AST 中包含了更多的元数据信息</li></ul></li><li>codegen 代码生成器（Codegen 负责 “翻译” 为可执行代码render 函数）<ul><li>代码生成器的作用是将 AST 转换为 JavaScript 代码</li><li>代码生成器的输出结果是一个渲染函数，渲染函数的作用是将数据渲染到 DOM 中</li></ul></li></ul><p>整体流程</p><ol><li>通过 vite、webpack 启动（打包）vue 项目，vite-plugin-vue(webpack vue-loader)</li><li>分词器（Tokenizer 负责 “切分” 模板为 tokens）</li><li>解析器（Parser 将分词 tokens 转换为 ast）</li><li>转换器（Transformer 负责优化 ast）</li><li>代码生成器（Codegen 将 ast 转换为 render 函数）</li><li>渲染函数（Render 负责 “执行” 渲染函数，将数据渲染到 DOM 中）</li><li>挂载（Mount 负责将渲染函数挂载到 DOM 中）</li></ol><h3 id="compiler-dom"><a href="#compiler-dom" class="headerlink" title="compiler-dom"></a>compiler-dom</h3><p><img src="/20241215/vue3%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/compiler-dom.png" alt="compiler-dom"></p><p>compiler-dom 是 Vue 3 的 DOM 编译器，它负责将 Vue 模板编译为 DOM 操作代码。</p><p>compiler-dom 是基于 compiler-core 的浏览器环境专用扩展，它在核心框架之上补充了浏览器 DOM 环境特有的编译逻辑，例如：</p><ul><li>处理 HTML 标签、属性（如 class、style）、自闭合标签等 DOM 特性。</li><li>支持 v-html、v-text 等操作 DOM 的指令。</li><li>生成与浏览器 DOM 操作匹配的渲染函数代码（如创建真实 DOM 节点的 API 调用）。</li></ul><h3 id="compiler-sfc"><a href="#compiler-sfc" class="headerlink" title="compiler-sfc"></a>compiler-sfc</h3><p><img src="/20241215/vue3%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/compiler-sfc.png" alt="compiler-sfc"><br>compiler-sfc 是 Vue 3 的单文件组件编译器，它负责将 Vue 单文件组件编译为 JavaScript 渲染函数。</p><p>是上层专用模块，基于 compiler-core 实现了对 SFC 格式的完整编译流程，是 Vue 单文件组件开发的核心依赖（如 Vite、Vue CLI<br>等工具都会用到它）。</p><h2 id="响应式处理"><a href="#响应式处理" class="headerlink" title="响应式处理"></a>响应式处理</h2><p><img src="/20241215/vue3%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/reactivity.png" alt="reactivity文件夹"></p><ul><li>dep 依赖<ul><li>track</li><li>trigger</li><li>notify</li></ul></li><li>collection 依赖收集<ul><li>MutableReactiveHandler，可读可写状态数据跟踪</li><li>当数据被访问时，触发 proxy 的 get，track 依赖收集</li><li>当数据被修改时，触发 proxy 的 set，trigger 依赖触发</li></ul></li><li>ref、reactive</li><li>watch</li><li>effect 副作用</li></ul><h2 id="运行时处理"><a href="#运行时处理" class="headerlink" title="运行时处理"></a>运行时处理</h2><h3 id="runtime-core"><a href="#runtime-core" class="headerlink" title="runtime-core"></a>runtime-core</h3><p>runtime-core 是 Vue 运行时的核心模块，与具体平台（如浏览器、Node.js、Weex 等）无关，包含了 Vue 最核心的逻辑，是跨平台能力的基础。</p><p>主要作用：</p><ul><li>虚拟 DOM 处理：实现虚拟 DOM 的创建、更新、diff 算法等核心逻辑，是 Vue 高效更新视图的基础。</li><li>组件系统：定义组件的生命周期、状态管理（如 setup、reactive、ref 等）、事件处理、Props 传递等核心功能。</li><li>响应式系统集成：与 @vue/reactivity 模块协作，实现数据变化驱动视图更新的响应式机制。</li><li>渲染调度：负责协调组件渲染的优先级、异步更新队列等，优化渲染性能。</li><li>平台无关的渲染逻辑：定义了渲染器（Renderer）的抽象接口，不直接操作 DOM，而是通过抽象接口与具体平台交互。</li></ul><p>简单说，runtime-core 是 Vue 的 “灵魂”，包含了所有不依赖具体平台的核心逻辑，是实现跨平台的基础。</p><h4 id="diff-算法"><a href="#diff-算法" class="headerlink" title="diff 算法"></a>diff 算法</h4><ul><li>简单 diff 算法</li><li>双端 diff 算法</li><li>快速 diff 算法（终极版本）</li></ul><h3 id="runtime-dom"><a href="#runtime-dom" class="headerlink" title="runtime-dom"></a>runtime-dom</h3><p>runtime-dom 是 针对浏览器平台的运行时扩展，基于 runtime-core 实现，负责将核心逻辑与浏览器的 DOM 环境对接。</p><p>主要作用：</p><ul><li>DOM 操作封装：提供浏览器特有的 DOM 操作方法，如创建元素（createElement）、插入元素（insert）、设置属性（setAttribute）、事件绑定（addEventListener）等。</li><li>处理浏览器特有属性和事件：例如 class、style 等属性的特殊处理，以及浏览器事件的兼容处理（如事件冒泡、默认行为等）。</li><li>集成浏览器 API：将 runtime-core 的抽象接口映射到实际的浏览器 API，例如将虚拟 DOM 转换为真实 DOM。</li><li>提供浏览器环境的渲染器：基于 runtime-core 的渲染器接口，实现浏览器环境下的具体渲染逻辑。</li></ul><p>简单说，runtime-dom 是 Vue 与浏览器 DOM 交互的 “桥梁”，让 runtime-core 的核心逻辑能在浏览器中生效。</p><p>runtime-core 负责组件的状态管理、虚拟 DOM 构建和 diff 计算。</p><p>runtime-dom 负责将虚拟 DOM 转换为真实 DOM，并处理浏览器特有的交互（如点击事件、样式更新等）。</p><h2 id="手写-reactive"><a href="#手写-reactive" class="headerlink" title="手写 reactive"></a>手写 reactive</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs ts"><br><span class="hljs-keyword">let</span> targetMap = <span class="hljs-keyword">new</span> <span class="hljs-title function_">weakMap</span>()<br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">ReactiveFlags</span> &#123;<br>    <span class="hljs-variable constant_">IS_REACTIVE</span> = <span class="hljs-string">&#x27;__v_isReactive&#x27;</span>,<br>&#125;<br><br><span class="hljs-keyword">const</span> mutableReactiveHandler = &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key, receiver</span>) &#123;<br>        <span class="hljs-comment">// 只要被代理了且访问了这个属性就返回 true</span><br>        <span class="hljs-keyword">if</span> (key === <span class="hljs-title class_">ReactiveFlags</span>.<span class="hljs-property">IS_REACTIVE</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125;<br><br>        <span class="hljs-comment">// 收集依赖，当取值的时候，让响应式对象的属性与 effect 关联起来</span><br>        <span class="hljs-title function_">track</span>(target, key)<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver)<br>    &#125;,<br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, value, receiver</span>) &#123;<br>        <span class="hljs-keyword">let</span> oldValue = target[key] <span class="hljs-comment">// 旧值</span><br>        <span class="hljs-keyword">let</span> r = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, value, receiver) <span class="hljs-comment">// 返回的是布尔类型</span><br><br>        <span class="hljs-comment">// 判断新旧值是否一样</span><br>        <span class="hljs-comment">// 当设置值的时候，让对应的 effect 执行</span><br>        <span class="hljs-keyword">if</span> (oldValue !== value) &#123;<br>            <span class="hljs-title function_">trigger</span>(target, key, value, oldValue)<br>        &#125;<br>        <span class="hljs-keyword">return</span> r<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createReactiveObject</span>(<span class="hljs-params">target</span>) &#123;<br>    <span class="hljs-comment">// 必须是对象</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isObject</span>(target)) &#123;<br>        <span class="hljs-keyword">return</span> target<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (target[<span class="hljs-title class_">ReactiveFlags</span>.<span class="hljs-property">IS_REACTIVE</span>]) &#123;<br>        <span class="hljs-keyword">return</span> target<br>    &#125;<br><br>    <span class="hljs-comment">// 重复代理 直接返回代理对象</span><br>    <span class="hljs-keyword">const</span> existingProxy = targetMap.<span class="hljs-title function_">get</span>(target)<br>    <span class="hljs-keyword">if</span> (existingProxy) &#123;<br>        <span class="hljs-keyword">return</span> existingProxy<br>    &#125;<br>    <span class="hljs-comment">// 代理对象</span><br>    <span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, mutableReactiveHandler)<br>    <span class="hljs-comment">// 缓存代理对象</span><br>    targetMap.<span class="hljs-title function_">set</span>(target, proxy)<br>    <span class="hljs-keyword">return</span> proxy<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">reactive</span>(<span class="hljs-params">target</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">createReactiveObject</span>(target)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="疑问：为什么要用-Reflect-而不是直接用-target-key-？"><a href="#疑问：为什么要用-Reflect-而不是直接用-target-key-？" class="headerlink" title="疑问：为什么要用 Reflect 而不是直接用 target[key]？"></a>疑问：为什么要用 Reflect 而不是直接用 target[key]？</h3><p>为了解决 this 指向问题</p><p>举个例子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> obj = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;jayhwang&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>    <span class="hljs-attr">sex</span>: <span class="hljs-string">&#x27;male&#x27;</span>,<br>    <span class="hljs-keyword">get</span> <span class="hljs-title function_">aliasName</span>() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;花鹿&#x27;</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;get&#x27;</span>, key)<br>        <span class="hljs-keyword">return</span> target[key]<br>    &#125;,<br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, value</span>) &#123;<br>        target[key] = value<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        <span class="hljs-comment">// return Reflect.set(target, key, value)</span><br>    &#125;<br>&#125;)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">aliasName</span>)<br></code></pre></td></tr></table></figure><p>执行上面的代码，我们会发现 在读取<code>aliasName</code>属性时，会触发<code>get aliasName() &#123;         return this.name + &#39;花鹿&#39;     &#125;</code>，这里面有<code>this.name</code>，可是我们在读取<code>this.name</code>的时候，没有触发下面的 proxy 的 get 的打印，这就说明这个 this<br>指向并不对，他没有被代理到。</p><p>我们再看下<code>es6</code>中<code>Reflect</code>的<code>get</code>方法</p><p>基本语法：<code>Reflect.get(target, propertyKey[, receiver])</code></p><ul><li>参数说明：<ul><li>target：要获取属性值的目标对象</li><li>propertyKey：要获取的属性名称（字符串或 Symbol）</li><li>receiver（可选）：如果 target 对象中指定了 getter，receiver 会作为 getter 函数的 this 值</li></ul></li><li>返回值：返回获取到的属性值</li></ul><h2 id="手写-effect-副作用函数"><a href="#手写-effect-副作用函数" class="headerlink" title="手写 effect 副作用函数"></a>手写 effect 副作用函数</h2><p><code>effect</code> 函数是一个核心概念，它负责创建 “副作用”（effect），并建立响应式数据与副作用之间的依赖关系。当响应式数据发生变化时，依赖它的副作用会自动重新执行，这是<br>Vue 3 响应式系统实现自动更新的基础机制。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>“副作用” 指的是一段会影响外部环境的代码（例如修改全局变量、更新 DOM 等）。在 Vue 中，组件的渲染函数就是一种典型的副作用（因为它会生成<br>DOM）。effect 函数的作用就是包裹这段副作用代码，并追踪其中使用的响应式数据，形成 “依赖收集”。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> activeEffect = <span class="hljs-literal">null</span> <span class="hljs-comment">// 当前的 effect</span><br><br><span class="hljs-comment">// 清除依赖</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">cleanupEffect</span>(<span class="hljs-params">effect</span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123;deps&#125; = effect<br>    <span class="hljs-keyword">if</span> (deps.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; deps.<span class="hljs-property">length</span>; i++) &#123;<br>            deps[i].<span class="hljs-title function_">delete</span>(effect)<br>        &#125;<br>        deps.<span class="hljs-property">length</span> = <span class="hljs-number">0</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReactiveEffect</span> &#123;<br><br>    <span class="hljs-keyword">public</span> active = <span class="hljs-literal">true</span> <span class="hljs-comment">// 是否是激活的</span><br>    <span class="hljs-keyword">public</span> deps = [] <span class="hljs-comment">// 依赖的响应式数据</span><br>    <span class="hljs-keyword">public</span> parent = <span class="hljs-literal">null</span> <span class="hljs-comment">// 父级 effect</span><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> fn, <span class="hljs-keyword">private</span> scheduler</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">fn</span> = fn<br>    &#125;<br><br>    <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">active</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">fn</span>() <span class="hljs-comment">// 关闭状态下，激活副作用</span><br>        &#125;<br>        <span class="hljs-comment">// 其余情况下，意味着副作用是激活状态</span><br><br>        <span class="hljs-comment">// 处理 effect 嵌套 effect 情况</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 将当前的 effect 变成全局的，，取值的时候可以拿到全局的 effect</span><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">parent</span> = activeEffect<br>            activeEffect = <span class="hljs-variable language_">this</span><br>            <span class="hljs-title function_">cleanupEffect</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">// 清除依赖</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">fn</span>()<br>            <span class="hljs-comment">// 执行副作用函数，副作用函数里面的响应式数据的取值操作会触发前面写的 reactive 的 get 方法</span><br>            <span class="hljs-comment">// 在那里可以我们取到全局的 activeEffect</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            activeEffect = <span class="hljs-variable language_">this</span>.<span class="hljs-property">parent</span><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">parent</span> = <span class="hljs-literal">null</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 停止依赖收集</span><br>    <span class="hljs-title function_">stop</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">active</span> = <span class="hljs-literal">false</span>  <span class="hljs-comment">// 当前的 effect 是激活的，让他失活</span><br>        <span class="hljs-title function_">cleanupEffect</span>(<span class="hljs-variable language_">this</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">effect</span>(<span class="hljs-params">fn, options = &#123;&#125;</span>) &#123;<br>    <span class="hljs-keyword">const</span> _effect = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReactiveEffect</span>(fn, options.<span class="hljs-property">scheduler</span>)<br>    _effect.<span class="hljs-title function_">run</span>() <span class="hljs-comment">// 默认执行一次</span><br><br>    <span class="hljs-keyword">const</span> runner = _effect.<span class="hljs-property">run</span>.<span class="hljs-title function_">bind</span>(_effect) <span class="hljs-comment">// 绑定 this 指向 _effect</span><br>    runner.<span class="hljs-property">effect</span> = _effect<br>    <span class="hljs-keyword">return</span> runner <span class="hljs-comment">// 用于启动依赖收集</span><br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 收集依赖关系，建立映射表，一个响应式的 key 可能对应一个或多个 effect 副作用，例如：</span><br><span class="hljs-comment">* effect(()=&gt;&#123;</span><br><span class="hljs-comment">*   document.title = obj.name</span><br><span class="hljs-comment">* )</span><br><span class="hljs-comment">* effect(()=&gt;&#123;</span><br><span class="hljs-comment">*   console.log(obj.name)</span><br><span class="hljs-comment">* &#125;)</span><br><span class="hljs-comment">* 当 obj.name 变化时，两个 effect 都需要重新执行</span><br><span class="hljs-comment">* */</span><br><span class="hljs-keyword">const</span> targetMap = <span class="hljs-keyword">new</span> <span class="hljs-title function_">weakMap</span>()  <span class="hljs-comment">// 映射表</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* targetMap的数据结构举例：</span><br><span class="hljs-comment">* &#123;</span><br><span class="hljs-comment">*   obj: &#123;</span><br><span class="hljs-comment">*     name: new Set([effect1, effect2]),</span><br><span class="hljs-comment">*     age: new Set([effect1])</span><br><span class="hljs-comment">*   &#125;</span><br><span class="hljs-comment">* &#125;</span><br><span class="hljs-comment">* </span><br><span class="hljs-comment">* */</span><br><br><span class="hljs-comment">// 依赖收集</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">track</span>(<span class="hljs-params">target, key</span>) &#123;<br>    <span class="hljs-comment">// 取值操作不是发生在 effect 中，就不需要执行副作用函数，直接 return</span><br>    <span class="hljs-keyword">if</span> (!activeEffect) &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-keyword">let</span> depsMap = targetMap.<span class="hljs-title function_">get</span>(target)<br>    <span class="hljs-keyword">if</span> (!depsMap) &#123;<br>        <span class="hljs-comment">// weakMap中的 key 只能是对象</span><br>        targetMap.<span class="hljs-title function_">set</span>(target, depsMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>())<br>    &#125;<br><br>    <span class="hljs-keyword">let</span> dep = depsMap.<span class="hljs-title function_">get</span>(key)<br>    <span class="hljs-keyword">if</span> (!dep) &#123;<br>        depsMap.<span class="hljs-title function_">set</span>(key, dep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>())<br>    &#125;<br><br>    <span class="hljs-title function_">trackEffect</span>(dep)<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">trackEffect</span>(<span class="hljs-params">dep</span>) &#123;<br>    <span class="hljs-comment">// 依赖不存在，那就收集依赖</span><br>    <span class="hljs-keyword">let</span> shouldTrack = !dep.<span class="hljs-title function_">has</span>(activeEffect)<br>    <span class="hljs-keyword">if</span> (shouldTrack) &#123;<br>        dep.<span class="hljs-title function_">add</span>(activeEffect)<br>        activeEffect.<span class="hljs-property">deps</span>.<span class="hljs-title function_">push</span>(dep)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 依赖触发</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">trigger</span>(<span class="hljs-params">target, key, newValue, oldValue</span>) &#123;<br>    <span class="hljs-keyword">const</span> depsMap = targetMap.<span class="hljs-title function_">get</span>(target)<br>    <span class="hljs-keyword">if</span> (!depsMap) &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">const</span> dep = depsMap.<span class="hljs-title function_">get</span>(key)<br>    <span class="hljs-keyword">if</span> (!dep) &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-title function_">triggerEffect</span>(dep)<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">triggerEffect</span>(<span class="hljs-params">dep</span>) &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 为什么要用 effects 重新接收一份？</span><br><span class="hljs-comment">    * 答：防止依赖触发时，依赖发生变化，导致无限循环</span><br><span class="hljs-comment">    * dep 是 set 类型的，在下方执行 run 方法的时候，会触发依赖清空操作</span><br><span class="hljs-comment">    * 接着又会触发 this.fn() 方法，这就又触发了依赖收集</span><br><span class="hljs-comment">    * 这样一边清空一边收集，操作的都是同一份 set，就会导致无限循环</span><br><span class="hljs-comment">    * 所以要重新定义一个新变量来接收</span><br><span class="hljs-comment">    * */</span><br>    <span class="hljs-keyword">const</span> effects = [...dep]  <span class="hljs-comment">// 新变量接收一份</span><br>    effects.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">effect</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (effect.<span class="hljs-property">scheduler</span>) &#123;<br>            effect.<span class="hljs-title function_">scheduler</span>()<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            effect.<span class="hljs-title function_">run</span>()<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="手写计算属性-computed"><a href="#手写计算属性-computed" class="headerlink" title="手写计算属性 computed"></a>手写计算属性 computed</h2><p>computed 示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 默认不会执行，只有读取的时候才会执行</span><br><span class="hljs-keyword">let</span> fullName = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> obj.<span class="hljs-property">firstName</span> + obj.<span class="hljs-property">lastName</span><br>&#125;)<br><br><span class="hljs-comment">// 多次读取 computed 属性，只有第一次会执行，后面的读取都从缓存中取</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fullName.<span class="hljs-property">value</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fullName.<span class="hljs-property">value</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fullName.<span class="hljs-property">value</span>)<br><span class="hljs-comment">// 当依赖的值变化了，会重新执行</span><br>obj.<span class="hljs-property">firstName</span> = <span class="hljs-string">&#x27;hello&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fullName.<span class="hljs-property">value</span>)<br><br><span class="hljs-comment">// vue3中计算属性也具备依赖收集的功能</span><br><span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fullName.<span class="hljs-property">value</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;isFunction&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@vue/shared&#x27;</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">noop</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ComputedRefImpl</span> &#123;<br>    dep = <span class="hljs-literal">undefined</span> <span class="hljs-comment">// 依赖的响应式数据</span><br>    __v_isRef = <span class="hljs-literal">true</span> <span class="hljs-comment">// 表示需要 .value 来调用</span><br>    _dirty = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 表示是否需要重新计算</span><br>    _value = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// 缓存值</span><br>    effect = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// 副作用函数</span><br><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">getter, setter</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span> = getter<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">setter</span> = setter<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">effect</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReactiveEffect</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">_dirty</span> = <span class="hljs-literal">true</span><br>            <span class="hljs-title function_">triggerEffect</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">dep</span>)<br>        &#125;)<br>    &#125;<br><br>    <span class="hljs-comment">// 属性访问器，取值的时候依赖收集</span><br>    <span class="hljs-keyword">get</span> <span class="hljs-title function_">value</span>() &#123;<br>        <span class="hljs-comment">// 如果有全局 effect，意味着这个计算属性在 effect 中执行的</span><br>        <span class="hljs-keyword">if</span> (activeEffect) &#123;<br>            <span class="hljs-title function_">trackEffect</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">dep</span> || (<span class="hljs-variable language_">this</span>.<span class="hljs-property">dep</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()))<br>        &#125;<br><br>        <span class="hljs-comment">// 依赖收集</span><br>        <span class="hljs-title function_">track</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-string">&#x27;value&#x27;</span>)<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">_dirty</span>) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">effect</span>.<span class="hljs-title function_">run</span>()<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">_dirty</span> = <span class="hljs-literal">false</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span><br>    &#125;<br><br>    <span class="hljs-comment">// 属性设置器</span><br>    <span class="hljs-keyword">set</span> <span class="hljs-title function_">value</span>(<span class="hljs-params">newValue</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setter</span>(newValue)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">computed</span>(<span class="hljs-params">getterOrOptions</span>) &#123;<br>    <span class="hljs-comment">// 判断是否是函数</span><br>    <span class="hljs-keyword">let</span> onlyGetter = <span class="hljs-title function_">isFunction</span>(getterOrOptions)<br><br>    <span class="hljs-keyword">let</span> getter<br>    <span class="hljs-keyword">let</span> setter<br><br>    <span class="hljs-comment">// 只有 getter 没有 setter，说明是只读属性</span><br>    <span class="hljs-keyword">if</span> (onlyGetter) &#123;<br>        getter = getterOrOptions<br>        setter = noop<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 有 getter 有 setter，说明是可读写属性</span><br>        getter = getterOrOptions.<span class="hljs-property">get</span><br>        setter = getterOrOptions.<span class="hljs-property">set</span> || noop<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ComputedRefImpl</span>(getter, setter)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="手写-ref"><a href="#手写-ref" class="headerlink" title="手写 ref"></a>手写 ref</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">ref</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RefImpl</span>()<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">toReactive</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">isObject</span>(value) ? <span class="hljs-title function_">reactive</span>(value) : value<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RefImpl</span> &#123;<br>    dep = <span class="hljs-literal">undefined</span><br>    __v_isRef = <span class="hljs-literal">true</span>   <span class="hljs-comment">// ref标识</span><br>    _value = <span class="hljs-literal">undefined</span><br><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span> = <span class="hljs-title function_">toReactive</span>(value)<br>    &#125;<br><br>    <span class="hljs-keyword">get</span> <span class="hljs-title function_">value</span>() &#123;<br>        <span class="hljs-comment">// 依赖收集</span><br>        <span class="hljs-keyword">if</span> (activeEffect) &#123;<br>            <span class="hljs-title function_">trackEffects</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">dep</span> || (<span class="hljs-variable language_">this</span>.<span class="hljs-property">dep</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()))<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span><br>    &#125;<br><br>    <span class="hljs-keyword">set</span> <span class="hljs-title function_">value</span>(<span class="hljs-params">newValue</span>) &#123;<br>        <span class="hljs-keyword">if</span> (newValue !== <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span>) &#123;<br>            <span class="hljs-comment">// 更新值</span><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span> = <span class="hljs-title function_">toReactive</span>(newValue)<br>            <span class="hljs-comment">// 触发更新</span><br>            <span class="hljs-title function_">triggerEfect</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">dep</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ref-和-reactive-的区别"><a href="#ref-和-reactive-的区别" class="headerlink" title="ref 和 reactive 的区别"></a>ref 和 reactive 的区别</h2><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><ul><li>用于创建基本类型数据的响应式数据，当然也可以包装引用类型（<code>object</code>、<code>array</code>）</li><li>对于基本类型：创建一个<code>&#123;value:原始值&#125;</code>的包装对象，通过重写 <code>value</code> 的 <code>getter</code>（收集依赖）和 <code>setter</code>（触发更新）实现响应式。</li><li>对于引用类型：内部会自动调用 <code>reactive</code> 方法，将引用类型转换为响应式对象，因此 <code>ref(obj).value</code> 本质是一个 <code>reactive</code> 对象。</li><li>在 js 中必须通过<code>.value</code>访问和修改值；在模板中可以直接访问，自动解包，不需要<code>.value</code>。</li><li>引用类型的 ref 如果直接替换整个对象，新对象仍会被转为响应式，不丢失响应式</li></ul><h3 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h3><ul><li>用于创建引用类型数据的响应式代理，无法直接处理基本类型数据（会警告且不生效）。</li><li>通过<code>Proxy</code>代理整个对象，拦截对象的<code>get</code>和<code>set</code>操作，实现响应式。如果对象存在嵌套属性，则递归处理。</li><li>无论在模板还是脚本中，都可以直接访问和修改属性，无需<code>.value</code>。</li><li>不能直接替换整个对象，否则会丢失响应式。</li><li>解构会丢失响应式，需要通过<code>toRef</code>或<code>toRefs</code>处理，如：<code>const &#123;name,age&#125; = toRefs(user)</code>。</li></ul><h2 id="watch-和-watchEffect-的区别"><a href="#watch-和-watchEffect-的区别" class="headerlink" title="watch 和 watchEffect 的区别"></a>watch 和 watchEffect 的区别</h2><h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><ul><li>显式指定依赖，需要手动声明要监听的数据源，仅当依赖变化时才会执行回调。</li><li>默认懒执行，初始化的时候不会自动执行回调，仅当被监听的数据变化时才触发。如果要初始化执行一次，需手动配置<code>immediate: true</code>。</li><li>能获得新旧值，回调函数接收两个参数：newVal(变化后的值)、oldVal(变化前的值)，方便对比数据前后变化状态。</li><li>延迟执行，默认情况下，watch 会在数据变化后立即执行回调。如果要延迟执行，需配置<code>flush: &#39;post&#39;</code>，在 Dom 更新后执行。</li></ul><h3 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h3><ul><li>自动追踪依赖，无需手动声明依赖，自动追踪回调函数内部使用的所有响应式数据，只要函数内部访问的像原始数据发生变化，就会触发回调。</li><li>默认立即执行，初始化时会立即执行一次回调函数，无需配置<code>immediate: true</code>。</li><li>无参数，无法直接获得响应式数据变化前后的值。</li></ul><h2 id="如何将-template-转换为-render-函数"><a href="#如何将-template-转换为-render-函数" class="headerlink" title="如何将 template 转换为 render 函数"></a>如何将 template 转换为 render 函数</h2><p>template 是声明式的模板语法，最终会被 vue 编译器编译为 render 函数，用于生成虚拟DOM。</p><p>将 template 转换为 render 函数，本质是将模板的标签、属性、指令、插值等语法，转换为通过 <code>h</code> 函数描述的 javascript 逻辑。</p><h3 id="h-函数"><a href="#h-函数" class="headerlink" title="h 函数"></a>h 函数</h3><p>Vue 提供的创建虚拟节点的函数，语法为：<code>h(tag,props,children)</code></p><ul><li><code>tag</code>：节点的标签名或组件，如 <code>&#39;div&#39;</code>、<code>&#39;span&#39;</code> 等。</li><li><code>props</code>：节点的属性/指令/事件，如 <code>&#123;id:&#39;app&#39;,class:&#39;container&#39;&#125;</code> 等。</li><li><code>children</code>：节点的子节点，如 <code>&#39;hello world&#39;</code>、<code>[h(&#39;div&#39;,&#39;hello world&#39;)]</code> 等。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>        Hello, Vue!<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">import &#123;h&#125; from &#x27;vue&#x27;<br><br>render() &#123;<br>return h(&#x27;div&#x27;, &#123;class: &#x27;container&#x27;&#125;, &#x27;Hello, Vue!&#x27;)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="vue-的-diff-算法原理"><a href="#vue-的-diff-算法原理" class="headerlink" title="vue 的 diff 算法原理"></a>vue 的 diff 算法原理</h2><p>Vue 的 diff 算法是虚拟 DOM 的核心组成部分，核心目的是通过对比新旧虚拟 DOM 数的差异，计算出最小化的 DOM 操作，从而提高渲染效率。</p><h3 id="patch-方法"><a href="#patch-方法" class="headerlink" title="patch 方法"></a>patch 方法</h3><p>patch 方法是 Vue 中用于对比新旧虚拟 DOM 数差异并更新真实 DOM 的核心函数。</p><h3 id="diff-算法的核心设计原则"><a href="#diff-算法的核心设计原则" class="headerlink" title="diff 算法的核心设计原则"></a>diff 算法的核心设计原则</h3><h4 id="同层比较，不跨层级"><a href="#同层比较，不跨层级" class="headerlink" title="同层比较，不跨层级"></a>同层比较，不跨层级</h4><p>虚拟 DOM 是树形结构，diff 算法只对比同一层级的节点，不跨层级比较，算法复杂度为 O(n)。</p><h4 id="先判断节点是否“可复用”"><a href="#先判断节点是否“可复用”" class="headerlink" title="先判断节点是否“可复用”"></a>先判断节点是否“可复用”</h4><p>对比节点时，首先判断两个节点是否为“相同节点”，只有可复用的节点才需要进一步比较细节，否则直接销毁旧节点并创建新节点。</p><p>判断是否为“相同节点”的依据：</p><ul><li>标签名相同</li><li>key 相同</li><li>是否为注释节点（isComment）</li><li>对比组件节点，组件类型相同</li></ul><h3 id="Vue2的-diff-算法核心"><a href="#Vue2的-diff-算法核心" class="headerlink" title="Vue2的 diff 算法核心"></a>Vue2的 diff 算法核心</h3><p>当两个节点被判定为“相同节点”后，会进入详细对比流程，分为<strong>属性对比</strong>和<strong>子节点对比</strong></p><h4 id="属性对比"><a href="#属性对比" class="headerlink" title="属性对比"></a>属性对比</h4><p>对比新旧节点的属性（attrs、class、style 等），找出差异并更新到真实 DOM：</p><h4 id="子节点对比"><a href="#子节点对比" class="headerlink" title="子节点对比"></a>子节点对比</h4><p>Vue2采用的双指针法（头尾指针），具体流程如下：</p><ol><li>初始化指针：<ul><li>旧节点的头指针（oldStartIdx）</li><li>旧节点的尾指针（oldEndIdx）</li><li>新节点的头指针（newStartIdx）</li><li>新节点的尾指针（newEndIdx）</li></ul></li><li>四种快速对比场景<ul><li>头头对比</li><li>尾尾对比</li><li>旧头新尾对比</li><li>旧尾新头对比</li></ul></li><li>key 映射表查找（处理乱序场景）<ul><li>为旧节点列表创建 key → 索引 的映射表（oldKeyToIdx），快速定位新节点的 key 在旧列表中是否存在。</li><li>若找到对应节点：判断是否为相同节点（避免 key 重复导致误判），若是则复用并移动到对应位置，否则创建新节点。</li><li>若未找到：直接创建新节点插入。</li></ul></li><li>清理剩余节点<br>当某一侧的指针遍历完成后：<ul><li>若旧节点指针未遍历完，将剩余节点全部删除</li><li>若新节点指针未遍历完，将剩余节点全部创建并插入到对应位置</li></ul></li></ol><h3 id="Vue3对-diff-算法的优化"><a href="#Vue3对-diff-算法的优化" class="headerlink" title="Vue3对 diff 算法的优化"></a>Vue3对 diff 算法的优化</h3><ol><li>静态标记：编译时对节点进行了标记，标记了该节点哪些是动态的（需要对比）。diff 算法在对比时，会跳过静态节点，只对比动态节点，从而提高对比效率。</li><li>最长递增子序列：处理列表乱序时，通过最长递增子序列算法算出最少的移动次数，减少 DOM 移动操作。</li><li>数结构打平：将虚拟 DOM 数的节点按层级打平为数组，通过索引快速访问，减少递归遍历的开销</li></ol><h2 id="vue-中-key-的作用"><a href="#vue-中-key-的作用" class="headerlink" title="vue 中 key 的作用"></a>vue 中 key 的作用</h2><p>在 Vue 中，key 是一个特殊的属性，主要用于标识虚拟 DOM（VNode）节点的唯一性，其核心作用是帮助 Vue 的 diff<br>算法更高效、更准确地识别节点的变化，从而优化 DOM 更新性能并避免状态错乱</p><h3 id="作为节点的-“唯一标识”，辅助-diff-算法识别可复用节点"><a href="#作为节点的-“唯一标识”，辅助-diff-算法识别可复用节点" class="headerlink" title="作为节点的 “唯一标识”，辅助 diff 算法识别可复用节点"></a>作为节点的 “唯一标识”，辅助 diff 算法识别可复用节点</h3><p>Vue 的 diff 算法在对比新旧虚拟 DOM 时，首要任务是判断 “两个节点是否为同一个节点”（即是否可复用）。而 key<br>是判断的核心依据之一（配合标签名、组件类型等）。</p><ul><li>当两个节点的 key 相同（且其他条件匹配，如标签名一致）时，Vue 会认为它们是 “同一个节点”，会尝试复用旧节点并仅更新差异（如属性、文本内容）。</li><li>当 key 不同时，Vue 会判定为 “不同节点”，会直接销毁旧节点并创建新节点，不会尝试复用。</li></ul><p>这一机制大幅减少了 diff 算法的复杂度：通过 key 可以快速定位到可复用的节点，避免对 “看似不同但实际可复用” 的节点进行不必要的销毁和重建。</p><h3 id="在列表渲染中避免-“节点复用错误”，保证状态正确"><a href="#在列表渲染中避免-“节点复用错误”，保证状态正确" class="headerlink" title="在列表渲染中避免 “节点复用错误”，保证状态正确"></a>在列表渲染中避免 “节点复用错误”，保证状态正确</h3><p>在使用 v-for 渲染列表时，key 是必须的（Vue 官方强制推荐），其核心作用是避免因节点复用导致的状态混乱。</p><p>错误使用：不使用 key 或使用索引（index）作为 key</p><h3 id="优化-DOM-更新性能，减少不必要的操作"><a href="#优化-DOM-更新性能，减少不必要的操作" class="headerlink" title="优化 DOM 更新性能，减少不必要的操作"></a>优化 DOM 更新性能，减少不必要的操作</h3><p>当列表发生排序、插入、删除等操作时，key 能帮助 diff 算法快速找到 “移动的节点”，从而仅通过 DOM 移动（而非销毁 +<br>重建）完成更新，大幅提升性能。</p><p>例如，对列表 [A, B, C] 排序为 [C, B, A]：</p><ul><li>有 key 时，diff 算法能通过 key 识别出节点只是位置变化，直接移动 DOM 元素即可。</li><li>无 key 时，diff 算法可能无法识别移动，会销毁所有旧节点并重建新节点，性能损耗大。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>key 的核心作用是给节点一个 “唯一且稳定的身份标识”，帮助 Vue 的 diff 算法：</p><ul><li>准确识别可复用的节点，避免状态错乱；</li><li>高效处理列表的增删改查，减少 DOM 操作，优化性能。</li></ul><p>在实际开发中，列表渲染必须使用唯一 ID 作为 key，这是保证列表状态正确和性能优化的关键实践。</p>]]></content>
    
    
    <categories>
      
      <category>技术类-Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>babel常用配置</title>
    <link href="/20241016/babel%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/"/>
    <url>/20241016/babel%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>在实际项目开发中，Babel 配置的核心作用是将现代 JavaScript 语法（如 ES6+）、JSX 等转换为浏览器兼容的代码。以下是项目中最常用的 Babel 配置项和场景：</p><h3 id="一、核心预设（Presets）"><a href="#一、核心预设（Presets）" class="headerlink" title="一、核心预设（Presets）"></a>一、核心预设（Presets）</h3><p>预设是预定义的插件集合，用于处理特定场景的语法转换，是配置的基础。</p><h4 id="1-babel-preset-env（必选）"><a href="#1-babel-preset-env（必选）" class="headerlink" title="1. @babel/preset-env（必选）"></a>1. <code>@babel/preset-env</code>（必选）</h4><ul><li><strong>作用</strong>：根据目标浏览器/环境自动转换 ES6+ 语法（如箭头函数、<code>async/await</code>、类等），无需手动配置单个插件。</li><li><strong>常用配置</strong>：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;presets&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;@babel/preset-env&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;targets&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&gt; 0.25%, not dead&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 目标浏览器范围（基于 browserslist）</span><br>      <span class="hljs-attr">&quot;useBuiltIns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;usage&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 自动引入所需的 polyfill（按需加载）</span><br>      <span class="hljs-attr">&quot;corejs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span> <span class="hljs-comment">// 指定 core-js 版本（需安装 core-js@3）</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li><code>targets</code>：可指定具体浏览器版本（如 <code>&#123;&quot;chrome&quot;: &quot;80&quot;, &quot;ie&quot;: &quot;11&quot;&#125;</code>），或使用 <code>.browserslistrc</code> 文件统一管理。</li><li><code>useBuiltIns: &quot;usage&quot;</code>：自动检测代码中使用的 ES6+ 特性，只引入必要的 <code>polyfill</code>，减小体积。</li></ul></li></ul><h4 id="2-babel-preset-react（React-项目必选）"><a href="#2-babel-preset-react（React-项目必选）" class="headerlink" title="2. @babel/preset-react（React 项目必选）"></a>2. <code>@babel/preset-react</code>（React 项目必选）</h4><ul><li><strong>作用</strong>：转换 JSX 语法为 <code>React.createElement</code> 调用，处理 React 相关语法。</li><li><strong>常用配置</strong>：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;presets&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;@babel/preset-react&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;runtime&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;automatic&quot;</span> <span class="hljs-comment">// 自动引入 React（无需手动写 import React from &#x27;react&#x27;）</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li><code>runtime: &quot;automatic&quot;</code>：是 React 17+ 推荐配置，简化代码。</li></ul></li></ul><h4 id="3-babel-preset-typescript（TypeScript-项目必选）"><a href="#3-babel-preset-typescript（TypeScript-项目必选）" class="headerlink" title="3. @babel/preset-typescript（TypeScript 项目必选）"></a>3. <code>@babel/preset-typescript</code>（TypeScript 项目必选）</h4><ul><li><strong>作用</strong>：将 TypeScript 转换为 JavaScript（仅处理语法，类型检查由 TypeScript 自身负责）。</li><li><strong>配置</strong>：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;presets&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;@babel/preset-typescript&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="二、常用插件（Plugins）"><a href="#二、常用插件（Plugins）" class="headerlink" title="二、常用插件（Plugins）"></a>二、常用插件（Plugins）</h3><p>插件用于处理预设未覆盖的特定语法或功能。</p><h4 id="1-babel-plugin-transform-runtime-babel-runtime"><a href="#1-babel-plugin-transform-runtime-babel-runtime" class="headerlink" title="1. @babel/plugin-transform-runtime + @babel/runtime"></a>1. <code>@babel/plugin-transform-runtime</code> + <code>@babel/runtime</code></h4><ul><li><strong>作用</strong>：<ul><li>复用辅助代码（如 <code>_classCallCheck</code>），减少重复代码，减小打包体积。</li><li>避免全局污染（通过沙箱方式引入 <code>polyfill</code>）。</li></ul></li><li><strong>配置</strong>：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;plugins&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;@babel/plugin-transform-runtime&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;corejs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span> <span class="hljs-comment">// 需安装 @babel/runtime-corejs3，提供 polyfill 支持</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li>通常与 <code>@babel/preset-env</code> 配合使用，前者处理语法转换，后者处理代码复用。</li></ul></li></ul><h4 id="2-babel-plugin-proposal-decorators（装饰器语法）"><a href="#2-babel-plugin-proposal-decorators（装饰器语法）" class="headerlink" title="2. @babel/plugin-proposal-decorators（装饰器语法）"></a>2. <code>@babel/plugin-proposal-decorators</code>（装饰器语法）</h4><ul><li><strong>作用</strong>：支持类装饰器（如 React 高阶组件、MobX 的 <code>@observable</code>）。</li><li><strong>配置</strong>：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;plugins&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;@babel/plugin-proposal-decorators&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2023-01&quot;</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 最新装饰器标准</span><br>    <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;@babel/plugin-proposal-class-properties&quot;</span><span class="hljs-punctuation">]</span> <span class="hljs-comment">// 支持类属性（如 class A &#123; x = 1 &#125;）</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="3-babel-plugin-import（按需加载-UI-库）"><a href="#3-babel-plugin-import（按需加载-UI-库）" class="headerlink" title="3. babel-plugin-import（按需加载 UI 库）"></a>3. <code>babel-plugin-import</code>（按需加载 UI 库）</h4><ul><li><strong>作用</strong>：自动转换 UI 库的导入方式，实现按需加载（如 Ant Design、Element UI）。</li><li><strong>配置（以 Ant Design 为例）</strong>：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;plugins&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;import&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;libraryName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;antd&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;libraryDirectory&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;es&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;style&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;css&quot;</span> <span class="hljs-comment">// 自动引入样式文件</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li>效果：<code>import &#123; Button &#125; from &#39;antd&#39;</code> 会被转换为 <code>import Button from &#39;antd/es/button&#39;</code>，只加载用到的组件。</li></ul></li></ul><h4 id="4-babel-plugin-syntax-dynamic-import（动态导入）"><a href="#4-babel-plugin-syntax-dynamic-import（动态导入）" class="headerlink" title="4. @babel/plugin-syntax-dynamic-import（动态导入）"></a>4. <code>@babel/plugin-syntax-dynamic-import</code>（动态导入）</h4><ul><li><strong>作用</strong>：支持 <code>import()</code> 动态导入语法（用于代码分割）。</li><li><strong>配置</strong>：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;plugins&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;@babel/plugin-syntax-dynamic-import&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li>注意：该插件仅允许 Babel 解析动态导入语法，实际代码分割需配合 Webpack 等工具。</li></ul></li></ul><h3 id="三、环境区分（env-配置）"><a href="#三、环境区分（env-配置）" class="headerlink" title="三、环境区分（env 配置）"></a>三、环境区分（<code>env</code> 配置）</h3><p>根据环境（开发/生产）使用不同配置，优化构建效率或代码质量。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;env&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;development&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;plugins&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;react-refresh/babel&quot;</span><span class="hljs-punctuation">]</span> <span class="hljs-comment">// 开发环境启用 HMR 刷新插件</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;production&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;plugins&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;transform-remove-console&quot;</span><span class="hljs-punctuation">]</span> <span class="hljs-comment">// 生产环境移除 console</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li>需通过 <code>BABEL_ENV</code> 或 <code>NODE_ENV</code> 环境变量指定环境（如 <code>BABEL_ENV=production</code>）。</li></ul><h3 id="四、其他实用配置"><a href="#四、其他实用配置" class="headerlink" title="四、其他实用配置"></a>四、其他实用配置</h3><h4 id="1-sourceType（模块类型）"><a href="#1-sourceType（模块类型）" class="headerlink" title="1. sourceType（模块类型）"></a>1. <code>sourceType</code>（模块类型）</h4><ul><li>指定代码模块类型，默认 <code>module</code>（支持 ES6 模块），如需兼容 CommonJS 可配置：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;sourceType&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;unambiguous&quot;</span> <span class="hljs-punctuation">&#125;</span> <span class="hljs-comment">// 自动检测模块类型（ES6 或 CommonJS）</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="2-ignore（忽略文件）"><a href="#2-ignore（忽略文件）" class="headerlink" title="2. ignore（忽略文件）"></a>2. <code>ignore</code>（忽略文件）</h4><ul><li>排除不需要转换的文件（如 <code>node_modules</code>）：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;ignore&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;node_modules/**&quot;</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="五、典型项目配置示例"><a href="#五、典型项目配置示例" class="headerlink" title="五、典型项目配置示例"></a>五、典型项目配置示例</h3><h4 id="React-ES6-项目"><a href="#React-ES6-项目" class="headerlink" title="React + ES6+ 项目"></a>React + ES6+ 项目</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;presets&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;@babel/preset-env&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;targets&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;defaults&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;useBuiltIns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;usage&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;corejs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;@babel/preset-react&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;runtime&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;automatic&quot;</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;plugins&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;@babel/plugin-transform-runtime&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;corejs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;import&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;libraryName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;antd&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;style&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;css&quot;</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;env&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;production&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;plugins&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;transform-remove-console&quot;</span><span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="TypeScript-React-项目"><a href="#TypeScript-React-项目" class="headerlink" title="TypeScript + React 项目"></a>TypeScript + React 项目</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;presets&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">&quot;@babel/preset-env&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;@babel/preset-typescript&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">[</span><br>      <span class="hljs-string">&quot;@babel/preset-react&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;runtime&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;automatic&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;plugins&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">[</span><br>      <span class="hljs-string">&quot;@babel/plugin-transform-runtime&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;corejs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>核心配置围绕 <strong>语法转换</strong>（<code>@babel/preset-env</code>）、<strong>框架支持</strong>（<code>@babel/preset-react</code>/<code>typescript</code>）、<strong>体积优化</strong>（<code>@babel/plugin-transform-runtime</code>）、<strong>按需加载</strong>（<code>babel-plugin-import</code>）展开。实际项目中，需根据技术栈（React/Vue/TypeScript）和目标环境调整配置，优先使用预设而非单个插件，减少配置复杂度。</p>]]></content>
    
    
    <categories>
      
      <category>babel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>babel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react状态管理方案</title>
    <link href="/20240915/react%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88/"/>
    <url>/20240915/react%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h2 id="zustand"><a href="#zustand" class="headerlink" title="zustand"></a>zustand</h2><p>优势： </p><ul><li>极简的 api，较低的学习成本。只需通过 <code>create</code> 函数创建 <code>store</code>，直接定义状态和修改状态的方法，无需冗余模板。</li><li>更灵活的状态访问方式。支持选择性订阅（只监听需要的状态字段，减少不必要的重渲染）。<code>const count = useStore((state) =&gt; state.count)</code></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// src/stores/useCounter.ts</span><br><br><span class="hljs-comment">// 引入 zustand 库</span><br><span class="hljs-keyword">import</span> &#123;create&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;zustand&#x27;</span><br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">CounterState</span> = &#123;<br>    <span class="hljs-attr">count</span>: <span class="hljs-built_in">number</span>,<br>    <span class="hljs-attr">add</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span><br>    <span class="hljs-attr">minus</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span><br>&#125;<br><br><span class="hljs-comment">// 创建一个 zustand 状态管理 store</span><br><span class="hljs-keyword">const</span> useCounter = create&lt;<span class="hljs-title class_">CounterState</span>&gt;(<span class="hljs-function">(<span class="hljs-params">set</span>) =&gt;</span> (<br>    &#123;<br>        <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,<br>        <span class="hljs-attr">add</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">set</span>(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">state</span>: <span class="hljs-built_in">any</span></span>) =&gt;</span> (&#123;<span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> + <span class="hljs-number">1</span>&#125;)),<br>        <span class="hljs-attr">minus</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">set</span>(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">state</span>: <span class="hljs-built_in">any</span></span>) =&gt;</span> (&#123;<br>            <span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> - <span class="hljs-number">1</span><br>        &#125;))<br><br>    &#125;<br>))<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> useCounter<br></code></pre></td></tr></table></figure><p>在页面上使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> useCounter <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/stores/useCounter&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123;count, add, minus&#125; = <span class="hljs-title function_">useCounter</span>()<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                &#123;count&#125;</span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;add&#125;</span>&gt;</span></span><br><span class="language-xml">                add</span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;minus&#125;</span>&gt;</span></span><br><span class="language-xml">                minus</span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/&gt;</span></span><br>    )<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="jotai"><a href="#jotai" class="headerlink" title="jotai"></a>jotai</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// AgeAtom.ts</span><br><span class="hljs-keyword">import</span> &#123;atom&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;jotai&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> ageAtom = <span class="hljs-title function_">atom</span>(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// NameAtom.ts</span><br><span class="hljs-keyword">import</span> &#123;atom&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;jotai&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> nameAtom = <span class="hljs-title function_">atom</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br><br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// InfoAtom.ts</span><br><span class="hljs-keyword">import</span> &#123;atom&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;jotai&#x27;</span><br><span class="hljs-keyword">import</span> &#123;ageAtom, nameAtom&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./Atom&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> infoAtom = <span class="hljs-title function_">atom</span>(<span class="hljs-function">(<span class="hljs-params">get</span>) =&gt;</span> (&#123;<br>    <span class="hljs-attr">age</span>: <span class="hljs-title function_">get</span>(ageAtom),<br>    <span class="hljs-attr">name</span>: <span class="hljs-title function_">get</span>(nameAtom)<br>&#125;))<br></code></pre></td></tr></table></figure><p>在页面上使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;useAtomValue, useSetAtom&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;jotai&#x27;</span><br><span class="hljs-keyword">import</span> &#123;infoAtom, ageAtom, nameAtom&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./Atom&#x27;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> info = <span class="hljs-title function_">useAtomValue</span>(infoAtom)<br>    <span class="hljs-keyword">const</span> setAge = <span class="hljs-title function_">useSetAtom</span>(ageAtom)<br>    <span class="hljs-keyword">const</span> setName = <span class="hljs-title function_">useSetAtom</span>(nameAtom)<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                &#123;info.age&#125;</span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                &#123;info.name&#125;</span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setAge((age) =&gt; age + 1)&#125;&gt;+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setName((name) =&gt; name + &#x27;hualu&#x27;)&#125;&gt;add name<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/&gt;</span></span><br>    )<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h2>]]></content>
    
    
    <categories>
      
      <category>技术类-React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>状态管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack基础进阶和原理剖析</title>
    <link href="/20240509/webpack%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6%E5%92%8C%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    <url>/20240509/webpack%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6%E5%92%8C%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://webpack.docschina.org/concepts/">webpack官方中文文档</a></p></blockquote><h2 id="webpack-配置中的-loader-和-plugin-的区别"><a href="#webpack-配置中的-loader-和-plugin-的区别" class="headerlink" title="webpack 配置中的 loader 和 plugin 的区别"></a>webpack 配置中的 loader 和 plugin 的区别</h2><p>在 Webpack 中，<code>loader</code> 和 <code>plugin</code> 是实现构建能力的核心机制，但它们的作用和工作方式有本质区别：</p><h3 id="一、Loader（加载器）：处理非-JS-模块的“翻译官”"><a href="#一、Loader（加载器）：处理非-JS-模块的“翻译官”" class="headerlink" title="一、Loader（加载器）：处理非 JS 模块的“翻译官”"></a>一、Loader（加载器）：处理非 JS 模块的“翻译官”</h3><p>Webpack 本质上只能识别 JavaScript 和 JSON 文件，**loader 的核心作用是将非 JS 模块（如 CSS、图片、TS 等）转换为 Webpack 可处理的模块<br>**，从而纳入构建流程。</p><h4 id="1-工作原理"><a href="#1-工作原理" class="headerlink" title="1. 工作原理"></a>1. 工作原理</h4><ul><li><strong>执行时机</strong>：在 Webpack 解析代码的过程中（模块打包阶段），当遇到非 JS 模块时触发。</li><li><strong>执行顺序</strong>：从右到左（或从下到上）链式调用。例如：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 先执行 sass-loader 处理 SASS，再用 css-loader 处理 CSS，最后用 style-loader 注入到 DOM</span><br><span class="hljs-attr">module</span>: &#123;<br>  <span class="hljs-attr">rules</span>: [<br>    &#123;<br>      <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.s[ac]ss$/i</span>,<br>      <span class="hljs-attr">use</span>: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>, <span class="hljs-string">&#x27;sass-loader&#x27;</span>] <br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure></li><li><strong>输入输出</strong>：接收源文件内容作为参数，返回处理后的内容（通常是 JS 代码）。</li></ul><h4 id="2-常见场景"><a href="#2-常见场景" class="headerlink" title="2. 常见场景"></a>2. 常见场景</h4><ul><li><strong>语言转换</strong>：<code>babel-loader</code> 将 ES6+ 转换为 ES5；<code>ts-loader</code> 将 TypeScript 转换为 JS。</li><li><strong>样式处理</strong>：<code>css-loader</code> 解析 CSS 中的 <code>@import</code> 和 <code>url()</code>；<code>style-loader</code> 将 CSS 注入到页面 <code>&lt;style&gt;</code> 标签；<br><code>sass-loader</code> 编译 SASS/SCSS 为 CSS。</li><li><strong>资源处理</strong>：<code>file-loader</code> 处理图片、字体等资源并输出到指定目录；<code>url-loader</code> 在文件体积较小时将资源转为 Base64 嵌入代码。</li></ul><h3 id="二、Plugin（插件）：扩展构建流程的“功能增强器”"><a href="#二、Plugin（插件）：扩展构建流程的“功能增强器”" class="headerlink" title="二、Plugin（插件）：扩展构建流程的“功能增强器”"></a>二、Plugin（插件）：扩展构建流程的“功能增强器”</h3><p>Plugin 用于<strong>扩展 Webpack 的功能</strong>，可以介入构建的整个生命周期（从初始化到输出产物），实现loader<br>无法完成的复杂操作（如打包优化、环境变量注入、资源管理等）。</p><h4 id="1-工作原理-1"><a href="#1-工作原理-1" class="headerlink" title="1. 工作原理"></a>1. 工作原理</h4><ul><li><strong>基于钩子机制</strong>：Webpack 在构建过程中会触发一系列生命周期钩子（如 <code>entryOption</code>、<code>compile</code>、<code>emit</code> 等），plugin<br>通过注册这些钩子，在特定时机执行自定义逻辑。</li><li><strong>灵活性高</strong>：可以修改输出资源、调整构建流程、生成额外文件等。</li></ul><h4 id="2-常见场景-1"><a href="#2-常见场景-1" class="headerlink" title="2. 常见场景"></a>2. 常见场景</h4><ul><li><strong>优化输出</strong>：<code>TerserPlugin</code> 压缩 JS 代码；<code>MiniCssExtractPlugin</code> 将 CSS 提取为单独文件（替代 <code>style-loader</code>）。</li><li><strong>环境配置</strong>：<code>DefinePlugin</code> 注入全局环境变量（如 <code>process.env.NODE_ENV</code>）。</li><li><strong>性能分析</strong>：<code>BundleAnalyzerPlugin</code> 可视化打包产物，分析体积过大的原因。</li><li><strong>资源处理</strong>：<code>CopyWebpackPlugin</code> 复制静态资源到输出目录；<code>HtmlWebpackPlugin</code> 自动生成 HTML 并引入打包后的资源。</li></ul><h3 id="三、核心区别"><a href="#三、核心区别" class="headerlink" title="三、核心区别"></a>三、核心区别</h3><table><thead><tr><th>维度</th><th>Loader</th><th>Plugin</th></tr></thead><tbody><tr><td>作用对象</td><td>针对<strong>模块文件</strong>（如 CSS、TS）</td><td>针对<strong>整个构建流程</strong></td></tr><tr><td>功能范围</td><td>仅处理文件转换（输入→输出内容）</td><td>可扩展任意构建功能（优化、注入、生成等）</td></tr><tr><td>用法</td><td>在 <code>module.rules</code> 中配置</td><td>在 <code>plugins</code> 数组中实例化</td></tr><tr><td>执行时机</td><td>模块解析阶段</td><td>整个生命周期（从初始化到输出）</td></tr></tbody></table><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><ul><li><strong>Loader 解决“Webpack 不能识别非 JS 模块”的问题</strong>，专注于文件内容的转换。</li><li><strong>Plugin 解决“扩展 Webpack 功能”的问题</strong>，通过钩子机制介入构建全流程，实现更复杂的需求。</li></ul><p>两者相辅相成：Loader 负责“翻译”各类资源，Plugin 负责“增强”构建过程，共同构成了 Webpack 灵活强大的构建能力。</p><h2 id="自定义-loader"><a href="#自定义-loader" class="headerlink" title="自定义 loader"></a>自定义 loader</h2><p>写一个 <code>uppercase-loader</code>，实现将文件内容转换为大写</p><p>loader 本质是函数，做编译的增强</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// /loaders/uppercase-loader.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">uppercaseLoader</span> (<span class="hljs-params">source</span>) &#123;<br>    <span class="hljs-keyword">return</span> source.<span class="hljs-title function_">toUpperCase</span>()<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// webpack.config.dev.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-attr">output</span>: &#123;<br>        <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),<br>        <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;main.js&#x27;</span><br>    &#125;,<br>    <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,<br>    <span class="hljs-attr">module</span>:&#123;<br>        <span class="hljs-attr">rules</span>:[<br>            &#123;<br>                <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,<br>                <span class="hljs-attr">use</span>:[<span class="hljs-string">&#x27;./loaders/uppercase-loader.js&#x27;</span>]<br>            &#125;<br>        ]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="自定义-plugin"><a href="#自定义-plugin" class="headerlink" title="自定义 plugin"></a>自定义 plugin</h2><p>plugin 本质是类，做构建的增强</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 产物统计</span><br><span class="hljs-comment">// /plugins/AssetsMapPlugin.js</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AssetsMapPlugin</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">options</span>)&#123;<br>        <br>    &#125;<br>    <span class="hljs-title function_">apply</span>(<span class="hljs-params">compiler</span>)&#123;<br>        <span class="hljs-comment">// compiler 是 webpack 实例，通过 compiler 可以访问到 webpack 所有的配置和插件</span><br>        compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">initialize</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-string">&#x27;AssetsMapPlugin&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">compilation</span>) =&gt;</span> &#123;<br>            <span class="hljs-comment">// compilation 是当前打包的上下文，通过 compilation 可以访问到当前打包的所有资源</span><br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(compilation.<span class="hljs-property">assets</span>)<br>        &#125;)<br>        compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">run</span>.<span class="hljs-title function_">tapAsync</span>(<span class="hljs-string">&#x27;AssetsMapPlugin&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">compilation, next</span>) =&gt;</span> &#123;<br>            <span class="hljs-comment">// compilation 是当前打包的上下文，通过 compilation 可以访问到当前打包的所有资源</span><br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(compilation.<span class="hljs-property">assets</span>)<br>            <span class="hljs-keyword">let</span> fileList = <span class="hljs-string">&quot;&quot;</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> fileName <span class="hljs-keyword">in</span> compilation.<span class="hljs-property">assets</span>) &#123;<br>                fileList += fileName + <span class="hljs-string">&#x27;\n&#x27;</span><br>            &#125;<br>            compilation.<span class="hljs-property">assets</span>[<span class="hljs-string">&#x27;file-list.md&#x27;</span>] = &#123;<br>                <span class="hljs-attr">source</span>: <span class="hljs-function">() =&gt;</span> fileList,<br>                <span class="hljs-attr">size</span>: <span class="hljs-function">() =&gt;</span> fileList.<span class="hljs-property">length</span><br>            &#125;<br>            <span class="hljs-title function_">next</span>() <span class="hljs-comment">// 必须调用 next 才能继续打包，权限交给下一个插件</span><br>        &#125;)<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// webpack.config.dev.js</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-attr">plugins</span>: [<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">AssetsMapPlugin</span>()<br>    ]<br>&#125; <br><br></code></pre></td></tr></table></figure><p>会输出一个 <code>file-list.md</code> 文件，内容是当前打包的所有资源文件名</p><h2 id="webpack-原理核心"><a href="#webpack-原理核心" class="headerlink" title="webpack 原理核心"></a>webpack 原理核心</h2><ol><li>compiler</li><li>compilation</li><li>module</li><li>chunk</li><li>dependency</li><li>resolver</li><li>loader </li><li>plugin</li></ol>]]></content>
    
    
    <categories>
      
      <category>工程化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Webpack</tag>
      
      <tag>工程化&#39;</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue-router 剖析和实现</title>
    <link href="/20240405/vue%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/"/>
    <url>/20240405/vue%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/</url>
    
    <content type="html"><![CDATA[<h2 id="实现一个-Vue-Router，需要考虑的问题有哪些？"><a href="#实现一个-Vue-Router，需要考虑的问题有哪些？" class="headerlink" title="实现一个 Vue-Router，需要考虑的问题有哪些？"></a>实现一个 Vue-Router，需要考虑的问题有哪些？</h2><ul><li>如何将状态和路由记录同步</li><li>如何通过判断路由记录决定渲染哪个视图</li><li>如何处理更新问题</li></ul><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/History">BrowserHistory</a>，原生 API 可以监听路有变化？</p><ul><li>hash</li><li>history</li></ul><h1 id="实现一个-hash-路由"><a href="#实现一个-hash-路由" class="headerlink" title="实现一个 hash 路由"></a>实现一个 hash 路由</h1><p><strong>HTML 部分</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;header&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#about&quot;</span>&gt;</span>关于<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#me&quot;</span>&gt;</span>我的<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;window.history.go(-1)&quot;</span>&gt;</span>返回<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.header</span> &#123;</span><br><span class="language-css">      <span class="hljs-attribute">background-color</span>: black;</span><br><span class="language-css">      <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">      <span class="hljs-attribute">line-height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">      <span class="hljs-attribute">display</span>: flex;</span><br><span class="language-css">      <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;</span><br><span class="language-css">      <span class="hljs-attribute">justify-content</span>: space-around;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span>,</span><br><span class="language-css">    <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span>,</span><br><span class="language-css">    <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span>,</span><br><span class="language-css">    <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span> &#123;</span><br><span class="language-css">      <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;</span><br><span class="language-css">      <span class="hljs-attribute">text-decoration</span>: none;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./hashroutes.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>JS 部分</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Route</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">routes</span> = &#123;&#125;;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">refresh</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">refresh</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;load&quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">refresh</span>);<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;hashchange&quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">refresh</span>);<br>  &#125;<br><br>  <span class="hljs-title function_">route</span>(<span class="hljs-params">path, callback</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">routes</span>[path] = callback || <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125;;<br>  &#125;<br><br>  <span class="hljs-title function_">refresh</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-keyword">let</span> path = <span class="hljs-string">`/<span class="hljs-subst">$&#123;<span class="hljs-variable language_">window</span>.location.hash.slice(<span class="hljs-number">1</span>) || <span class="hljs-string">&quot;&quot;</span>&#125;</span>`</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(path);<br>    <span class="hljs-keyword">let</span> cb = <span class="hljs-variable language_">this</span>.<span class="hljs-property">routes</span>[path];<br>    cb &amp;&amp; <span class="hljs-title function_">cb</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-title class_">Router</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Route</span>();<br><span class="hljs-keyword">let</span> body = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;body&quot;</span>);<br><span class="hljs-title class_">Router</span>.<span class="hljs-title function_">route</span>(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) &#123;<br>  body.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = <span class="hljs-string">&quot;red&quot;</span>;<br>&#125;);<br><br><span class="hljs-title class_">Router</span>.<span class="hljs-title function_">route</span>(<span class="hljs-string">&quot;/about&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  body.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = <span class="hljs-string">&quot;blue&quot;</span>;<br>&#125;);<br><br><span class="hljs-title class_">Router</span>.<span class="hljs-title function_">route</span>(<span class="hljs-string">&quot;/me&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  body.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = <span class="hljs-string">&quot;green&quot;</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="实现一个-history-路由"><a href="#实现一个-history-路由" class="headerlink" title="实现一个 history 路由"></a>实现一个 history 路由</h1><p>hash 虽然能解决问题，但是带有#不太美观。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ol><li>window.history.back()</li><li>window.history.forward()</li><li>window.history.go(number)</li><li>window.history.pushState() 新增=》A B =》 A B C</li><li>window.history.replaceState() 覆盖/替换 A B =》 A C</li></ol><ul><li>history 模式下可以使用 Popstate 事件来监听 url 的变化</li><li>pushState 和 replaceState 并不会触发 Popstate 事件</li><li>哪些情况会触发 popstate 呢？<ul><li>浏览器的前进/后退按钮</li><li>history/back/forward/go</li></ul></li></ul><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ol><li>state:是一个对象，是一个指定网址相关的状态对象，如果不需要，可以为 null</li><li>title：新页面的标题，null</li><li>URL：新的网址，必须与当前页面出于同一个域，才会显示</li></ol><p><strong>部署 history 路由的时候，要使你的路由中的所有 path 都访问到 index.html 文件</strong></p><h2 id="HTML-部分"><a href="#HTML-部分" class="headerlink" title="HTML 部分"></a>HTML 部分</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;header&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/gray&quot;</span>&gt;</span>灰色<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/green&quot;</span>&gt;</span>绿色<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/&quot;</span>&gt;</span>白色<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;window.history.go(-1)&quot;</span>&gt;</span>返回<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.header</span> &#123;</span><br><span class="language-css">      <span class="hljs-attribute">background-color</span>: black;</span><br><span class="language-css">      <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">      <span class="hljs-attribute">line-height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">      <span class="hljs-attribute">display</span>: flex;</span><br><span class="language-css">      <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;</span><br><span class="language-css">      <span class="hljs-attribute">justify-content</span>: space-around;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span>,</span><br><span class="language-css">    <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span>,</span><br><span class="language-css">    <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span>,</span><br><span class="language-css">    <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span> &#123;</span><br><span class="language-css">      <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;</span><br><span class="language-css">      <span class="hljs-attribute">text-decoration</span>: none;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./hashroutes.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="JS-部分"><a href="#JS-部分" class="headerlink" title="JS 部分"></a>JS 部分</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Route</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">routes</span> = &#123;&#125;;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">bindPopState</span>();<br>  &#125;<br><br>  <span class="hljs-title function_">route</span>(<span class="hljs-params">path, callback</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">routes</span>[path] = callback || <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125;;<br>  &#125;<br><br>  <span class="hljs-title function_">init</span>(<span class="hljs-params">path</span>) &#123;<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">history</span>.<span class="hljs-title function_">replaceState</span>(&#123; path &#125;, <span class="hljs-literal">null</span>, path);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">execCallbackByPath</span>(path);<br>  &#125;<br><br>  <span class="hljs-title function_">bindPopState</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;popstate&quot;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> path = e.<span class="hljs-property">state</span> &amp;&amp; e.<span class="hljs-property">state</span>.<span class="hljs-property">path</span>;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(path);<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">execCallbackByPath</span>(path);<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-title function_">go</span>(<span class="hljs-params">path</span>) &#123;<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">history</span>.<span class="hljs-title function_">pushState</span>(<br>      &#123;<br>        path,<br>      &#125;,<br>      <span class="hljs-literal">null</span>,<br>      path<br>    );<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">execCallbackByPath</span>(path);<br>  &#125;<br><br>  <span class="hljs-title function_">execCallbackByPath</span>(<span class="hljs-params">path</span>) &#123;<br>    <span class="hljs-keyword">const</span> cb = <span class="hljs-variable language_">this</span>.<span class="hljs-property">routes</span>[path];<br>    <span class="hljs-keyword">if</span> (cb) &#123;<br>      <span class="hljs-title function_">cb</span>();<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-title class_">Router</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Route</span>();<br><span class="hljs-keyword">let</span> body = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;body&quot;</span>);<br><span class="hljs-title class_">Router</span>.<span class="hljs-title function_">route</span>(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) &#123;<br>  body.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = <span class="hljs-string">&quot;red&quot;</span>;<br>&#125;);<br><br><span class="hljs-title class_">Router</span>.<span class="hljs-title function_">route</span>(<span class="hljs-string">&quot;/about&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  body.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = <span class="hljs-string">&quot;blue&quot;</span>;<br>&#125;);<br><br><span class="hljs-title class_">Router</span>.<span class="hljs-title function_">route</span>(<span class="hljs-string">&quot;/me&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  body.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = <span class="hljs-string">&quot;green&quot;</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="VueRouter"><a href="#VueRouter" class="headerlink" title="VueRouter"></a>VueRouter</h1><ol><li>vue router 从列表浏览了一段时间,点击进了一个详情页,然后返回的时候,我期望回到列表页还是停留在原来的浏览位置,你可以怎么做?</li></ol><ul><li>keep-alive</li><li>localStorage/sessionStorage + scrollTop + scrollTo</li><li>scrollBehavior</li></ul><ol start="2"><li>router-view 是什么?</li></ol><p>类似于动态的组件.</p><p>找到当前路径对应的 component, 并展示出来.</p>]]></content>
    
    
    <categories>
      
      <category>技术类-Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NEXT.JS从入门到放弃</title>
    <link href="/20240130/NEXT-JS%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/"/>
    <url>/20240130/NEXT-JS%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/</url>
    
    <content type="html"><![CDATA[<blockquote><p>包学包会！看完你也会</p><p>NEXT.JS 官方英文文档：<a href="https://nextjs.org/">https://nextjs.org/</a></p><p>中文文档不建议看，落后太多！</p></blockquote><h1 id="1-初始篇"><a href="#1-初始篇" class="headerlink" title="1. 初始篇"></a>1. 初始篇</h1><h3 id="1-1-创建项目"><a href="#1-1-创建项目" class="headerlink" title="1.1 创建项目"></a>1.1 创建项目</h3><p>使用 create-next-app 脚手架</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs node">npx<br>create - next - app<br></code></pre></td></tr></table></figure><p>如果你不使用 npx，也支持使用 yarn、pnpm、bunx</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs node">yarn<br>create<br>next - app<br><br>pnpm<br>create<br>next - app<br><br>bunx<br>create - next - app<br></code></pre></td></tr></table></figure><h3 id="1-2-运行项目"><a href="#1-2-运行项目" class="headerlink" title="1.2 运行项目"></a>1.2 运行项目</h3><p>查看项目根目录 package.json 文件的代码：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;dev&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;next dev&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;next build&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;next start&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;lint&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;next lint&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>开发的时候使用 <code>npm run dev</code>。部署的时候先使用 <code>npm run build</code>构建生产代码，再执行 <code>npm run start</code><br>运行生产项目。运行 <code>npm run lint</code>则会执行 <code>ESLint</code> 语法检查。</p><h1 id="2-路由篇-App-Router"><a href="#2-路由篇-App-Router" class="headerlink" title="2. 路由篇(App Router)"></a>2. 路由篇(App Router)</h1><p>Next.js 目前有两套路由解决方案，之前的方案称之为“Pages Router”，目前的方案称之为“App Router”，两套方案是兼容的，都可以在<br>Next.js 中使用。</p><p>目前，我们主要学习“App Router”。</p><h2 id="1-文件系统"><a href="#1-文件系统" class="headerlink" title="1. 文件系统"></a>1. 文件系统</h2><p>Next.js 的路由基于的是文件系统，也就是说，一个文件就可以是一个路由。举个例子，你在 app/pages 目录下创建一个 index.js<br>文件，它会直接映射到 / 路由地址；在 app/pages 目录下创建一个 about.js 文件，它会直接映射到 /about 路由地址。</p><h2 id="2-App-Router"><a href="#2-App-Router" class="headerlink" title="2. App Router"></a>2. App Router</h2><h3 id="2-1-定义路由"><a href="#2-1-定义路由" class="headerlink" title="2.1 定义路由"></a>2.1 定义路由</h3><p>文件夹被用来定义路由。</p><p><code>app/dashboard/settings</code>目录对应的路由地址就是 <code>/dashboard/settings</code></p><h3 id="2-2-定义页面（Pages）"><a href="#2-2-定义页面（Pages）" class="headerlink" title="2.2 定义页面（Pages）"></a>2.2 定义页面（Pages）</h3><p>你需要创建一个特殊的名为 <code>page.js</code> 的文件，这是一种约定和规范</p><p><img src="/20240130/NEXT-JS%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image.png" alt="目录结构"></p><p>在上图这个例子中:</p><ul><li>app/page.js 对应路由 /</li><li>app/dashboard/page.js 对应路由 /dashboard</li><li>app/dashboard/settings/page.js 对应路由/dashboard/settings</li><li>analytics 目录下因为没有 page.js 文件，所以没有对应的路由。这个文件可以被用于存放组件、样式表、图片或者其他文件。</li></ul><p>page.js 的代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// app/page.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, Next.js!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-定义布局（Layouts）"><a href="#2-3-定义布局（Layouts）" class="headerlink" title="2.3 定义布局（Layouts）"></a>2.3 定义布局（Layouts）</h3><p>布局是指<strong>多个页面共享的 UI。在导航的时候，布局会保留状态，保持可交互性并且不会重新渲染</strong>，比如用来实现后台管理系统的侧边导航栏。</p><p>定义一个布局，你需要新建一个名为 <code>layout.js</code>的文件，该文件默认导出一个 React 组件，该组件应接收一个 <code>children</code><br>prop，<code>chidren</code> 表示子布局（如果有的话）或者子页面。</p><p><img src="/20240130/NEXT-JS%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/%E5%AE%9A%E4%B9%89%E5%B8%83%E5%B1%80.png" alt="目录结构"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// app/dashboard/layout.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">DashboardLayout</span>(<span class="hljs-params">&#123;</span><br><span class="hljs-params">                                            children,</span><br><span class="hljs-params">                                        &#125;</span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">nav</span>&gt;</span>nav<span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span></span><br><span class="language-xml">            &#123;children&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span></span><br>    )<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// app/dashboard/page.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, Dashboard!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/20240130/NEXT-JS%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/%E5%AE%9A%E4%B9%89%E5%B8%83%E5%B1%802.png" alt="显示"></p><p>你可以发现：同一文件夹下如果有 layout.js 和 page.js，page 会作为 children 参数传入 layout。换句话说，layout 会包裹同层级的<br>page。</p><h4 id="根布局（Root-Layout）"><a href="#根布局（Root-Layout）" class="headerlink" title="根布局（Root Layout）"></a>根布局（Root Layout）</h4><p>布局支持嵌套，最顶层的布局我们称之为根布局（Root Layout），也就是 <code>app/layout.js</code>。它会应用于所有的路由。除此之外，这个布局还有点特殊。</p><p>使用 <code>create-next-app</code> 默认创建的 <code>layout.js</code> 代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// app/layout.js</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./globals.css&#x27;</span><br><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">Inter</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;next/font/google&#x27;</span><br><br><span class="hljs-keyword">const</span> inter = <span class="hljs-title class_">Inter</span>(&#123;<span class="hljs-attr">subsets</span>: [<span class="hljs-string">&#x27;latin&#x27;</span>]&#125;)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> metadata = &#123;<br>    <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Create Next App&#x27;</span>,<br>    <span class="hljs-attr">description</span>: <span class="hljs-string">&#x27;Generated by create next app&#x27;</span>,<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">RootLayout</span>(<span class="hljs-params">&#123;children&#125;</span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;inter.className&#125;</span>&gt;</span>&#123;children&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br>    )<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>app 目录必须包含根布局，也就是 app/layout.js 这个文件是必需的。</li><li>根布局必须包含 html 和 body标签，其他布局不能包含这些标签。但如果你要更改这些标签，不推荐直接修改，Next.js<br>提供内置工具帮助你管理诸如 <code>&lt;title /&gt;</code> 这样的 HTML 元素。</li><li>你可以使用路由组创建多个根布局。</li><li>默认根布局是服务端组件，且不能设置为客户端组件。</li></ul><h3 id="2-4-定义模板（Templates）"><a href="#2-4-定义模板（Templates）" class="headerlink" title="2.4 定义模板（Templates）"></a>2.4 定义模板（Templates）</h3><p>模板类似于布局，它也会传入每个子布局或者页面。但不会像布局那样维持状态。</p><p>模板在路由切换时会为每一个 <code>children</code> 创建一个实例。这就意味着当用户在共享一个模板的路由间跳转的时候，将会重新挂载组件实例，重新创建<br>DOM 元素，不保留状态。</p><p>定义一个模板，你需要新建一个名为 template.js 的文件，该文件默认导出一个 React 组件，该组件接收一个 children prop。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// app/template.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Template</span>(<span class="hljs-params">&#123;children&#125;</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;children&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>你会发现，这用法跟布局一模一样。它们最大的区别就是状态的保持。如果同一目录下既有 <code>template.js</code> 也有 <code>layout.js</code>,<code>layout</code><br>会包裹 <code>template</code>，<code>template</code> 又会包裹 <code>page</code></p><p>模板会比布局更适合以下场景：</p><ol><li><p>依赖于 useEffect 和 useState 的功能，比如记录页面访问数（维持状态就不会在路由切换时记录访问数了）、用户反馈表单（每次重新填写）等</p></li><li><p>更改框架的默认行为，举个例子，布局内的 Suspense 只会在布局加载的时候展示一次 fallback UI，当切换页面的时候不会展示。但是使用模板，fallback<br>会在每次路由切换的时候展示。</p></li></ol><h3 id="2-5-定义加载页面（Loading-UI）"><a href="#2-5-定义加载页面（Loading-UI）" class="headerlink" title="2.5 定义加载页面（Loading UI）"></a>2.5 定义加载页面（Loading UI）</h3><p>App Router 提供了用于展示加载界面的 <code>loading.js</code>。</p><p>这个功能的实现借助了 React 的<code>Suspense</code> API。关于 Suspense<br>的用法，可以查看 <a href="https://juejin.cn/post/7163934860694781989">《React 之 Suspense》</a>。它实现的效果就是当发生路由变化的时候，立刻展示<br>fallback UI，等加载完成后，展示数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 在 ProfilePage 组件处于加载阶段时显示 Spinner</span><br>&lt;<span class="hljs-title class_">Suspense</span> fallback=&#123;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Spinner</span>/&gt;</span></span>&#125;&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ProfilePage</span>/&gt;</span></span><br>&lt;/<span class="hljs-title class_">Suspense</span>&gt;<br></code></pre></td></tr></table></figure><p>新建一个loading.js 文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// app/dashboard/loading.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">DashboardLoading</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span>Loading dashboard...<span class="hljs-tag">&lt;/&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>同级的page.js文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// app/dashboard/page.js</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getData</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">3000</span>))<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello, Dashboard!&#x27;</span>,<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">DashboardPage</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123;message&#125; = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getData</span>()<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;message&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样页面的加载loading效果就出现了。</p><p>其关键在于 page.js导出了一个 <code>async</code> 函数。</p><p><code>loading.js</code> 的实现原理是将 <code>page.js</code>和下面的 children 用 <code>&lt;Suspense&gt;</code> 包裹。因为<code>page.js</code>导出一个 async 函数，Suspense<br>得以捕获数据加载的 promise，借此实现了 loading 组件的关闭。</p><h3 id="2-6-定义错误处理（Error-Handling）"><a href="#2-6-定义错误处理（Error-Handling）" class="headerlink" title="2.6 定义错误处理（Error Handling）"></a>2.6 定义错误处理（Error Handling）</h3><p><code>error.js</code>。顾名思义，用来创建发生错误时的展示 UI。</p><p>其实现借助了 React<br>的 <a href="https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary">Error Boundary</a><br>功能。简单来说，就是给 page.js 和 children 包了一层 <code>ErrorBoundary</code>。</p><p>新建一个 <code>error.js</code> 文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&#x27;use client&#x27;</span> <span class="hljs-comment">// 错误组件必须是客户端组件</span><br><span class="hljs-comment">// dashboard/error.js</span><br><span class="hljs-keyword">import</span> &#123;useEffect&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Error</span>(<span class="hljs-params">&#123;error, reset&#125;</span>) &#123;<br>    <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error)<br>    &#125;, [error])<br><br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Something went wrong!<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">                <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;</span></span></span><br><span class="hljs-tag"><span class="language-xml">                    // <span class="hljs-attr">尝试恢复</span></span></span><br><span class="hljs-tag"><span class="language-xml">                    () =&gt;</span> reset()</span><br><span class="language-xml">                &#125;</span><br><span class="language-xml">            &gt;</span><br><span class="language-xml">                Try again</span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p>同级 <code>page.js</code> 的代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&quot;use client&quot;</span>;<br><span class="hljs-comment">// dashboard/page.js</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> [error, setError] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleGetError</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        <span class="hljs-title function_">setError</span>(<span class="hljs-literal">true</span>);<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span>&#123;error ? Error() : <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleGetError&#125;</span>&gt;</span>Get Error<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>&#125;<span class="hljs-tag">&lt;/&gt;</span></span><br>    );<br>&#125;<br></code></pre></td></tr></table></figure><p>当前这些特殊文件的层级关系如下图：<br><img src="/20240130/NEXT-JS%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/%E5%B1%82%E7%BA%A7%E5%85%B3%E7%B3%BB.png" alt="层级关系"></p><p>因为 <code>Layout</code> 和 <code>Template</code> 在 <code>ErrorBoundary</code> 外面，这说明错误边界不能捕获同级的 <code>layout.js</code> 或者 <code>template.js</code><br>中的错误。如果你想捕获特定布局或者模板中的错误，那就在父级的 <code>error.js</code> 里进行捕获。</p><p>那问题来了，如果已经到了顶层，就比如根布局中的错误如何捕获呢？为了解决这个问题，Next.js 提供了 <code>global-error.js</code>文件，使用它时，将其放在<br>app 目录下。</p><p><code>global-error.js</code>会包裹整个应用，而且当它触发的时候，它会替换掉根布局的内容。所以，<code>global-error.js</code> 中也要定义 <code>&lt;html&gt;</code><br>和 <code>&lt;body&gt;</code><br>标签。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&#x27;use client&#x27;</span><br><span class="hljs-comment">// app/global-error.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">GlobalError</span>(<span class="hljs-params">&#123;error, reset&#125;</span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Something went wrong!<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> reset()&#125;&gt;Try again<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p>注：<code>global-error.js</code> 用来处理根布局和根模板中的错误，<code>app/error.js</code> 建议还是要写的</p><h3 id="2-7-定义404页面"><a href="#2-7-定义404页面" class="headerlink" title="2.7 定义404页面"></a>2.7 定义404页面</h3><p><code>not-found.js</code>。顾名思义，当该路由不存在的时候展示的内容</p><p>需要在 app 目录下新建一个 <code>not-found.js</code>，代码示例如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Link</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;next/link&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">NotFound</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Not Found<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Could not find requested resource<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/&quot;</span>&gt;</span>Return Home<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们请求一个用户的数据时或是请求一篇文章的数据时，如果该数据不存在，就可以直接丢出 <code>notFound</code><br>函数，渲染自定义的<code>not-found</code><br>界面。一个示例代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// app/dashboard/blog/[id]/page.js</span><br><span class="hljs-keyword">import</span> &#123;notFound&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;next/navigation&#x27;</span><br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchUser</span>(<span class="hljs-params">id</span>) &#123;<br>    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://...&#x27;</span>)<br>    <span class="hljs-keyword">if</span> (!res.<span class="hljs-property">ok</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span><br>    <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">json</span>()<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Profile</span>(<span class="hljs-params">&#123;params&#125;</span>) &#123;<br>    <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchUser</span>(params.<span class="hljs-property">id</span>)<br><br>    <span class="hljs-keyword">if</span> (!user) &#123;<br>        <span class="hljs-title function_">notFound</span>()<br>    &#125;<br><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="链接与导航"><a href="#链接与导航" class="headerlink" title="链接与导航"></a>链接与导航</h2><p>知道了如何定义路由，最后我们再讲讲如何在 Next.js 中实现链接和导航。Next.js 提供了两种方式：</p><ol><li>使用 <code>&lt;Link&gt;</code> 组件</li><li>使用 <code>useRouter</code> Hook</li></ol><h3 id="lt-Link-gt"><a href="#lt-Link-gt" class="headerlink" title="&lt;Link&gt;"></a><code>&lt;Link&gt;</code></h3><p>使用方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Link</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;next/link&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/dashboard&quot;</span>&gt;</span>Dashboard<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果需要对当前链接进行判断，你可以使用 <code>usePathname()</code> 这个方法，它会读取当前 URL 的路径名（pathname），这是一段示例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&#x27;use client&#x27;</span><br><br><span class="hljs-keyword">import</span> &#123;usePathname&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;next/navigation&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Link</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;next/link&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Navigation</span>(<span class="hljs-params">&#123;navLinks&#125;</span>) &#123;<br>    <span class="hljs-keyword">const</span> pathname = <span class="hljs-title function_">usePathname</span>()<br><br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">            &#123;navLinks.map((link) =&gt; &#123;</span><br><span class="language-xml">                const isActive = pathname === link.href</span><br><span class="language-xml">                return (</span><br><span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">Link</span></span></span><br><span class="hljs-tag"><span class="language-xml">                        <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;isActive</span> ? &#x27;<span class="hljs-attr">text-blue</span>&#x27; <span class="hljs-attr">:</span> &#x27;<span class="hljs-attr">text-black</span>&#x27;&#125;</span></span><br><span class="hljs-tag"><span class="language-xml">                        <span class="hljs-attr">href</span>=<span class="hljs-string">&#123;link.href&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">                        <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;link.name&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">                    &gt;</span></span><br><span class="language-xml">                        &#123;link.name&#125;</span><br><span class="language-xml">                    <span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span></span><br><span class="language-xml">                )</span><br><span class="language-xml">            &#125;)&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/&gt;</span></span><br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p>App Router 的默认行为是滚动到新路由的顶部，或者在前进后退导航时维持之前的滚动距离。</p><p>如果你想要禁用这个行为，你可以给 <code>&lt;Link&gt;</code> 组件传递一个 <code>scroll=&#123;false&#125;</code>，或者在使用 <code>router.push</code>和 <code>router.replace</code>的时候，设置<br><code>scroll: false</code>。</p><p>示例代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// next/link</span><br>&lt;<span class="hljs-title class_">Link</span> href=<span class="hljs-string">&quot;/dashboard&quot;</span> scroll=&#123;<span class="hljs-literal">false</span>&#125;&gt;<br>    <span class="hljs-title class_">Dashboard</span><br>&lt;/<span class="hljs-title class_">Link</span>&gt;<br></code></pre></td></tr></table></figure><p>或者：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// useRouter</span><br><span class="hljs-keyword">import</span> &#123;useRouter&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;next/navigation&#x27;</span><br><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">useRouter</span>()<br><br>router.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;/dashboard&#x27;</span>, &#123;<span class="hljs-attr">scroll</span>: <span class="hljs-literal">false</span>&#125;)<br></code></pre></td></tr></table></figure><h3 id="useRouter"><a href="#useRouter" class="headerlink" title="useRouter"></a><code>useRouter</code></h3><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&#x27;use client&#x27;</span><br><br><span class="hljs-keyword">import</span> &#123;useRouter&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;next/navigation&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> router = <span class="hljs-title function_">useRouter</span>()<br><br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> router.push(&#x27;/dashboard&#x27;)&#125;&gt;</span><br><span class="language-xml">            Dashboard</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p>注意使用该 hook 需要在客户端组件中。（顶层的 <code>use client</code> 就是声明这是客户端组件）</p><h1 id="3-路由篇（动态路由、路由组、平行路由、拦截路由）"><a href="#3-路由篇（动态路由、路由组、平行路由、拦截路由）" class="headerlink" title="3. 路由篇（动态路由、路由组、平行路由、拦截路由）"></a>3. 路由篇（动态路由、路由组、平行路由、拦截路由）</h1><h2 id="1-动态路由"><a href="#1-动态路由" class="headerlink" title="1. 动态路由"></a>1. 动态路由</h2><p>有的时候，你并不能提前知道路由的地址，就比如根据 URL 中的 id 参数展示该 id 对应的文章内容，文章那么多，我们不可能一一定义路由，这个时候就需要用到动态路由。</p><h3 id="1-1-folderName"><a href="#1-1-folderName" class="headerlink" title="1.1 [folderName]"></a>1.1 [folderName]</h3><p>使用动态路由，你需要将文件夹的名字用方括号括住，比如 <code>[id]</code>、<code>[slug]</code>。这个路由的名字会作为 <code>param</code> prop 传给<code>布局（layout）</code>、 <code>页面（page）</code>、 <code>路由处理程序（route）</code>以及 <code>generateMetadata（用于生成页面元数据）</code> 函数。</p><p>举个例子，我们在 <code>app/blog</code> 目录下新建一个名为<code>[slug]</code>的文件夹，在该文件夹新建一个 <code>page.js</code> 文件，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// app/blog/[slug]/page.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params">&#123; params &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>My Post: &#123;params.slug&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>页面效果 ：</p><p><img src="/20240130/NEXT-JS%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/foldername.png" alt="Alt text"></p><h3 id="1-2-…folderName"><a href="#1-2-…folderName" class="headerlink" title="1.2 […folderName]"></a>1.2 […folderName]</h3><p>如果你在方括号内添加省略号，比如 <code>[...folderName]</code>，这表示捕获所有后面所有的路由片段。</p><p>也就是说，<code>app/shop/[...slug]/page.js</code>会匹配 <code>/shop/clothes</code>，也会匹配<code> /shop/clothes/tops</code>、<code>/shop/clothes/tops/t-shirts</code>等等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// app/shop/[...slug]/page.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params">&#123; params &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>My Shop: &#123;JSON.stringify(params)&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>页面效果：<br><img src="/20240130/NEXT-JS%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/foldername1.png" alt="Alt text"></p><p>当你访问 <code>/shop/a</code>的时候，<code>params</code> 的值为 <code>&#123; slug: [&#39;a&#39;] &#125;</code>。</p><p>当你访问 <code>/shop/a/b</code>的时候，<code>params</code> 的值为 <code>&#123; slug: [&#39;a&#39;, &#39;b&#39;] &#125;</code>。</p><p>当你访问 <code>/shop/a/b/c</code>的时候，<code>params</code> 的值为 <code>&#123; slug: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] &#125;</code>。</p><h3 id="1-3-…folderName"><a href="#1-3-…folderName" class="headerlink" title="1.3 [[…folderName]]"></a>1.3 [[…folderName]]</h3><p>在命名文件夹的时候，如果你在双方括号内添加省略号，比如 [[…folderName]]，这表示可选的捕获所有后面所有的路由片段。</p><p>也就是说，<code>app/shop/[[...slug]]/page.js</code>会匹配 <code>/shop</code>，也会匹配 <code>/shop/clothes</code>、 <code>/shop/clothes/tops</code>、<code>/shop/clothes/tops/t-shirts</code>等等。</p><p>它与上一种的区别就在于，不带参数的路由也会被匹配（就比如 <code>/shop</code>）</p><h2 id="2-路由组（Route-groups）"><a href="#2-路由组（Route-groups）" class="headerlink" title="2. 路由组（Route groups）"></a>2. 路由组（Route groups）</h2><p>在 <code>app</code>目录下，文件夹名称通常会被映射到 URL 中，但你可以将文件夹标记为路由组，阻止文件夹名称被映射到 URL 中。</p><p>使用路由组，你可以将路由和项目文件按照逻辑进行分组，但不会影响 URL 路径结构。路由组可用于比如：</p><p>按站点、意图、团队等将路由分组</p><ol><li>在同一层级中创建多个布局，甚至是创建多个根布局</li><li>那么该如何标记呢？把文件夹用括号括住就可以了，就比如 <code>(dashboard)</code>。</li></ol><h3 id="2-1-按逻辑分组"><a href="#2-1-按逻辑分组" class="headerlink" title="2.1 按逻辑分组"></a>2.1 按逻辑分组</h3><p><img src="/20240130/NEXT-JS%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/routegroups.png" alt="按逻辑分组"></p><p>最终的url中省略了带括号的文件夹</p><h3 id="2-2-创建不同布局"><a href="#2-2-创建不同布局" class="headerlink" title="2.2 创建不同布局"></a>2.2 创建不同布局</h3><p>借助路由组，即便在同一层级，也可以创建不同的布局：</p><p><img src="/20240130/NEXT-JS%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/routegroups1.png" alt="创建不同的布局"></p><p>在这个例子中，<code>/account</code> 、<code>/cart</code>、<code>/checkout</code> 都在同一层级。但是 <code>/account</code>和 <code>/cart</code>使用的是 <code>/app/(shop)/layout.js</code>布局和<code>app/layout.js</code>布局，<code>/checkout</code>使用的是 <code>app/layout.js</code></p><h3 id="2-3-创建多个根布局"><a href="#2-3-创建多个根布局" class="headerlink" title="2.3 创建多个根布局"></a>2.3 创建多个根布局</h3><p><img src="/20240130/NEXT-JS%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/routegroups2.png" alt="创建多个根布局"></p><p>创建多个根布局，你需要删除掉 <code>app/layout.js</code> 文件，然后在每组都创建一个 <code>layout.js</code>文件。创建的时候要注意，因为是根布局，所以要有 <code>&lt;html&gt;</code> 和<code> &lt;body&gt;</code> 标签。</p><p>这个功能很实用，比如你将前台购买页面和后台管理页面都放在一个项目里，一个 C 端，一个 B 端，两个项目的布局肯定不一样，借助路由组，就可以轻松实现区分。</p><p>路由组tips：</p><ol><li>路由组的命名除了用于组织之外并无特殊意义。它们不会影响 URL 路径。</li><li>注意不要解析为相同的 URL 路径。举个例子，因为路由组不影响 URL 路径，所以 <code>(marketing)/about/page.js</code>和 <code>(shop)/about/page.js</code>都会解析为 <code>/about</code>，这会导致报错。</li><li>创建多个根布局的时候，因为删除了顶层的 <code>app/layout.js</code>文件，访问 <code>/</code>会报错，所以<code>app/page.js</code>需要定义在其中一个路由组中。</li><li>跨根布局导航会导致页面完全重新加载，就比如使用 <code>app/(shop)/layout.js</code>根布局的 <code>/cart</code> 跳转到使用 <code>app/(marketing)/layout.js</code>根布局的 <code>/blog</code> 会导致页面重新加载<code>（full page load）</code>。</li></ol>]]></content>
    
    
    <categories>
      
      <category>技术类-前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Next.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript通关秘籍</title>
    <link href="/20230816/TypeScript%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D/"/>
    <url>/20230816/TypeScript%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="TS类型系统支持哪些类型和类型运算"><a href="#TS类型系统支持哪些类型和类型运算" class="headerlink" title="TS类型系统支持哪些类型和类型运算"></a>TS类型系统支持哪些类型和类型运算</h1><h2 id="TS中的类型"><a href="#TS中的类型" class="headerlink" title="TS中的类型"></a>TS中的类型</h2><p>静态类型系统的目的是把类型检查从运行时提前到编译时。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">基础类型：number、boolean、string、object、symbol、undefined、null<br>包装类型：Number、Boolean、String、Object、Symbol<br>复合类型：class、Array<br>新增了三种类型：Tuple（元组）、Enum（枚举）、Interface（接口）<br></code></pre></td></tr></table></figure><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>元组是一种特殊的数组，它限定了数组元素的类型和个数。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">tuple</span>: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>] = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>];<br>tuple[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;b&#x27;</span>;<br>tuple[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>tuple[<span class="hljs-number">2</span>] = <span class="hljs-number">3</span>; <span class="hljs-comment">// Error: 不能将类型“3”分配给类型“undefined”</span><br></code></pre></td></tr></table></figure><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口(Interface)是一种类型，它可以描述函数、对象、构造器的结构：</p><p>描述对象：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">person</span>: <span class="hljs-title class_">Person</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">25</span><br>&#125;;<br>person.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Jerry&#x27;</span>;<br>person.<span class="hljs-property">age</span> = <span class="hljs-string">&#x27;25&#x27;</span>; <span class="hljs-comment">// Error: 不能将类型“&quot;25&quot;”分配给类型“number”</span><br></code></pre></td></tr></table></figure><p>描述函数：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SearchFunc</span> &#123;<br>    (<span class="hljs-attr">source</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">subString</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">boolean</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">mySearch</span>: <span class="hljs-title class_">SearchFunc</span>;<br>mySearch = <span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-attr">source</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">subString</span>: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-keyword">return</span> source.<span class="hljs-title function_">search</span>(subString) !== -<span class="hljs-number">1</span>;<br>&#125;;<br><span class="hljs-title function_">mySearch</span>(<span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>);<br></code></pre></td></tr></table></figure><p>描述构造器：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">PersonConstructor</span> &#123;<br>    <span class="hljs-title function_">new</span>(<span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>): <span class="hljs-title class_">IPerson</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createPerson</span>(<span class="hljs-params"><span class="hljs-attr">ctor</span>: <span class="hljs-title class_">PersonConstructor</span></span>): <span class="hljs-title class_">IPerson</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">ctor</span>(<span class="hljs-string">&#x27;guang&#x27;</span>, <span class="hljs-number">18</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>对象类型、class类型在TS中也叫做<code>索引类型</code>，因为它们都可以通过索引的方式访问属性。对象可以动态添加属性，如果不知道有什么属性，可以用索引签名。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IPerson</span> &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br><br>    [<span class="hljs-attr">propName</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">obj</span>: <span class="hljs-title class_">IPerson</span> = &#123;&#125;<br>obj.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;hualu&#x27;</span><br>obj.<span class="hljs-property">age</span> = <span class="hljs-number">18</span><br></code></pre></td></tr></table></figure><p>总之，接口可以用来描述函数、构造器、索引类型（对象、class、数组）等复合类型。</p><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举（Enum）是一系列值的复合：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;<span class="hljs-title class_">Red</span>, <span class="hljs-title class_">Green</span>, <span class="hljs-title class_">Blue</span>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">c</span>: <span class="hljs-title class_">Color</span> = <span class="hljs-title class_">Color</span>.<span class="hljs-property">Green</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>枚举的值默认从0开始，也可以手动指定：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;<span class="hljs-title class_">Red</span> = <span class="hljs-number">1</span>, <span class="hljs-title class_">Green</span> = <span class="hljs-number">2</span>, <span class="hljs-title class_">Blue</span> = <span class="hljs-number">4</span>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">c</span>: <span class="hljs-title class_">Color</span> = <span class="hljs-title class_">Color</span>.<span class="hljs-property">Green</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>枚举的值可以是字符串：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;<span class="hljs-title class_">Red</span> = <span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-title class_">Green</span> = <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-title class_">Blue</span> = <span class="hljs-string">&#x27;blue&#x27;</span>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">c</span>: <span class="hljs-title class_">Color</span> = <span class="hljs-title class_">Color</span>.<span class="hljs-property">Green</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c); <span class="hljs-comment">// green</span><br></code></pre></td></tr></table></figure><p>枚举的值可以是计算出来的：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;<span class="hljs-title class_">Red</span> = <span class="hljs-string">&#x27;red&#x27;</span>.<span class="hljs-property">length</span>, <span class="hljs-title class_">Green</span> = <span class="hljs-string">&#x27;green&#x27;</span>.<span class="hljs-property">length</span>, <span class="hljs-title class_">Blue</span> = <span class="hljs-string">&#x27;blue&#x27;</span>.<span class="hljs-property">length</span>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">c</span>: <span class="hljs-title class_">Color</span> = <span class="hljs-title class_">Color</span>.<span class="hljs-property">Green</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c); <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><h3 id="字面量类型"><a href="#字面量类型" class="headerlink" title="字面量类型"></a>字面量类型</h3><p>TypeScript 还支持<code>字面量类型</code>，也就是类似 1111、’aaaa’、{ a: 1} 这种值也可以做为类型。</p><p>字符串的字面量类型有两种，一种是普通的字符串字面量，比如 ‘aaa’，另一种是模版字面量，比如 aaa${string}，它的意思是以 aaa<br>开头，后面是任意 string 的字符串字面量类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>: <span class="hljs-string">&#x27;aaa&#x27;</span>;<br>a = <span class="hljs-string">&#x27;aaa&#x27;</span>;<br>a = <span class="hljs-string">&#x27;bbb&#x27;</span>; <span class="hljs-comment">// Error: 不能将类型“&quot;bbb&quot;”分配给类型“&quot;aaa&quot;”</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">b</span>: <span class="hljs-string">`aaa<span class="hljs-subst">$&#123;<span class="hljs-built_in">string</span>&#125;</span>`</span>;<br>b = <span class="hljs-string">&#x27;aaa&#x27;</span>;<br>b = <span class="hljs-string">&#x27;aaabbb&#x27;</span>;<br></code></pre></td></tr></table></figure><p>还有四种特殊的类型：<code>void</code>、<code>never</code>、<code>any</code>、<code>unknown</code>：</p><p><code>never</code> 代表不可达，比如函数抛异常的时候，返回值就是 never。</p><p><code>void</code> 代表空，可以是 undefined 或 never。</p><p><code>any</code> 是任意类型，任何类型都可以赋值给它，它也可以赋值给任何类型（除了 never）。</p><p><code>unknown</code> 是未知类型，任何类型都可以赋值给它，但是它不可以赋值给别的类型。</p><p>这些就是 TypeScript 类型系统中的全部类型了，大部分是从 JS 中迁移过来的，比如基础类型、Array、class 等，也添加了一些类型，比如<br>枚举（enum）、接口（interface）、元组等，还支持了字面量类型和 void、never、any、unknown 的特殊类型。</p><h2 id="类型的装饰"><a href="#类型的装饰" class="headerlink" title="类型的装饰"></a>类型的装饰</h2><p>除了描述类型的结构外，TypeScript 的类型系统还支持描述类型的属性，比如是否可选，是否只读等：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IPerson</span> &#123;<br>    <span class="hljs-keyword">readonly</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-attr">age</span>?: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">type</span> tuple = [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>?];<br></code></pre></td></tr></table></figure><hr><h1 id="TypeScript-类型系统中的类型运算"><a href="#TypeScript-类型系统中的类型运算" class="headerlink" title="TypeScript 类型系统中的类型运算"></a>TypeScript 类型系统中的类型运算</h1><h2 id="条件：extends"><a href="#条件：extends" class="headerlink" title="条件：extends ? :"></a>条件：extends ? :</h2><p>TypeScript 里的条件判断是 extends ? :，叫做条件类型（Conditional Type）。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> res = <span class="hljs-number">1</span> <span class="hljs-keyword">extends</span> <span class="hljs-number">2</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><p>这就是 TypeScript 类型系统里的 if else。</p><p>但是，上面这样的逻辑没啥意义，静态的值自己就能算出结果来，为什么要用代码去判断呢？</p><p>所以，类型运算逻辑都是用来做一些动态的类型的运算的，也就是对类型参数的运算。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> isTwo&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-number">2</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">type</span> res = isTwo&lt;<span class="hljs-number">1</span>&gt;;<br><span class="hljs-keyword">type</span> res2 = isTwo&lt;<span class="hljs-number">2</span>&gt;;<br></code></pre></td></tr></table></figure><p>这种类型也叫做<code>高级类型</code>。</p><p><strong>高级类型的特点是传入类型参数，经过一系列类型运算逻辑后，返回新的类型。</strong></p><h2 id="推倒：infer"><a href="#推倒：infer" class="headerlink" title="推倒：infer"></a>推倒：infer</h2><p>如何提取类型的一部分呢？答案是 infer。</p><p>比如提取元组类型的第一个元素：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">First</span>&lt;<span class="hljs-title class_">Tuple</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">unknown</span>[]&gt; = <span class="hljs-title class_">Tuple</span> <span class="hljs-keyword">extends</span> [infer T, ...infer R] ? T : <span class="hljs-built_in">never</span>;<br><br><span class="hljs-keyword">type</span> res = <span class="hljs-title class_">First</span>&lt;[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]&gt;;<br></code></pre></td></tr></table></figure><h2 id="联合："><a href="#联合：" class="headerlink" title="联合：|"></a>联合：|</h2><p>联合类型（Union Type）是指一个变量可以有多种类型，比如 number | string，表示这个变量可以是 number 类型，也可以是 string 类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> res = <span class="hljs-number">1</span> | <span class="hljs-number">2</span> | <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><h2 id="交叉：-amp"><a href="#交叉：-amp" class="headerlink" title="交叉：&amp;"></a>交叉：&amp;</h2><p>交叉类型（Intersection Type）是指一个变量可以同时拥有多种类型的属性，比如 number &amp; string，表示这个变量既拥有 number<br>类型的属性，也拥有 string 类型的属性。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> res = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125; &amp; &#123; <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;;<br></code></pre></td></tr></table></figure><p>注意，同一类型可以合并，不同的类型没法合并，会被舍弃：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> res = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125; &amp; &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">2</span> &#125;;  <span class="hljs-comment">// res:never</span><br></code></pre></td></tr></table></figure><h2 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h2><p>对象、class 在 TypeScript 对应的类型是索引类型（Index Type），那么如何对索引类型作修改呢？</p><p>答案是映射类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">MapType</span>&lt;T&gt; = &#123;<br>    [<span class="hljs-title class_">Key</span> <span class="hljs-keyword">in</span> keyof T]?: T[<span class="hljs-title class_">Key</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p><code>keyof T</code>是查询索引类型中所有的索引，叫做<code>索引查询</code></p><p><code>T[Key]</code>是查询索引类型中索引对应的类型，叫做<code>索引访问</code></p><p><code>in</code>是用于便利联合类型的运算符。</p><p>比如我们把一个索引类型的值变成 3 个元素的数组：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">MapType</span>&lt;T&gt; = &#123;<br>    [<span class="hljs-title class_">Key</span> <span class="hljs-keyword">in</span> keyof T]: [T[<span class="hljs-title class_">Key</span>], T[<span class="hljs-title class_">Key</span>], T[<span class="hljs-title class_">Key</span>]]<br>&#125;<br><br><span class="hljs-keyword">type</span> res = <span class="hljs-title class_">MapType</span>&lt;&#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;&gt;;<br></code></pre></td></tr></table></figure><p>除了值可以变化，索引也可以做变化，用 as 运算符，叫做<code>重映射</code>。</p><p>比如我们把一个索引类型的值变成 3 个元素的数组：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">MapType</span>&lt;T&gt; = &#123;<br>    [<span class="hljs-title class_">Key</span> <span class="hljs-keyword">in</span> keyof T <span class="hljs-keyword">as</span> <span class="hljs-string">`new_<span class="hljs-subst">$&#123;Key&#125;</span>`</span>]: T[<span class="hljs-title class_">Key</span>]<br>&#125;<br><br><span class="hljs-keyword">type</span> res = <span class="hljs-title class_">MapType</span>&lt;&#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;&gt;;<br></code></pre></td></tr></table></figure><h1 id="套路一：模式匹配做提取"><a href="#套路一：模式匹配做提取" class="headerlink" title="套路一：模式匹配做提取"></a>套路一：模式匹配做提取</h1><h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p>比如这样一个 Promise 类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> p = <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-string">&#x27;guang&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>我们想提取value的类型，可以这样做：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> res = p <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Promise</span>&lt;infer T&gt; ? T : <span class="hljs-built_in">never</span>;<br></code></pre></td></tr></table></figure><p>通过 extends 对传入的类型参数 P 做模式匹配，其中值的类型是需要提取的，通过 infer 声明一个局部变量 Value 来保存，如果匹配，就返回匹配到的<br>Value，否则就返回 never 代表没匹配到。</p><p>这就是 Typescript 类型的模式匹配：</p><p>Typescript 类型的模式匹配是通过 extends 对类型参数做匹配，结果保存到通过 infer 声明的局部类型变量里，如果匹配就能从该局部变量里拿到提取出的类型。</p><h2 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h2><p>数组类型想提取第一个元素的类型怎么做呢？</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">GetArrFirst</span>&lt;<span class="hljs-title class_">Arr</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">unknown</span>[]&gt; = <span class="hljs-title class_">Arr</span> <span class="hljs-keyword">extends</span> [infer T, ...infer arr] ? T : <span class="hljs-built_in">never</span>;<br></code></pre></td></tr></table></figure><h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><p><code>构造器</code>和<code>函数</code>的区别是，<code>构造器</code>是用于创建对象的，所以可以被<code>new</code>。</p><h1 id="套路二：重新构造做变换"><a href="#套路二：重新构造做变换" class="headerlink" title="套路二：重新构造做变换"></a>套路二：重新构造做变换</h1><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Zip</span>&lt;<span class="hljs-title class_">One</span> <span class="hljs-keyword">extends</span> [<span class="hljs-built_in">unknown</span>, <span class="hljs-built_in">unknown</span>], <span class="hljs-title class_">Other</span> <span class="hljs-keyword">extends</span> [<span class="hljs-built_in">unknown</span>, <span class="hljs-built_in">unknown</span>]&gt; =<br>    <span class="hljs-title class_">One</span> <span class="hljs-keyword">extends</span> [infer <span class="hljs-title class_">OneFirst</span>, infer <span class="hljs-title class_">OneSecond</span>] ? (<span class="hljs-title class_">Other</span> <span class="hljs-keyword">extends</span> [infer <span class="hljs-title class_">OtherFirst</span>, infer <span class="hljs-title class_">OtherSecond</span>] ? [[<span class="hljs-title class_">OneFirst</span>, <span class="hljs-title class_">OtherFirst</span>], [<span class="hljs-title class_">OneSecond</span>, <span class="hljs-title class_">OtherSecond</span>]] : []) : [];<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">ZipResult</span> = <span class="hljs-title class_">Zip</span>&lt;[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-string">&#x27;huang&#x27;</span>, <span class="hljs-string">&#x27;jie&#x27;</span>]&gt;<br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 首字母大写</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">CapitalizeStr</span>&lt;<span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt; = <span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;infer first&#125;</span><span class="hljs-subst">$&#123;infer left&#125;</span>`</span> ? <span class="hljs-string">`<span class="hljs-subst">$&#123;Uppercase&lt;first&gt;&#125;</span><span class="hljs-subst">$&#123;left&#125;</span>`</span> : <span class="hljs-title class_">Str</span><br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">UseString</span> = <span class="hljs-title class_">CapitalizeStr</span>&lt;<span class="hljs-string">&#x27;huang&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 实现 dong_dong_dong 到 dongDongDong 的变换</span><br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">CamelCase</span>&lt;<span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt; = <span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;infer left&#125;</span>_<span class="hljs-subst">$&#123;infer right&#125;</span><span class="hljs-subst">$&#123;infer rest&#125;</span>`</span> ? <span class="hljs-string">`<span class="hljs-subst">$&#123;left&#125;</span><span class="hljs-subst">$&#123;Uppercase&lt;right&gt;&#125;</span><span class="hljs-subst">$&#123;CamelCase&lt;rest&gt;&#125;</span>`</span> : <span class="hljs-title class_">Str</span><br><br><span class="hljs-keyword">type</span> tryCamelCase = <span class="hljs-title class_">CamelCase</span>&lt;<span class="hljs-string">&#x27;dong_dong_dong&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 删除字符串中的某个子串</span><br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">DropSubStr</span>&lt;<span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>, <span class="hljs-title class_">SubStr</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt; = <span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;infer prefix&#125;</span><span class="hljs-subst">$&#123;SubStr&#125;</span><span class="hljs-subst">$&#123;infer suffix&#125;</span>`</span> ? <span class="hljs-title class_">DropSubStr</span>&lt;<span class="hljs-string">`<span class="hljs-subst">$&#123;prefix&#125;</span><span class="hljs-subst">$&#123;suffix&#125;</span>`</span>, <span class="hljs-title class_">SubStr</span>&gt; : <span class="hljs-title class_">Str</span><br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">TeyDropSubStr</span> = <span class="hljs-title class_">DropSubStr</span>&lt;<span class="hljs-string">&#x27;hello,world&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><br><span class="hljs-comment">// 函数类型的重新构造</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">AppendArgument</span>&lt;<span class="hljs-title class_">Func</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Function</span>, <span class="hljs-title class_">Arg</span>&gt; = <span class="hljs-title class_">Func</span> <span class="hljs-title function_">extends</span> (...<span class="hljs-attr">args</span>: infer <span class="hljs-title class_">Args</span>) =&gt; infer <span class="hljs-title class_">ReturnType</span> ? <span class="hljs-function">(<span class="hljs-params">...<span class="hljs-attr">args</span>: [...<span class="hljs-title class_">Args</span>, <span class="hljs-title class_">Arg</span>]</span>) =&gt;</span> <span class="hljs-title class_">ReturnType</span> : <span class="hljs-built_in">never</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Add</span>(<span class="hljs-params"><span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> &#123;<br>    <span class="hljs-keyword">return</span> a + b<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">TryAppendArgument</span> = <span class="hljs-title class_">AppendArgument</span>&lt;<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Add</span>, <span class="hljs-number">3</span>&gt;<br></code></pre></td></tr></table></figure><h2 id="索引类型的重新构造"><a href="#索引类型的重新构造" class="headerlink" title="索引类型的重新构造"></a>索引类型的重新构造</h2><p>索引类型是聚合多个元素的类型，class、对象等都是索引类型，比如这就是一个索引类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> obj = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>    <span class="hljs-attr">gender</span>: <span class="hljs-built_in">boolean</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>索引类型可以添加修饰符 readonly（只读）、?（可选）:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> obj = &#123;<br>    <span class="hljs-keyword">readonly</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-attr">age</span>?: <span class="hljs-built_in">number</span>;<br>    <span class="hljs-attr">gender</span>: <span class="hljs-built_in">boolean</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Mapping"><a href="#Mapping" class="headerlink" title="Mapping"></a>Mapping</h3><p>对它的修改和构造新类型涉及到了映射类型的语法：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Mapping</span>&lt;<span class="hljs-title class_">Obj</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">object</span>&gt; = &#123;<br>    [<span class="hljs-title class_">Key</span> <span class="hljs-keyword">in</span> keyof <span class="hljs-title class_">Obj</span>]: <span class="hljs-title class_">Obj</span>[<span class="hljs-title class_">Key</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p>用 <code>keyof</code> 取出 <code>Obj</code> 的索引，作为新的索引类型的索引，也就是 <code>Key in keyof Obj</code>。</p><h3 id="UppercaseKey"><a href="#UppercaseKey" class="headerlink" title="UppercaseKey"></a>UppercaseKey</h3><p>除了可以对 <code>Value</code> 做修改，也可以对 <code>Key</code> 做修改，使用 <code>as</code>，这叫做<strong>重映射</strong>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 把索引类型的key变成大写</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">UppercaseKey</span>&lt;<span class="hljs-title class_">Obj</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">object</span>&gt; = &#123;<br>    [<span class="hljs-title class_">Key</span> <span class="hljs-keyword">in</span> keyof <span class="hljs-title class_">Obj</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">Uppercase</span>&lt;<span class="hljs-title class_">Key</span> &amp; <span class="hljs-built_in">string</span>&gt;]: <span class="hljs-title class_">Obj</span>[<span class="hljs-title class_">Key</span>]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Record"><a href="#Record" class="headerlink" title="Record"></a>Record</h3><p>TypeScript 提供了内置的高级类型 <code>Record</code> 来创建索引类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Record</span>&lt;K <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | <span class="hljs-built_in">symbol</span>, T&gt; = &#123; [P <span class="hljs-keyword">in</span> K]: T; &#125;<br></code></pre></td></tr></table></figure><p>指定索引和值的类型分别为 <code>K</code> 和 <code>T</code>，就可以创建一个对应的索引类型。</p><p>上面的索引类型的约束我们用的 object，其实更语义化一点我推荐用 Record&lt;string, any&gt;:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">UppercaseKey</span>&lt;<span class="hljs-title class_">Obj</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>&gt;&gt; = &#123;<br>    [<span class="hljs-title class_">Key</span> <span class="hljs-keyword">in</span> keyof <span class="hljs-title class_">Obj</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">Uppercase</span>&lt;<span class="hljs-title class_">Key</span> &amp; <span class="hljs-built_in">string</span>&gt;]: <span class="hljs-title class_">Obj</span>[<span class="hljs-title class_">Key</span>]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="去掉readonly修饰"><a href="#去掉readonly修饰" class="headerlink" title="去掉readonly修饰"></a>去掉readonly修饰</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">RemoveReadonly</span>&lt;<span class="hljs-title class_">Obj</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>&gt;&gt; = &#123;<br>    -<span class="hljs-keyword">readonly</span> [<span class="hljs-title class_">Key</span> <span class="hljs-keyword">in</span> keyof <span class="hljs-title class_">Obj</span>]: <span class="hljs-title class_">Obj</span>[<span class="hljs-title class_">Key</span>]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="去掉可选修饰符"><a href="#去掉可选修饰符" class="headerlink" title="去掉可选修饰符"></a>去掉可选修饰符</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">RemoveOptional</span>&lt;<span class="hljs-title class_">Obj</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>&gt;&gt; = &#123;<br>    [<span class="hljs-title class_">Key</span> <span class="hljs-keyword">in</span> keyof <span class="hljs-title class_">Obj</span>]-?: <span class="hljs-title class_">Obj</span>[<span class="hljs-title class_">Key</span>]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="FilterByValueType"><a href="#FilterByValueType" class="headerlink" title="FilterByValueType"></a>FilterByValueType</h3><p>可以在构造新索引类型的时候根据值的类型做下过滤：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">FilterByValueType</span>&lt;<br>    <span class="hljs-title class_">Obj</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>&gt;,<br>    <span class="hljs-title class_">ValueType</span><br>&gt; = &#123;<br>    [<span class="hljs-title class_">Key</span> <span class="hljs-keyword">in</span> keyof <span class="hljs-title class_">Obj</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">Obj</span>[<span class="hljs-title class_">Key</span>] <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ValueType</span> ? <span class="hljs-title class_">Key</span> : <span class="hljs-built_in">never</span>]<br>    : <span class="hljs-title class_">Obj</span>[<span class="hljs-title class_">Key</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p>如果原来索引的值 <code>Obj[Key]</code> 是 <code>ValueType</code> 类型，索引依然为之前的索引 <code>Key</code>，否则索引设置为 <code>never</code>，<code>never</code><br>的索引会在生成新的索引类型时被去掉。</p><p>值保持不变，依然为原来索引的值，也就是 <code>Obj[Key]</code>。</p><p>这样就达到了过滤索引类型的索引，产生新的索引类型的目的。</p><hr><h1 id="递归复用做变换"><a href="#递归复用做变换" class="headerlink" title="递归复用做变换"></a>递归复用做变换</h1><p><code>递归</code>是把问题分解为一系列相似的小问题，通过函数不断调用自身来解决这一个个小问题，直到满足结束条件，就完成了问题的求解。</p><p>TypeScript<br>类型系统不支持循环，但支持递归。当处理数量（个数、长度、层数）不固定的类型的时候，可以只处理一个类型，然后递归的调用自身处理下一个类型，直到结束条件也就是所有的类型都处理完了，就完成了不确定数量的类型编程，达到循环的效果。</p><h2 id="Promise-的递归复用"><a href="#Promise-的递归复用" class="headerlink" title="Promise 的递归复用"></a>Promise 的递归复用</h2><h3 id="DeepPromiseValueType"><a href="#DeepPromiseValueType" class="headerlink" title="DeepPromiseValueType"></a>DeepPromiseValueType</h3><p>先用 Promise 热热身，实现一个提取不确定层数的 Promise 中的 value 类型的高级类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts">    <span class="hljs-keyword">type</span> ttt = <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>&gt;&gt;&gt;&gt;;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">DeepPromiseValueType</span>&lt;P <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">unknown</span>&gt;&gt; =<br>    P <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Promise</span>&lt;infer <span class="hljs-title class_">ValueType</span>&gt;<br>        ? <span class="hljs-title class_">ValueType</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">unknown</span>&gt;<br>            ? <span class="hljs-title class_">DeepPromiseValueType</span>&lt;<span class="hljs-title class_">ValueType</span>&gt; : <span class="hljs-title class_">ValueType</span><br>        : <span class="hljs-built_in">never</span>;<br></code></pre></td></tr></table></figure><p>其实这个类型的实现可以进一步的简化：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">DeepPromiseValueType</span>&lt;P&gt; =<br>P <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Promise</span>&lt;infer <span class="hljs-title class_">ValueType</span>&gt;<br>    ? <span class="hljs-title class_">DeepPromiseValueType</span>&lt;<span class="hljs-title class_">ValueType</span>&gt; : P;<br></code></pre></td></tr></table></figure><h2 id="数组类型的递归"><a href="#数组类型的递归" class="headerlink" title="数组类型的递归"></a>数组类型的递归</h2><h3 id="ReverseArr"><a href="#ReverseArr" class="headerlink" title="ReverseArr"></a>ReverseArr</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 将 type arr = [1,2,3,4,5] 变成 type arr = [5,4,3,2,1]</span><br><span class="hljs-comment">// 假如数组长度不确定，怎么做呢？ 用递归！</span><br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">ReverseArr</span>&lt;<span class="hljs-title class_">Arr</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">unknown</span>&gt;&gt; = <span class="hljs-title class_">Arr</span> <span class="hljs-keyword">extends</span> [infer <span class="hljs-title class_">First</span>, ...infer <span class="hljs-title class_">Rest</span>] ? [...<span class="hljs-title class_">ReverseArr</span>&lt;<span class="hljs-title class_">Rest</span>&gt;, <span class="hljs-title class_">First</span>] : <span class="hljs-title class_">Arr</span>;<br></code></pre></td></tr></table></figure><h3 id="Includes"><a href="#Includes" class="headerlink" title="Includes"></a>Includes</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 查找 [1, 2, 3, 4, 5] 中是否存在 4，是就返回 true，否则返回 false。</span><br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Includes</span>&lt;<span class="hljs-title class_">Arr</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">unknown</span>&gt;, <span class="hljs-title class_">FindItem</span>&gt; = <span class="hljs-title class_">Arr</span> <span class="hljs-keyword">extends</span> [infer <span class="hljs-title class_">First</span>, ...infer <span class="hljs-title class_">Rest</span>] ? (<span class="hljs-title class_">First</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FindItem</span> ? <span class="hljs-literal">true</span> : <span class="hljs-title class_">Includes</span>&lt;<span class="hljs-title class_">Rest</span>, <span class="hljs-title class_">FindItem</span>&gt;) : <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><h3 id="RemoveItem"><a href="#RemoveItem" class="headerlink" title="RemoveItem"></a>RemoveItem</h3><p>可以查找自然就可以删除，只需要改下返回结果，构造一个新的数组返回。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">RemoveItem</span>&lt;<span class="hljs-title class_">Arr</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">unknown</span>[], <span class="hljs-title class_">Item</span>, <span class="hljs-title class_">Result</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">unknown</span>[] = []&gt;<br>    = <span class="hljs-title class_">Arr</span> <span class="hljs-keyword">extends</span> [infer <span class="hljs-title class_">First</span>, ...infer <span class="hljs-title class_">Rest</span>]<br>    ? (<span class="hljs-title class_">First</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Item</span><br>        ? <span class="hljs-title class_">RemoveItem</span>&lt;<span class="hljs-title class_">Rest</span>, <span class="hljs-title class_">Item</span>, <span class="hljs-title class_">Result</span>&gt;<br>        : <span class="hljs-title class_">RemoveItem</span>&lt;<span class="hljs-title class_">Rest</span>, <span class="hljs-title class_">Item</span>, [...<span class="hljs-title class_">Result</span>, <span class="hljs-title class_">First</span>]&gt;)<br>    : <span class="hljs-title class_">Result</span>; <br></code></pre></td></tr></table></figure><h3 id="BuildArray"><a href="#BuildArray" class="headerlink" title="BuildArray"></a>BuildArray</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 传入 5 和元素类型，构造一个长度为 5 的该元素类型构成的数组。</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">BuildArray</span>&lt;<span class="hljs-title class_">Length</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">number</span>, <span class="hljs-title class_">Ele</span> = <span class="hljs-built_in">unknown</span>, <span class="hljs-title class_">Arr</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">unknown</span>[] = []&gt; = <span class="hljs-title class_">Arr</span>[<span class="hljs-string">&#x27;length&#x27;</span>] <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Length</span> ? <span class="hljs-title class_">Arr</span> : <span class="hljs-title class_">BuildArray</span>&lt;<span class="hljs-title class_">Length</span>, <span class="hljs-title class_">Ele</span>, [<span class="hljs-title class_">Ele</span>, ...<span class="hljs-title class_">Arr</span>]&gt;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">BuildArrResult</span> = <span class="hljs-title class_">BuildArray</span>&lt;<span class="hljs-number">5</span>, <span class="hljs-built_in">string</span>&gt;<br></code></pre></td></tr></table></figure><h2 id="字符串类型的递归"><a href="#字符串类型的递归" class="headerlink" title="字符串类型的递归"></a>字符串类型的递归</h2><p><strong>在类型体操里，遇到数量不确定的问题，就要条件反射的想到递归。</strong></p><h3 id="ReplaceAll"><a href="#ReplaceAll" class="headerlink" title="ReplaceAll"></a>ReplaceAll</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ReplaceAll</span>&lt;<br>    <span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>,<br>    <span class="hljs-title class_">From</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>,<br>    <span class="hljs-title class_">To</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span><br>&gt; = <span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;infer Left&#125;</span><span class="hljs-subst">$&#123;From&#125;</span><span class="hljs-subst">$&#123;infer Right&#125;</span>`</span><br>    ? <span class="hljs-string">`<span class="hljs-subst">$&#123;Left&#125;</span><span class="hljs-subst">$&#123;To&#125;</span><span class="hljs-subst">$&#123;ReplaceAll&lt;Right, From, To&gt;&#125;</span>`</span><br>    : <span class="hljs-title class_">Str</span>;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">ReplaceAllResult</span> = <span class="hljs-title class_">ReplaceAll</span>&lt;<span class="hljs-string">&#x27;hello,world&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="StringToUnion"><a href="#StringToUnion" class="headerlink" title="StringToUnion"></a>StringToUnion</h3><p>把字符串字面量类型的每个字符都提取出来组成联合类型，也就是把 ‘dong’ 转为 ‘d’ | ‘o’ | ‘n’ | ‘g’。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><br><span class="hljs-comment">// 首字母放到first字段，其余字符放到Rest字段</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">StringToUnion</span>&lt;<span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt; = <span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;infer first&#125;</span><span class="hljs-subst">$&#123;infer Rest&#125;</span>`</span> ? first | <span class="hljs-title class_">StringToUnion</span>&lt;<span class="hljs-title class_">Rest</span>&gt; : <span class="hljs-built_in">never</span><br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">StringToUnionResult</span> = <span class="hljs-title class_">StringToUnion</span>&lt;<span class="hljs-string">&#x27;dong&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="ReverseStr"><a href="#ReverseStr" class="headerlink" title="ReverseStr"></a>ReverseStr</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ReverseStr</span>&lt;<span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>, <span class="hljs-title class_">Result</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;&#x27;</span>&gt; = <span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;infer First&#125;</span><span class="hljs-subst">$&#123;infer Rest&#125;</span>`</span> ? <span class="hljs-title class_">ReverseStr</span>&lt;<span class="hljs-title class_">Rest</span>, <span class="hljs-string">`<span class="hljs-subst">$&#123;First&#125;</span><span class="hljs-subst">$&#123;Result&#125;</span>`</span>&gt; : <span class="hljs-title class_">Result</span><br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">ReverseStrResult</span> = <span class="hljs-title class_">ReverseStr</span>&lt;<span class="hljs-string">&#x27;dong&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><h2 id="对象类型的递归"><a href="#对象类型的递归" class="headerlink" title="对象类型的递归"></a>对象类型的递归</h2><h3 id="DeepReadonly"><a href="#DeepReadonly" class="headerlink" title="DeepReadonly"></a>DeepReadonly</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs ts"><br><span class="hljs-comment">// 如果对象的层数不确定，就需要递归来解决</span><br><br><span class="hljs-comment">// type DeepReadonly&lt;Obj extends Record&lt;string, any&gt;&gt; = &#123;</span><br><span class="hljs-comment">//     readonly [Key in keyof Obj]:</span><br><span class="hljs-comment">//     Obj[Key] extends object</span><br><span class="hljs-comment">//         ? Obj[Key] extends Function</span><br><span class="hljs-comment">//             ? Obj[Key]</span><br><span class="hljs-comment">//             : DeepReadonly&lt;Obj[Key]&gt;</span><br><span class="hljs-comment">//         : Obj[Key]</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">DeepReadonly</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>&gt; = &#123;&#125;&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">any</span> ? &#123;<br>    <span class="hljs-keyword">readonly</span> [k <span class="hljs-keyword">in</span> keyof T]: T[k] <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>&gt; ? <span class="hljs-title class_">DeepReadonly</span>&lt;T[k]&gt; : T[k]<br>&#125; : <span class="hljs-built_in">never</span>;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">TestDeepReadonly</span> = <span class="hljs-title class_">DeepReadonly</span>&lt;&#123;<br>    <span class="hljs-attr">a</span>: &#123;<br>        <span class="hljs-attr">b</span>: &#123;<br>            <span class="hljs-attr">c</span>: &#123;<br>                <span class="hljs-attr">f</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-string">&#x27;dong&#x27;</span>,<br>                <span class="hljs-attr">d</span>: &#123;<br>                    <span class="hljs-attr">e</span>: &#123;<br>                        <span class="hljs-attr">guang</span>: <span class="hljs-built_in">string</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">k</span>: <span class="hljs-number">1</span><br>&#125;&gt;<br><br></code></pre></td></tr></table></figure><h1 id="元组长度做计算"><a href="#元组长度做计算" class="headerlink" title="元组长度做计算"></a>元组长度做计算</h1><p>**TypeScript 类型系统中没有加减乘除运算符，但是可以通过构造不同的元组然后取 length 的方式来完成数值计算，把数值的加减乘除转化为对元组的提取和构造。<br>**</p><h2 id="元组长度实现加减乘除"><a href="#元组长度实现加减乘除" class="headerlink" title="元组长度实现加减乘除"></a>元组长度实现加减乘除</h2><h3 id="Add加法"><a href="#Add加法" class="headerlink" title="Add加法"></a>Add加法</h3><p>构造两个数组，然后合并成一个，取 length。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">BuildArray</span>&lt;<br>    <span class="hljs-title class_">Length</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">number</span>,<br>    <span class="hljs-title class_">Ele</span> = <span class="hljs-built_in">unknown</span>,<br>    <span class="hljs-title class_">Arr</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">unknown</span>[] = []<br>&gt; = <span class="hljs-title class_">Arr</span>[<span class="hljs-string">&#x27;length&#x27;</span>] <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Length</span><br>    ? <span class="hljs-title class_">Arr</span><br>    : <span class="hljs-title class_">BuildArray</span>&lt;<span class="hljs-title class_">Length</span>, <span class="hljs-title class_">Ele</span>, [...<span class="hljs-title class_">Arr</span>, <span class="hljs-title class_">Ele</span>]&gt;;<br></code></pre></td></tr></table></figure><p>类型参数 Length 是要构造的数组的长度。类型参数 Ele 是数组元素，默认为 unknown。类型参数 Arr 为构造出的数组，默认是 []。</p><p>基于它就能实现加法：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Add</span>&lt;<span class="hljs-title class_">Num1</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">number</span>, <span class="hljs-title class_">Num2</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">number</span>&gt; =<br>    [...<span class="hljs-title class_">BuildArray</span>&lt;<span class="hljs-title class_">Num1</span>&gt;, ...<span class="hljs-title class_">BuildArray</span>&lt;<span class="hljs-title class_">Num2</span>&gt;][<span class="hljs-string">&#x27;length&#x27;</span>];<br></code></pre></td></tr></table></figure><h3 id="Subtract减法"><a href="#Subtract减法" class="headerlink" title="Subtract减法"></a>Subtract减法</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Subtract</span>&lt;<span class="hljs-title class_">Num1</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">number</span>, <span class="hljs-title class_">Num2</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">number</span>&gt; =<br>    <span class="hljs-title class_">BuildArray</span>&lt;<span class="hljs-title class_">Num1</span>&gt; <span class="hljs-keyword">extends</span> [...<span class="hljs-attr">arr1</span>: <span class="hljs-title class_">BuildArray</span>&lt;<span class="hljs-title class_">Num2</span>&gt;, ...<span class="hljs-attr">arr2</span>: infer <span class="hljs-title class_">Rest</span>]<br>        ? <span class="hljs-title class_">Rest</span>[<span class="hljs-string">&#x27;length&#x27;</span>]<br>        : <span class="hljs-built_in">never</span>;<br></code></pre></td></tr></table></figure><p>类型参数 Num1、Num2 分别是被减数和减数，通过 extends 约束为 number。</p><p>构造 Num1 长度的数组，通过模式匹配提取出 Num2 长度个元素，剩下的放到 infer 声明的局部变量 Rest 里。</p><p>取 Rest 的长度返回，就是减法的结果。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">SubstractResult</span> = <span class="hljs-title class_">Subtract</span>&lt;<span class="hljs-number">5</span>, <span class="hljs-number">3</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="Multiply乘法"><a href="#Multiply乘法" class="headerlink" title="Multiply乘法"></a>Multiply乘法</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Multiply</span>&lt;<span class="hljs-title class_">Num1</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">number</span>, <span class="hljs-title class_">Num2</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">number</span>&gt; =<br>    <span class="hljs-title class_">BuildArray</span>&lt;<span class="hljs-title class_">Num2</span>&gt; <span class="hljs-keyword">extends</span> [...<span class="hljs-attr">arr</span>: <span class="hljs-title class_">BuildArray</span>&lt;<span class="hljs-title class_">Num1</span>&gt;]<br>        ? arr[<span class="hljs-string">&#x27;length&#x27;</span>]<br>        : <span class="hljs-built_in">never</span>;<br></code></pre></td></tr></table></figure><h1 id="TS内置的高级类型有哪些？"><a href="#TS内置的高级类型有哪些？" class="headerlink" title="TS内置的高级类型有哪些？"></a>TS内置的高级类型有哪些？</h1><h2 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h2><p><code>Parameters</code>用于提取函数类型的参数类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Parameters</span>&lt;T <span class="hljs-title function_">extends</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>) =&gt; <span class="hljs-built_in">any</span>&gt;<br>    = T <span class="hljs-title function_">extends</span> (...<span class="hljs-attr">args</span>: infer P) =&gt; <span class="hljs-built_in">any</span><br>    ? P<br>    : <span class="hljs-built_in">never</span>;<br></code></pre></td></tr></table></figure><p>类型参数 T 为待处理的类型，通过 extends 约束为函数，参数和返回值任意。</p><p>通过 extends 匹配一个模式类型，提取参数的类型到 infer 声明的局部变量 P 中返回。</p><h2 id="ReturnType"><a href="#ReturnType" class="headerlink" title="ReturnType"></a>ReturnType</h2><p><code>ReturnType</code> 用于提取函数类型的返回值类型。</p><p>源码是这样的：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ReturnType</span>&lt;T <span class="hljs-title function_">extends</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>) =&gt; <span class="hljs-built_in">any</span>&gt; =<br>    T <span class="hljs-title function_">extends</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>) =&gt; infer P ? P : <span class="hljs-built_in">any</span> <br></code></pre></td></tr></table></figure><p>类型参数 T 为待处理的类型，通过 extends 约束为函数类型，参数和返回值任意。</p><p>用 T 匹配一个模式类型，提取返回值的类型到 infer 声明的局部变量 P 里返回。</p><h2 id="ConstructorParameters"><a href="#ConstructorParameters" class="headerlink" title="ConstructorParameters"></a>ConstructorParameters</h2><p>构造器类型和函数类型的区别就是可以被<code>new</code></p><p><code>Parameters</code> 用于提取函数参数的类型，而 <code>ConstructorParameters</code> 用于提取构造器参数的类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ConstructorParameters</span>&lt;<br>    T <span class="hljs-keyword">extends</span> <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">new</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>) =&gt; <span class="hljs-built_in">any</span><br>&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">new</span> (...<span class="hljs-attr">args</span>: infer P) =&gt; <span class="hljs-built_in">any</span><br>    ? P<br>    : <span class="hljs-built_in">never</span>;<br></code></pre></td></tr></table></figure><p>类型参数 T 是待处理的类型，通过 extends 约束为构造器类型，加个 abstract 代表不能直接被实例化（其实不加也行）。</p><p>用 T 匹配一个模式类型，提取参数的部分到 infer 声明的局部变量 P 里，返回 P。</p><h2 id="InstanceType"><a href="#InstanceType" class="headerlink" title="InstanceType"></a>InstanceType</h2><p>提取构造器返回值的类型，就是 <code>InstanceType</code>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">InstanceType</span>&lt;<br>    T <span class="hljs-keyword">extends</span> <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">new</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>) =&gt; <span class="hljs-built_in">any</span><br>&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">new</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>) =&gt; infer R<br>    ? R<br>    : <span class="hljs-built_in">any</span>;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术类-TypeScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang笔记</title>
    <link href="/20230728/Golang%E7%AC%94%E8%AE%B0/"/>
    <url>/20230728/Golang%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>1.</p><p><strong>数组</strong>是值类型，赋值和传参会复制整个数组，而不是指针。<br><strong>切片</strong>是引用类型，赋值和传参都会复制指针，而不是数据。</p><p>2.</p><p>函数的参数有两种传递方式，按值传递和按引用传递。按值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到原来的实际参数。按引用传递是指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到原来的实际参数。</p><p>引用类型（slice、map、interface、channel）都默认使用引用传递</p><p>3.</p><p>切片传入方法中，如果方法内部没有对切片进行扩容，那么切片的修改会影响到原切片，如果方法内部对切片进行了扩容，那么切片的修改不会影响到原切片。</p><h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><ol><li>延迟执行，在当前栈退出时执行</li><li>一般用于资源清理工作</li><li>解锁、关闭文件</li><li>多次调用defer，执行时类似于栈的机制：先进后出</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pinia笔记</title>
    <link href="/20230619/Pinia%E7%AC%94%E8%AE%B0/"/>
    <url>/20230619/Pinia%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="Pinia的-3-大核心"><a href="#Pinia的-3-大核心" class="headerlink" title="Pinia的 3 大核心"></a>Pinia的 3 大核心</h2><ol><li>状态(state)</li><li>派生出新状态(getters)</li><li>操作(actions)</li></ol><h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;defineStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span><br><br><span class="hljs-keyword">const</span> useUserStore = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">&#x27;user&#x27;</span>,&#123;<br>    <span class="hljs-comment">// 状态</span><br>    <span class="hljs-attr">state</span>:<span class="hljs-function">()=&gt;</span>(&#123;<br>        <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;张三&#x27;</span>,<br>        <span class="hljs-attr">age</span>:<span class="hljs-number">18</span><br>    &#125;),<br>    <span class="hljs-comment">// 派生</span><br>    <span class="hljs-attr">getters</span>:&#123;<br>        <span class="hljs-title function_">getAge</span>(<span class="hljs-params">state</span>)&#123;<br>            <span class="hljs-keyword">return</span> state.<span class="hljs-property">age</span><br>        &#125;<br>    &#125;,<br>    <span class="hljs-comment">// 操作</span><br>    <span class="hljs-attr">actions</span>:&#123;<br>        <span class="hljs-title function_">changeAge</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>++<br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;useUserStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/stores/user&#x27;</span><br><span class="hljs-keyword">const</span> userStore = <span class="hljs-title function_">useUserStore</span>()<br>userStore.<span class="hljs-property">age</span> <span class="hljs-comment">// 18</span><br>userStore.<span class="hljs-title function_">changeAge</span>()<br></code></pre></td></tr></table></figure><h2 id="进阶使用-推荐✅"><a href="#进阶使用-推荐✅" class="headerlink" title="进阶使用(推荐✅)"></a>进阶使用(推荐✅)</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;defineStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span><br><span class="hljs-keyword">import</span> &#123;reactive,computed&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useUserStore = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">&#x27;user&#x27;</span>,<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-comment">// 状态</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title class_">Person</span> = <span class="hljs-title function_">reactive</span>(&#123;<br>        <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;张三&#x27;</span>,<br>        <span class="hljs-attr">age</span>:<span class="hljs-number">18</span><br>    &#125;)<br>    <span class="hljs-comment">// 派生</span><br>    <span class="hljs-keyword">const</span> getAge = <span class="hljs-title function_">computed</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Person</span>.<span class="hljs-property">age</span><br>    &#125;)<br>    <span class="hljs-comment">// 操作</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">changeAge</span> = (<span class="hljs-params"></span>)=&gt;&#123;<br>        <span class="hljs-title class_">Person</span>.<span class="hljs-property">age</span>++<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-title class_">Person</span>,<br>        getAge,<br>        changeAge<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;useUserStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/stores/user&#x27;</span><br><span class="hljs-keyword">const</span> userStore = <span class="hljs-title function_">useUserStore</span>()<br>userStore.<span class="hljs-property">Person</span>.<span class="hljs-property">age</span> <span class="hljs-comment">// 18</span><br>userStore.<span class="hljs-title function_">changeAge</span>()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术类-Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>Pinia</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端工程化</title>
    <link href="/20230420/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    <url>/20230420/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d62b9a148e14be298cad627cac1de6b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="前端工程化"></p><h2 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h2><p><code>前端工程化</code>指使用软件工程的技术与方法对前端开发的技术、工具、流程、经验、方案等指标标准化，<br>它具备<strong>模块化、组件化、规范化、自动化</strong>四大特性，<br>主要目的是<strong>降低成本</strong>与<strong>增加效率</strong>。</p><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p><code>模块化</code>是前端工程化的重中之重。它在前端工程化中具体表现为：在文件层面上对代码与资源实现拆分与组装，将一个大文件拆分为互相依赖的小文件，再统一拼装与加载。</p><h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><p><code>组件化</code>是前端工程化的重要基础。它实现了代码更高层次的复用性，提升开发效率。组件的封装也是对象的封装，同样要做到**高内聚低耦合<br>**，组件化的项目不仅利于单元测试的进行，同样也利于需求迭代的推进。</p><p>优秀的组件化遵循以下设计哲学。</p><ul><li>将设计图划分为最小组件层级</li><li>使用预设规范创建组件静态版本</li><li>确定组件内部最小且完整的状态的表示方式</li><li>确定组件内部最小且完整的状态的存放方式</li><li>实现数据流的正向传递与反向传递</li></ul><h3 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h3><p><code>规范化</code>指将一系列预设规范接入工程各个阶段，通过各项指标标准化开发者的工作流程，引导开发者在团队协作中往更好的方向发展。</p><p><code>规范化</code><br>是前端工程化的重要部分。它有效地将一盘松散的规范通过指定标准凝聚在一起，将所有工作流程标准化，协同所有开发者以标准化的方式定义工作流程，同时也影响着代码、文档和日志，甚至影响着每个开发者及其团队发展方向，因此每个成熟的前端团队都有一套身经百战的规范化方案。</p><p><code>规范化</code>更多应用在团队协作中，为每个开发者指明一个方向，引领着成员往该方向走。若团队无规范化，每个开发者各做各的事情，在合并代码时肯定会发生争吵，甚至影响工作效率。</p><h3 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h3><p><code>自动化</code>指将一系列繁琐重复的工作流程交由程序根据预设脚本自动处理，整个工作流程无需人工参与，以解放开发者双手让其更专注业务需求的开发。</p><p><code>自动化</code><br>是前端工程化的智能部分。它既可解放双手又能节省大量时间做更多有意义的事情，常见自动化场景包括但不限于<code>自动化构建</code>、<code>自动化测试</code>、<code>自动化打包</code>、<code>自动化发布</code><br>和<code>自动化部署</code>，更高级的自动化场景包括但不限于<code>持续集成</code>、<code>持续交付</code>和<code>持续部署</code><br>。以自动化构建为例，又可将其划分为以下子任务，这些子任务分布在自动化构建不同阶段，在不同阶段的最佳时刻会调用相关工具处理相关流程。</p><table><thead><tr><th>任务</th><th>职责</th></tr></thead><tbody><tr><td>Stylelint</td><td>校验样式代码</td></tr><tr><td>Eslint</td><td>校验脚本代码</td></tr><tr><td>Postcss</td><td>Postcss → CSS</td></tr><tr><td>Sass</td><td>SASS → CSS</td></tr><tr><td>Less</td><td>LESS → CSS</td></tr><tr><td>Babel</td><td>ES6 → ES5</td></tr><tr><td>TypeScript</td><td>TS → JS</td></tr></tbody></table><hr><h3 id="工程化的表现"><a href="#工程化的表现" class="headerlink" title="工程化的表现"></a>工程化的表现</h3><p>一切以提高效率、降低成本、质量保证为目的的手段都属于<strong>工程化</strong></p>]]></content>
    
    
    <categories>
      
      <category>技术类-前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端工程化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx知识整理&amp;记录</title>
    <link href="/20230303/Nginx%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E8%AE%B0%E5%BD%95/"/>
    <url>/20230303/Nginx%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd0a614838ac4aafb10f0275a32ab130~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp"></p><h2 id="Nginx是什么？"><a href="#Nginx是什么？" class="headerlink" title="Nginx是什么？"></a>Nginx是什么？</h2><p><code>Nginx (engine x)</code> 是一个<strong>轻量级</strong>、<strong>高性能</strong>的<strong>HTTP和反向代理服务器</strong>,同时也是一个通用代理服务器(<br>TCP/UDP/IMAP/POP3/SMTP)。</p><ul><li>Nginx是一个拥有高性能HTTP和反向代理服务器，其特点是占用内存少，并发能力强，并且在现实中，nginx的并发能力要比在同类型的网页服务器中表现要好</li><li>Nginx专为性能优化而开发，最重要的要求便是性能，且十分注重效率，有报告nginx能支持高达50000个并发连接数</li></ul><h2 id="正向代理与反向代理"><a href="#正向代理与反向代理" class="headerlink" title="正向代理与反向代理"></a>正向代理与反向代理</h2><ul><li>正向代理，代理客户端,客户端不想让服务器知道客户端的ip，所以让代理服务器去访问，再返回给客户端。</li><li>反向代理，代理服务器,服务器不想客户端知道是哪个服务器响应的，所以让代理服务器去分配，让空闲的服务器去响应。</li></ul><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>负载均衡：是高可用网络基础架构的关键组件，通常用于将工作负载分布到多个服务器来提高网站、应用、数据库或其他服务的性能和可靠性。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6c634ec69f54d5ab76644d8dd78b0c2~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="负载均衡"></p><h2 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h2><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a91e7a373df14e90891e6f4f62a629d7~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="动静分离"></p><h2 id="服务器端配置和使用Nginx"><a href="#服务器端配置和使用Nginx" class="headerlink" title="服务器端配置和使用Nginx"></a>服务器端配置和使用Nginx</h2><p><a href="https://juejin.cn/post/7052952117425733663">此文写的比较详细，点击链接跳转</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>页面响应式布局的要点</title>
    <link href="/20220720/%E9%A1%B5%E9%9D%A2%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%E7%9A%84%E8%A6%81%E7%82%B9/"/>
    <url>/20220720/%E9%A1%B5%E9%9D%A2%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%E7%9A%84%E8%A6%81%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/6844903814332432397#heading-3">参考文章</a></p><h2 id="响应式设计与自适应设计的区别"><a href="#响应式设计与自适应设计的区别" class="headerlink" title="响应式设计与自适应设计的区别"></a>响应式设计与自适应设计的区别</h2><p>响应式开发一套界面，通过检测视口分辨率，针对不同客户端在客户端做代码处理，来展现不同的布局和内容；自适应需要开发多套界面，通过检测视口分辨率，来判断当前访问的设备是 pc 端、平板、手机，从而请求服务层，返回不同的页面。</p><h2 id="响应式布局实现方案"><a href="#响应式布局实现方案" class="headerlink" title="响应式布局实现方案"></a>响应式布局实现方案</h2><h3 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h3><p>不管是移动优先还是 PC 优先，都是依据当随着屏幕宽度增大或减小的时候，后面的样式会覆盖前面的样式。因此，移动端优先首先使用的是 min-width，PC 端优先使用的 max-width。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* iphone6 7 8 */</span><br><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: yellow;<br>&#125;<br><span class="hljs-comment">/* iphone 5 */</span><br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">320px</span>) &#123;<br>  <span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: red;<br>  &#125;<br>&#125;<br><span class="hljs-comment">/* iphoneX */</span><br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">375px</span>) <span class="hljs-keyword">and</span> (<span class="hljs-attribute">-webkit-device-pixel-ratio</span>: <span class="hljs-number">3</span>) &#123;<br>  <span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#0ff000</span>;<br>  &#125;<br>&#125;<br><span class="hljs-comment">/* iphone6 7 8 plus */</span><br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">414px</span>) &#123;<br>  <span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: blue;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="百分比布局"><a href="#百分比布局" class="headerlink" title="百分比布局"></a>百分比布局</h3><p>我们必须要弄清楚 css 中子元素的百分比到底是相对谁的百分比。直接上结论吧：</p><ul><li>子元素的 height 或 width 中使用百分比，是相对于子元素的直接父元素。width 相对于直接父元素的 width，height 相对于直接父元素的 height。</li><li>子元素的 top 和 bottom 如果设置百分比，则相对于直接非 static 定位(默认定位)的父元素的高度。</li><li>同样子元素的 left 和 right 如果设置百分比，则相对于直接非 static 定位(默认定位的)父元素的宽度。</li><li>子元素的 padding 如果设置百分比，不论是垂直方向或者是水平方向，都相对于直接父亲元素的 width，而与父元素的 height 无关。</li><li>子元素的 margin 如果设置成百分比，不论是垂直方向还是水平方向，都相对于直接父元素的 width</li><li>border-radius 不一样，如果设置 border-radius 为百分比，则是相对于自身的宽度，除了 border-radius 外，还有比如 translate、background-size 等都是相对于自身的。</li></ul><h3 id="rem-布局"><a href="#rem-布局" class="headerlink" title="rem 布局"></a>rem 布局</h3><p><code>rem</code>是<code>css3</code>中新增的单位，并且移动端支持度很高。</p><p><code>rem</code>单位都是相对于根元素 html 的<code>font-size</code>来决定大小的,根元素的<code>font-size</code>相当于提供了一个基准，当页面的 size 发生变化时，只需要改变<code>font-size</code>的值，那么以<code>rem</code>为固定单位的元素的大小也会发生响应的变化。 因此，如果通过<code>rem</code>来实现响应式的布局，只需要根据视图容器的大小，动态的改变<code>font-size</code>即可（而 em 是相对于父元素的）。</p><p>rem 响应式的布局思想：</p><ul><li>一般不要给元素设置具体的宽度，但是对于一些小图标可以设定具体宽度值</li><li>高度值可以设置固定值，设计稿有多大，我们就严格有多大</li><li>所有设置的固定值都用 rem 做单位（首先在 HTML 总设置一个基准值：px 和 rem 的对应比例，然后在效果图上获取 px 值，布局的时候转化为 rem 值)</li><li>js 获取真实屏幕的宽度，让其除以设计稿的宽度，算出比例，把之前的基准值按照比例进行重新的设定，这样项目就可以在移动端自适应了</li></ul><p><code>rem</code>布局也是目前多屏幕适配的最佳方式。</p><h3 id="vw-vh-视口单位"><a href="#vw-vh-视口单位" class="headerlink" title="vw/vh 视口单位"></a>vw/vh 视口单位</h3><p><code>vw</code>表示相对于视图窗口的宽度，<code>vh</code>表示相对于视图窗口高度，除了<code>vw</code>和<code>vh</code>外，还有<code>vmin</code>和<code>vmax</code>两个相关的单位。</p><table><thead><tr><th>单位</th><th>含义</th></tr></thead><tbody><tr><td>vw</td><td>相对于视窗的宽度，1vw 等于视口宽度的 1%，即视窗宽度是 100vw</td></tr><tr><td>vh</td><td>相对于视窗的高度，1vh 等于视口高度的 1%，即视窗高度是 100vh</td></tr><tr><td>vmin</td><td>vw 和 vh 中的较小值</td></tr><tr><td>vmax</td><td>vw 和 vh 中的较大值</td></tr></tbody></table><p>vw 和%的区别为：<br>| 单位 | 含义 |<br>| —– | —————————————————————————- |<br>| % | 大部分相对于祖先元素，也有相对于自身的情况比如（border-radius、translate 等) |<br>| vw/vh | 相对于视窗的尺寸 |</p><ul><li>1 物理像素线（也就是普通屏幕下 1px,高清屏幕下 0.5px 的情况）采用 transform 属性 scale 实现</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> <span class="hljs-keyword">only</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">-webkit-min-device-pixel-ratio</span>: <span class="hljs-number">2</span>) &#123;<br>  -webkit-<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scaleY</span>(<span class="hljs-number">0.5</span>);<br>  -webkit-<span class="hljs-attribute">transform-origin</span>: <span class="hljs-number">50%</span> <span class="hljs-number">0%</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="图片响应式"><a href="#图片响应式" class="headerlink" title="图片响应式"></a>图片响应式</h3><ul><li>1.使用 max-width（图片自适应）</li></ul><p>图片自适应意思就是图片能随着容器的大小进行缩放</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">img</span> &#123;<br>  <span class="hljs-attribute">display</span>: inline-block;<br>  <span class="hljs-attribute">max-width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: auto;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>2.使用<code>srcset</code></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;<span class="hljs-selector-tag">img</span> srcset=&quot;photo_w350<span class="hljs-selector-class">.jpg</span> <span class="hljs-number">1</span>x, photo_w640<span class="hljs-selector-class">.jpg</span> <span class="hljs-number">2</span>x&quot; <span class="hljs-attribute">src</span>=&quot;photo_w350<span class="hljs-selector-class">.jpg</span>&quot; alt=&quot;&quot;&gt;<br></code></pre></td></tr></table></figure><p>如果屏幕的 dpi = 1 的话则加载 1 倍图，而 dpi = 2 则加载 2 倍图，手机和 mac 基本上 dpi 都达到了 2 以上，这样子对于普通屏幕来说不会浪费流量，而对于视网膜屏来说又有高清的体验。</p><h2 id="响应式布局的成型方案"><a href="#响应式布局的成型方案" class="headerlink" title="响应式布局的成型方案"></a>响应式布局的成型方案</h2><p>现在的 css，UI 框架等都已经考虑到了适配不同屏幕分辨率的问题，实际项目中我们可以直接使用这些新特性和框架来实现响应式布局。可以有以下选择方案：</p><ul><li>利用上面的方法自己来实现，比如 CSS3 Media Query,rem，vw 等</li><li>Flex 弹性布局，兼容性较差</li><li>Grid 网格布局，兼容性较差</li><li>Columns 栅格系统，往往需要依赖某个 UI 库，如 Bootstrap</li></ul><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><p>在实际项目中，我们可能需要综合使用响应式布局方案，比如用 rem 来做字体的适配，用 srcset 来做图片的响应式，宽度可以用 rem，flex，栅格系统等来实现响应式，然后可能还需要利用媒体查询来作为响应式布局的基础，因此综合上面的实现方案，项目中实现响应式布局需要注意下面几点：</p><ul><li>设置 viewport</li><li>媒体查询</li><li>字体的适配（字体单位）</li><li>百分比布局</li><li>图片的适配（图片的响应式）</li><li>结合 flex，grid，BFC，栅格系统等已经成型的方案</li></ul>]]></content>
    
    
    <categories>
      
      <category>技术类-前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>响应式布局</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年中总结</title>
    <link href="/20220715/2022%E5%B9%B4%E4%B8%AD%E6%80%BB%E7%BB%93/"/>
    <url>/20220715/2022%E5%B9%B4%E4%B8%AD%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>今年上半年一直在独立负责“UTen 项目”的前端开发工作。该项目基于 vue2 全家桶，提供海外客户在线选品的功能，收入在于功能付费。</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Promise输出顺序相关问题</title>
    <link href="/20220329/Promise%E8%BE%93%E5%87%BA%E9%A1%BA%E5%BA%8F%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <url>/20220329/Promise%E8%BE%93%E5%87%BA%E9%A1%BA%E5%BA%8F%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="题："><a href="#题：" class="headerlink" title="题："></a>题：</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>()<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;宏任务&quot;</span>);<br>    &#125;, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// return 4</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">4</span>); <span class="hljs-comment">// 此处是迷惑点</span><br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>  &#125;);<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>()<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">5</span>);<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">6</span>);<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">7</span>);<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">8</span>);<br>  &#125;);<br></code></pre></td></tr></table></figure><h2 id="答："><a href="#答：" class="headerlink" title="答："></a>答：</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 输出结果</span><br><span class="hljs-number">0</span>;<br><span class="hljs-number">1</span>;<br><span class="hljs-number">2</span>;<br><span class="hljs-number">3</span>;<br><span class="hljs-number">4</span>;<br><span class="hljs-number">5</span>;<br><span class="hljs-number">6</span>;<br><span class="hljs-number">7</span>;<br><span class="hljs-number">8</span>;<br>宏任务;<br></code></pre></td></tr></table></figure><h2 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h2><p>| <code>return Promise.resolve(4)</code>会产生一个叫 job 的函数，等到当前执行栈为空的时候会去执行</p><p>| 微任务的执行中生成了微任务，那么会继续执行微任务，直到微任务队列为空。</p><ol><li><strong>宏任务队列 1</strong>,执行<code>Promise.resolve()</code></li><li>遇到<code>then()</code>回调,往微任务队列推入以下代码：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 微任务队列加入了以下代码</span><br><span class="hljs-comment">// 微任务队列1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;宏任务&quot;</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure><ol start="3"><li>仍然在当前宏任务往下执行，执行第二个<code>Promise.resolve()</code></li><li>遇到<code>then()</code>回调,往微任务队列推入以下代码:</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>所以此时微任务队列里有两个代码块待执行。队列就是先进先出的原则</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 第一个:A</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;宏任务&quot;</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">4</span>);<br><br><span class="hljs-comment">// 第二个:B</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><ol start="5"><li>此时代码模块里的宏任务都已经执行完了，开始捞取微任务到执行栈中执行。队列里第一个出来的也就是代码：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;宏任务&quot;</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure><p>输出 0。</p><p>注册一个 job，当执行栈为空的时候，job 进入队列。此时执行栈并不为空。A 出栈 B 入栈</p><p>6.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>输出 1。then 的回调推入微任务队列。B 出栈。执行栈为空。job 也进入微任务队列</p><p>函数是:<br>此时的微任务队列就有两个函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 第一个</span><br>.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>  &#125;)<br><br><span class="hljs-comment">// 第二个，job</span><br>(<span class="hljs-number">4</span>) =&gt; &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">resolvePromise</span>(promise2, <span class="hljs-number">4</span>, resolve, reject);<br>&#125;;<br></code></pre></td></tr></table></figure><hr><ol start="7"><li>输出 2 将它的回调函数推入微任务队列</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);<br>  &#125;)<br></code></pre></td></tr></table></figure><p>再去执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-number">4</span>) =&gt; &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">resolvePromise</span>(promise2, <span class="hljs-number">4</span>, resolve, reject);<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个函数会将</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">(res) =&gt; &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>&#125;;<br></code></pre></td></tr></table></figure><p>推入微任务队列</p><ol start="8"><li>输出 3 和 4</li></ol><p>输出 3 的回调再次推入微任务</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">5</span>);<br>  &#125;)<br></code></pre></td></tr></table></figure><ol start="9"><li><p> 输出 5</p></li><li><p>后续输出原理相同，输出 6,7,8</p></li><li><p>此时没有回调微任务进栈了，开始清空宏任务队列，也就是 setTimeout，输出<code>宏任务</code></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>技术类-前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue2源码</title>
    <link href="/20220222/vue2%E6%BA%90%E7%A0%81/"/>
    <url>/20220222/vue2%E6%BA%90%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h2 id="为什么data是函数，而components是对象？"><a href="#为什么data是函数，而components是对象？" class="headerlink" title="为什么data是函数，而components是对象？"></a>为什么data是函数，而components是对象？</h2><h2 id="data函数如果没有返回值会报错吗？"><a href="#data函数如果没有返回值会报错吗？" class="headerlink" title="data函数如果没有返回值会报错吗？"></a>data函数如果没有返回值会报错吗？</h2><p>答：会</p><blockquote><p>vue源码位置：src\core\instance\state.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">initData</span> (<span class="hljs-params">vm: Component</span>) &#123;<br>  <span class="hljs-keyword">let</span> data = vm.<span class="hljs-property">$options</span>.<span class="hljs-property">data</span><br>  data = vm.<span class="hljs-property">_data</span> = <span class="hljs-keyword">typeof</span> data === <span class="hljs-string">&#x27;function&#x27;</span><br>    ? <span class="hljs-title function_">getData</span>(data, vm)<br>    : data || &#123;&#125;<br>    <span class="hljs-comment">// //   看这里！这里有一个判断 isPlainObject(data)</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isPlainObject</span>(data)) &#123;<br>    data = &#123;&#125;<br>    process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp; <span class="hljs-title function_">warn</span>(<br>      <span class="hljs-string">&#x27;data functions should return an object:\n&#x27;</span> +<br>      <span class="hljs-string">&#x27;https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function&#x27;</span>,<br>      vm<br>    )<br>  &#125;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// ...</span><br>  <span class="hljs-comment">// observe data</span><br>  <span class="hljs-title function_">observe</span>(data, <span class="hljs-literal">true</span> <span class="hljs-comment">/* asRootData */</span>)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Vue源码位置：packages\weex-template-compiler\build.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isPlainObject</span> (<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">return</span> _toString.<span class="hljs-title function_">call</span>(obj) === <span class="hljs-string">&#x27;[object Object]&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>data函数</code>执行之后将返回值重新赋值给<code>data</code>，如果<code>data</code>不是个<code>object</code>，<code>name</code>就会报出一个警告</p><h2 id="为什么props定义的数据不能和data同名"><a href="#为什么props定义的数据不能和data同名" class="headerlink" title="为什么props定义的数据不能和data同名?"></a>为什么props定义的数据不能和data同名?</h2><blockquote><p>vue源码路径：vue\src\core\instance\state.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-comment">// proxy data on instance</span><br>  <span class="hljs-keyword">const</span> keys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(data)<br>  <span class="hljs-keyword">const</span> props = vm.<span class="hljs-property">$options</span>.<span class="hljs-property">props</span><br>  <span class="hljs-keyword">const</span> methods = vm.<span class="hljs-property">$options</span>.<span class="hljs-property">methods</span><br>  <span class="hljs-keyword">let</span> i = keys.<span class="hljs-property">length</span><br>  <span class="hljs-keyword">while</span> (i--) &#123;<br>    <span class="hljs-keyword">const</span> key = keys[i]<br>    <span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span>) &#123;<br>      <span class="hljs-keyword">if</span> (methods &amp;&amp; <span class="hljs-title function_">hasOwn</span>(methods, key)) &#123;<br>        <span class="hljs-title function_">warn</span>(<br>          <span class="hljs-string">`Method &quot;<span class="hljs-subst">$&#123;key&#125;</span>&quot; has already been defined as a data property.`</span>,<br>          vm<br>        )<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (props &amp;&amp; <span class="hljs-title function_">hasOwn</span>(props, key)) &#123;<br>      process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp; <span class="hljs-title function_">warn</span>(<br>        <span class="hljs-string">`The data property &quot;<span class="hljs-subst">$&#123;key&#125;</span>&quot; is already declared as a prop. `</span> +<br>        <span class="hljs-string">`Use prop default value instead.`</span>,<br>        vm<br>      )<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isReserved</span>(key)) &#123;<br>      <span class="hljs-title function_">proxy</span>(vm, <span class="hljs-string">`_data`</span>, key)<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>可以看到先获取<code>data</code>的<code>key</code>，然后再去调用<code>hasOwn</code>方法去判断<code>methods</code>和<code>props</code>里面是否有重复的<code>key</code>，有的话就会发出警告。最后都通过了之后就会调用<code>proxy(vm, &#39;_data&#39;, key)</code>，用封装的<code>proxy</code>方法对<code>vm实例</code>做了一层代理，使得我们可以直接通过<code>this</code>直接调用<code>key</code></p><h2 id="vue2代理的实现"><a href="#vue2代理的实现" class="headerlink" title="vue2代理的实现"></a>vue2代理的实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> sharedPropertyDefinition = &#123;<br>  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">get</span>: noop,<br>  <span class="hljs-attr">set</span>: noop<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">proxy</span> (<span class="hljs-params">target: <span class="hljs-built_in">Object</span>, sourceKey: string, key: string</span>) &#123;<br>  <span class="hljs-comment">// 去掉_props，vm._props.xxx =&gt; vm.xxx，可以直接访问</span><br>  sharedPropertyDefinition.<span class="hljs-property">get</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">proxyGetter</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>[sourceKey][key]<br>  &#125;<br>  sharedPropertyDefinition.<span class="hljs-property">set</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">proxySetter</span> (<span class="hljs-params">val</span>) &#123;<br>    <span class="hljs-variable language_">this</span>[sourceKey][key] = val<br>  &#125;<br>  <span class="hljs-comment">// 代理，</span><br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(target, key, sharedPropertyDefinition)<br>&#125;<br></code></pre></td></tr></table></figure><p>使用的是<code>Object.defineProperty</code>来实现的</p><h2 id="Vue的初始化"><a href="#Vue的初始化" class="headerlink" title="Vue的初始化"></a>Vue的初始化</h2><blockquote><p>Vue源码位置：src\core\instance\index.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">initMixin</span>(<span class="hljs-title class_">Vue</span>)<br><span class="hljs-title function_">stateMixin</span>(<span class="hljs-title class_">Vue</span>)<br><span class="hljs-title function_">eventsMixin</span>(<span class="hljs-title class_">Vue</span>)<br><span class="hljs-title function_">lifecycleMixin</span>(<span class="hljs-title class_">Vue</span>)<br><span class="hljs-title function_">renderMixin</span>(<span class="hljs-title class_">Vue</span>)<br></code></pre></td></tr></table></figure><p>最先执行的是<code>initMixin()</code>，我们看看里面有啥。</p><blockquote><p>Vue源码位置：src\core\instance\init.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//init.js</span><br><br>    <span class="hljs-comment">// 初始化</span><br>    vm.<span class="hljs-property">_self</span> = vm<br>    <span class="hljs-comment">// 生命周期</span><br>    <span class="hljs-title function_">initLifecycle</span>(vm)<br>    <span class="hljs-comment">// 事件</span><br>    <span class="hljs-title function_">initEvents</span>(vm)<br>    <span class="hljs-comment">// 渲染</span><br>    <span class="hljs-title function_">initRender</span>(vm)<br>    <span class="hljs-comment">// 面试题：beforeCreae和created之间做了什么？或者说二者有什么区别？</span><br>    <span class="hljs-comment">// 答：初始化injected，初始化state，初始化provide</span><br>    <span class="hljs-title function_">callHook</span>(vm, <span class="hljs-string">&#x27;beforeCreate&#x27;</span>)<br>    <span class="hljs-comment">// 初始化inject</span><br>    <span class="hljs-title function_">initInjections</span>(vm) <span class="hljs-comment">// resolve injections before data/props</span><br>    <span class="hljs-comment">// 初始化state，state里面有data，computed，method，props，watch</span><br>    <span class="hljs-title function_">initState</span>(vm)<br>    <span class="hljs-comment">// 初始化provide</span><br>    <span class="hljs-title function_">initProvide</span>(vm) <span class="hljs-comment">// resolve provide after data/props</span><br>    <span class="hljs-title function_">callHook</span>(vm, <span class="hljs-string">&#x27;created&#x27;</span>)<br></code></pre></td></tr></table></figure><p><code>initState()</code>是从<code>state.js</code>文件里面导入的，我们再去看看里面有什么。</p><blockquote><p>src\core\instance\state.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">initState</span> (<span class="hljs-params">vm: Component</span>) &#123;<br>  vm.<span class="hljs-property">_watchers</span> = []<br>  <span class="hljs-keyword">const</span> opts = vm.<span class="hljs-property">$options</span><br>  <span class="hljs-comment">// 初始化props</span><br>  <span class="hljs-keyword">if</span> (opts.<span class="hljs-property">props</span>) <span class="hljs-title function_">initProps</span>(vm, opts.<span class="hljs-property">props</span>)<br>  <span class="hljs-comment">// 初始化方法</span><br>  <span class="hljs-keyword">if</span> (opts.<span class="hljs-property">methods</span>) <span class="hljs-title function_">initMethods</span>(vm, opts.<span class="hljs-property">methods</span>)<br>  <span class="hljs-comment">// 初始化data</span><br>  <span class="hljs-keyword">if</span> (opts.<span class="hljs-property">data</span>) &#123;<br>    <span class="hljs-title function_">initData</span>(vm)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_">observe</span>(vm.<span class="hljs-property">_data</span> = &#123;&#125;, <span class="hljs-literal">true</span> <span class="hljs-comment">/* asRootData */</span>)<br>  &#125;<br>  <span class="hljs-comment">// 初始化computed</span><br>  <span class="hljs-keyword">if</span> (opts.<span class="hljs-property">computed</span>) <span class="hljs-title function_">initComputed</span>(vm, opts.<span class="hljs-property">computed</span>)<br>  <span class="hljs-comment">// 初始化watch</span><br>  <span class="hljs-keyword">if</span> (opts.<span class="hljs-property">watch</span> &amp;&amp; opts.<span class="hljs-property">watch</span> !== nativeWatch) &#123;<br>    <span class="hljs-title function_">initWatch</span>(vm, opts.<span class="hljs-property">watch</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可见在<code>beforeCreate</code>与<code>created</code>之间初始化了<code>inject</code>,<code>props</code>,<code>methods</code>,<code>data</code>,<code>computed</code>,<code>watch</code></p><h2 id="基于Vue2的proxy，自己实现一个代理"><a href="#基于Vue2的proxy，自己实现一个代理" class="headerlink" title="基于Vue2的proxy，自己实现一个代理"></a>基于Vue2的proxy，自己实现一个代理</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> noop = &#123;&#125; <br><br><span class="hljs-keyword">const</span> propertyDefinition = &#123;<br>    <span class="hljs-attr">enumerable</span>:<span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">configurable</span>:<span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">get</span>:noop,<br>    <span class="hljs-attr">set</span>:noop<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Proxy</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">target,sourceKey,key</span>)&#123;<br>    propertyDefinition.<span class="hljs-property">get</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">getter</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> target[sourceKey][key]<br>    &#125;<br><br>    propertyDefinition.<span class="hljs-property">set</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">setter</span> (<span class="hljs-params">val</span>) &#123;        <br>        target[sourceKey][key] = val<br>    &#125;<br><br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(target,key,propertyDefinition)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Vue</span>(<span class="hljs-params">data</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_data</span> = data<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">_data</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>        <span class="hljs-title class_">Proxy</span>(<span class="hljs-variable language_">this</span>,<span class="hljs-string">&#x27;_data&#x27;</span>,key)<br>    &#125;)<br>&#125;<br><br><span class="hljs-keyword">const</span> vueIns = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<span class="hljs-attr">a</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">b</span>:<span class="hljs-number">2</span>&#125;)<br><br>vueIns.<span class="hljs-property">_data</span>.<span class="hljs-property">b</span> = <span class="hljs-string">&#x27;hhh&#x27;</span><br>vueIns.<span class="hljs-property">a</span> = <span class="hljs-number">2222</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(vueIns.<span class="hljs-property">_data</span>.<span class="hljs-property">a</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(vueIns.<span class="hljs-property">b</span>)<br><br></code></pre></td></tr></table></figure><h2 id="Vue的实例为什么不能挂载在body或根节点上？挂载了会报错吗？"><a href="#Vue的实例为什么不能挂载在body或根节点上？挂载了会报错吗？" class="headerlink" title="Vue的实例为什么不能挂载在body或根节点上？挂载了会报错吗？"></a>Vue的实例为什么不能挂载在body或根节点上？挂载了会报错吗？</h2><p>答：挂载节点会被虚拟dom生成的Dom替换，会报错</p><blockquote><p>Vue源码位置：src\platforms\web\entry-runtime-with-compiler.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (el === <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span> || el === <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>) &#123;<br>    process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp; <span class="hljs-title function_">warn</span>(<br>      <span class="hljs-string">`Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`</span><br>    )<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span><br>  &#125;<br></code></pre></td></tr></table></figure><h2 id="Vue-set方法是如何实现的"><a href="#Vue-set方法是如何实现的" class="headerlink" title="Vue.set方法是如何实现的"></a>Vue.set方法是如何实现的</h2><p>在 Vue2中由于<code>Object.defineProperty</code>的局限性，无法原生监听对象新增属性、删除属性或者数组索引操作，所以提供了 <code>Vue.set</code> 方法作为补偿 api来解决这个问题。</p><h3 id="Vue-set的核心作用是："><a href="#Vue-set的核心作用是：" class="headerlink" title="Vue.set的核心作用是："></a>Vue.set的核心作用是：</h3><ul><li>为响应式对象新增属性，并让该属性也具备响应式能力（即被 getter、setter 拦截）</li><li>触发该对象的依赖更新（即通知所有依赖该属性的 watcher 执行更新）</li></ul><h3 id="实现的核心逻辑"><a href="#实现的核心逻辑" class="headerlink" title="实现的核心逻辑"></a>实现的核心逻辑</h3><ol><li>参数校验与边界处理<ul><li>接收三个参数：target（目标对象/数组）、key（新增属性名/索引）、value（新增属性值）</li><li>如果 target 是 vue 实例或者 $data(根数据对象)，直接报错。vue 不允许给实例添加根级响应式属性</li><li>如果 target 不是响应式对象(未被 Observer 处理过)，直接赋值target[key] = value，然后返回。非响应式数据无需劫持。</li></ul></li><li>处理数组的情况<br> 如果 target 是数组且 key 是有效的索引：<ul><li>计算实际索引（处理负数索引，如 <code>key=-1</code> 对应 <code>target.length-1</code>）</li><li>使用 splice 方法在指定索引位置新增元素</li></ul></li></ol><p><strong>核心操作：</strong> 调用数组的 splice 方法替换元素(target.splice(key,1,val))。因为 Vue 已经重写了数组的 splice 方法，使其执行的时候会触发依赖更新（dep.notify()），同时新插入的 val 会被转为响应式。</p><ol start="3"><li>处理对象的情况<br> 如果 target 是对象：<ul><li>如果 key 已存在与 target，那么旧直接赋值<code>target[key] = value</code>，会触发 setter，自动更新依赖。</li><li>如果 key 是新属性：<ul><li>获取 target 对象的 Observer 实例（Vue 内部用于管理响应式的对象，每个响应式数据都有一个 Observer 实例）</li><li>调用 Observer 实例的 defineReactive 方法，为新属性key 添加 getter/setter，使其具备响应式属性。</li><li>触发 target 对象的依赖更新，通过 Observer 实例的 dep.notify() 方法通知所有依赖该对象的 watcher 执行更新。</li></ul></li></ul></li></ol><h2 id="computed-和-watch-的区别"><a href="#computed-和-watch-的区别" class="headerlink" title="computed 和 watch 的区别"></a>computed 和 watch 的区别</h2><h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><p>从现有响应式数据中动态派生新值。</p><ul><li>显式依赖响应式数据（data、props），依赖关系是“多对一”，可从多个数据派生出一个新值。</li><li>只有当依赖的数据发生变化时，才会重新计算，若依赖未变，直接返回缓存的结果。</li><li>触发时机是惰性的，只有当计算结果被模板或者其他响应式数据使用时才会触发计算。</li></ul><h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><ul><li>监听响应式数据变化并执行副作用。</li><li>可以监听单个或多个响应式数据（data、props、computed），依赖关系是“一对多”或者“多对多”（一个数据变化可以触发多个操作）</li><li>触发时机是主动的，当监听的响应式数据发生变化时，会立即执行回调函数。</li><li>当监听的数据变化时，都会执行回调函数，不会缓存执行结果。</li><li>配置灵活，支持<code>deep: true</code>深度监听，以及<code>immediate: true</code>立即执行回调，<code>handler（回调函数）</code>等选项。</li></ul><h2 id="new-Vue-过程中做了些什么"><a href="#new-Vue-过程中做了些什么" class="headerlink" title="new Vue()过程中做了些什么"></a>new Vue()过程中做了些什么</h2><p>new Vue(options)的过程是实例初始化的核心流程，本质是通过一系列初始化步骤将传入的配置（options）转化为一个可响应、可渲染的 Vue 实例。</p><p>整个过程可分为<strong>选项合并</strong>、<strong>初始化核心模块</strong>、<strong>模板编译与挂载</strong>三大阶段。</p><h3 id="选项合并"><a href="#选项合并" class="headerlink" title="选项合并"></a>选项合并</h3><p>Vue 实例接收的 options（如 data、methods、components 等）并非直接使用，而是需要与全局配置（Vue.config）、组件继承的配置（若为组件实例）进行合并，最终生成一个统一的配置对象。</p><h3 id="初始化核心模块"><a href="#初始化核心模块" class="headerlink" title="初始化核心模块"></a>初始化核心模块</h3><ol><li>初始化生命周期</li><li>初始化事件系统（$on、$emit、$off等）</li><li>初始化注入（inject），从父组件的 provide 中获取对应的值</li><li>初始化状态，处理 data、props、computed、watch 等核心数据<ol><li>初始化 props</li><li>初始化 methods</li><li>初始化 data</li><li>初始化 computed</li><li>初始化 watch</li></ol></li><li>初始化 provide</li></ol><h3 id="模板编译与挂载"><a href="#模板编译与挂载" class="headerlink" title="模板编译与挂载"></a>模板编译与挂载</h3><ol><li>模板编译<br> 将模板转换为 render 渲染函数<ul><li>解析：将模板字符串解析为 AST（抽象语法数）</li><li>优化：优化 AST，标记 AST 中的静态节点，避免每次更新时重新渲染</li><li>生成：将 AST 转换为 render 函数</li></ul></li><li>挂载<br> 通过 render 函数生成虚拟 DOM，再将虚拟 DOM 渲染为真实 DOM 并插入到 el 对应的容器中</li></ol><h2 id="Vue-observable的了解"><a href="#Vue-observable的了解" class="headerlink" title="Vue.observable的了解"></a>Vue.observable的了解</h2><p>在 Vue 2 中，Vue.observable 是一个全局 API，定义在 Vue 构造函数上，源码基于响应式系统的核心逻辑实现。</p><h3 id="核心作用"><a href="#核心作用" class="headerlink" title="核心作用"></a>核心作用</h3><p>将一个普通对象转换为响应式对象，使其具备 “数据变化时触发依赖更新” 的能力。转换后的对象可以被组件引用，当对象属性变化时，引用它的组件会自动重新渲染。</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>与组件内 data 的响应式处理逻辑一致：通过 Object.defineProperty 对对象的属性递归添加 getter/setter，实现依赖收集（getter 时）和更新触发（setter 时），本质是创建了一个 Observer 实例来管理该对象的响应式。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// store.js</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-comment">// 创建响应式状态对象</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> store = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">observable</span>(&#123;<br>  <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-attr">user</span>: &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span> &#125;<br>&#125;)<br><br><span class="hljs-comment">// 定义修改状态的方法</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> mutations = &#123;<br>  <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;<br>    store.<span class="hljs-property">count</span>++<br>  &#125;,<br>  <span class="hljs-title function_">setName</span>(<span class="hljs-params">name</span>) &#123;<br>    store.<span class="hljs-property">user</span>.<span class="hljs-property">name</span> = name<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术类-Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法</title>
    <link href="/20220127/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <url>/20220127/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="1-线性表"><a href="#1-线性表" class="headerlink" title="1.线性表"></a>1.线性表</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote><p>线性表是具有相同数据类型的 n(n≥0)个数据元素的有限序列。其中 n 为表长，当 n=0 时该线性表是一个空表。</p></blockquote><p>若用 L 命名线性表，则其一般表示如下：</p><pre><code class="hljs">L=(a1,a2,...ai,ai+1,...,an)</code></pre><p>其中，a1 是唯一的“第一个”数据元素，又称为表头元素；an 是唯一的“最后一个”数据元素，又称为表尾元素。除第一个元素外，每个元素有且仅有一个直接前驱；除最后一个元素外，每个元素有且仅有一个直接后继。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>线性表常见的特点如下：</p><ul><li><p>表中元素的个数是有限的；</p></li><li><p>表中元素具有逻辑上的顺序性，在序列中各元素排列有先后次序；</p></li><li><p>表中元素都是数据元素，每一个表元素都是单个元素；</p></li><li><p>表中元素的数据类型都相同，这意味着每一个表元素占有相同数量的存储空间；</p></li><li><p>表中元素具有抽象性，就是说，仅讨论表元素之间的逻辑关系，不考虑表元素究竟表示什么内容</p></li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><img src="/20220127/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%88%86%E7%B1%BB.jpg" class="" title="线性表的分类"><h3 id="线性表的基本操作"><a href="#线性表的基本操作" class="headerlink" title="线性表的基本操作"></a>线性表的基本操作</h3><pre><code class="hljs"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">InitList</span>(L); <span class="hljs-comment">//初始化表。构造一个空的线性表；</span><br><span class="hljs-title class_">Legnth</span>(L); <span class="hljs-comment">//求表长度。返回线性表L的长度，即L中数据元素的个数；</span><br><span class="hljs-title class_">LocateElem</span>(L, e); <span class="hljs-comment">//按值查找操作。在表L中查找具有给定关键字值的元素；</span><br><span class="hljs-title class_">GetElem</span>(L, i); <span class="hljs-comment">//按位查找操作。获取表L中第i个位置的元素的值；</span><br><span class="hljs-title class_">ListInsert</span>(L, i, e); <span class="hljs-comment">//插入操作。在表L中第i个位置上插入制定元素；</span><br><span class="hljs-title class_">ListDelete</span>(L, i, e); <span class="hljs-comment">//删除操作。删除表L中第i个位置上的元素；</span><br><span class="hljs-title class_">PrintList</span>(L); <span class="hljs-comment">//输出操作。按前后顺序输出线性表L的所有元素的值；</span><br><span class="hljs-title class_">Empty</span>(L); <span class="hljs-comment">//判空操作</span><br></code></pre></td></tr></table></figure></code></pre><h2 id="1-1-线性表的顺序表示-顺序表"><a href="#1-1-线性表的顺序表示-顺序表" class="headerlink" title="1.1 线性表的顺序表示(顺序表)"></a>1.1 线性表的顺序表示(顺序表)</h2><blockquote><p>线性表的顺序存储又称之为<strong>顺序表</strong>。</p></blockquote><p>它是用一组连续地址的存储单元，依次存储线性表的数据元素，从而使得逻辑上相邻的两个元素在物理上也相邻。</p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul><li>顺序表中元素的逻辑顺序与物理顺序相同</li></ul><h2 id="2-链表"><a href="#2-链表" class="headerlink" title="2. 链表"></a>2. 链表</h2>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6随笔</title>
    <link href="/20220114/ES6%E9%9A%8F%E7%AC%94/"/>
    <url>/20220114/ES6%E9%9A%8F%E7%AC%94/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.bookstack.cn/read/es6-3rd/sidebar.md">参考资料：阮一峰 ES6 标准入门教程第三版</a></p><blockquote><p>本文用于记录我觉得 ES6 中重要的原理和使用技巧</p></blockquote><h2 id="class-的继承"><a href="#class-的继承" class="headerlink" title="class 的继承"></a>class 的继承</h2><p>Class 可以通过 extends 关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ColorPoint</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Point</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x, y, color</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(x, y); <span class="hljs-comment">// 调用父类的constructor(x, y)</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span> = color;<br>  &#125;<br>  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span> + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// 调用父类的toString()</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>子类必须在 constructor 方法中调用 super 方法，否则新建实例时会报错。这是因为子类自己的 this 对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用 super 方法，子类就得不到 this 对象。</p><p>ES5 的继承，实质是先创造子类的实例对象 this，然后再将父类的方法添加到 this 上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到 this 上面（所以必须先调用 super 方法），然后再用子类的构造函数修改 this。</p><hr><h2 id="20220502-更新"><a href="#20220502-更新" class="headerlink" title="20220502 更新"></a>20220502 更新</h2><blockquote><p>构造函数的 prototype 属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的 prototype 属性上面。 –阮一峰《ES6》</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>  <span class="hljs-title function_">toValue</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br><span class="hljs-comment">// 等同于</span><br><span class="hljs-title class_">Point</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;&#125;,<br>  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;&#125;,<br>  <span class="hljs-title function_">toValue</span>(<span class="hljs-params"></span>) &#123;&#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>当我想打印输出看一下<code>console.log(Point.prototype)</code>的时候输出却是<code>&#123;&#125;</code>,感到很奇怪，明明方法是定义在<code>prototype</code>属性上的，为什么输出确实空的呢？</p><p>查了一下发现：</p><blockquote><p>这是因为 <code>console.log()</code>使用了 <code>util.inspect()</code>，它使用了 Object。对象上的<code>keys()</code>，它只返回可枚举的属性。并且 <code>Object.prototype</code> 包含非可枚举属性，这就是它返回空节点的原因。</p></blockquote><p>因为那些方法都默认是不可枚举的，所以当我们想定义一个可枚举的属性时可以使用<code>Object.defineProperty()</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-title class_">Point</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">&quot;hh&quot;</span>, &#123;<br>  <span class="hljs-attr">value</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);<br>  &#125;,<br>  <span class="hljs-comment">// 可枚举</span><br>  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Point</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br></code></pre></td></tr></table></figure><p>这下打印出了<code>&#123; hh: [Function: value] &#125;</code></p><hr>]]></content>
    
    
    
    <tags>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>装饰器的使用</title>
    <link href="/20211223/%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/20211223/%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="在-create-react-app-搭建的项目中使用装饰器"><a href="#在-create-react-app-搭建的项目中使用装饰器" class="headerlink" title="在 create-react-app 搭建的项目中使用装饰器"></a>在 create-react-app 搭建的项目中使用装饰器</h2><ol><li><p>执行<code>yarn eject</code>命令，暴露出配置项</p></li><li><p>因为装饰器是新的提案，许多浏览器和 Node 环境并不支持，所以我们需要安装插件：<code>@babel/plugin-proposal-decorators</code>。使用<code>create-react-app</code>创建的项目自带这个插件，不过我们需要配置一下，找到<code>package.json</code>文件加入一下代码：</p></li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;babel&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;presets&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;react-app&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><br>    <span class="hljs-attr">&quot;plugins&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;@babel/plugin-proposal-decorators&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;legacy&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>另外 vscode 可能会提示你需要配置<code>tsconfig</code>或<code>jsconfig</code>文件，我们在项目根目录创建<code>jsconfig.js</code>，并写入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;compilerOptions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;experimentalDecorators&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>这样就能愉快的在项目中使用装饰器了</p><h2 id="装饰器的使用"><a href="#装饰器的使用" class="headerlink" title="装饰器的使用"></a>装饰器的使用</h2><h3 id="使用装饰器修饰类"><a href="#使用装饰器修饰类" class="headerlink" title="使用装饰器修饰类"></a>使用装饰器修饰类</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//声明一个装饰器</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">target</span>) &#123;<br>  <span class="hljs-comment">//这个函数的`target`指的就是装饰器要修饰的类</span><br>  target.<span class="hljs-property">test</span> = <span class="hljs-literal">false</span>;<br>&#125;<br><br>@fn <span class="hljs-comment">//使用装饰器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-comment">//声明一个类</span><br>&#125;<br>@fn<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;<br>  <span class="hljs-comment">//声明另一个类</span><br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property">test</span>); <span class="hljs-comment">//false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Dog</span>.<span class="hljs-property">test</span>); <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/13931286-758df1981c769cd2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="输出结果"></p><p>可以看到<code>Person</code>类和<code>Dog</code>类下面多出了一个<code>test</code>属性，这就体现了装饰器的优点，无需更改类的内部代码也无需去继承就可以给类添加新功能</p><h3 id="使用装饰器传参"><a href="#使用装饰器传参" class="headerlink" title="使用装饰器传参"></a>使用装饰器传参</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js">@fn<br>@<span class="hljs-title function_">fn2</span>(<span class="hljs-number">5</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">target</span>) &#123;<br>  target.<span class="hljs-property">test</span> = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn2</span>(<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">target</span>) &#123;<br>    <span class="hljs-comment">//这个函数的`target`指的就是装饰器要修饰的类</span><br>    target.<span class="hljs-property">count</span> = value;<br>  &#125;;<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property">test</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property">count</span>);<br></code></pre></td></tr></table></figure><p>声明一个装饰器<code>fn2</code>，它接收一个值，并且返回一个函数，这个函数的<code>target</code>指的就是装饰器要修饰的类<br><img src="https://upload-images.jianshu.io/upload_images/13931286-446a1e6ba77e0c89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="输出结果"></p><h3 id="使用装饰器添加实例属性"><a href="#使用装饰器添加实例属性" class="headerlink" title="使用装饰器添加实例属性"></a>使用装饰器添加实例属性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js">@fn<br>@<span class="hljs-title function_">fn2</span>(<span class="hljs-number">5</span>)<br>@fn3<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">target</span>) &#123;<br>  target.<span class="hljs-property">test</span> = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn2</span>(<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">target</span>) &#123;<br>    target.<span class="hljs-property">count</span> = value;<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn3</span>(<span class="hljs-params">target</span>) &#123;<br>  target.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">foo</span> = <span class="hljs-string">&quot;hhh&quot;</span>; <span class="hljs-comment">// target指的就是装饰的类，在类的原型对象上添加一个属性foo</span><br>&#125;<br><br><span class="hljs-keyword">const</span> test1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(); <span class="hljs-comment">// new一个实例出来</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(test1.<span class="hljs-property">foo</span>);<br></code></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/13931286-d69f263c088633e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="输出结果"></p><h3 id="实现一个混入-mixins-功能"><a href="#实现一个混入-mixins-功能" class="headerlink" title="实现一个混入 mixins 功能"></a>实现一个混入 mixins 功能</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 实现一个mixins功能</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">mixins</span>(<span class="hljs-params">...list</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">target</span>) &#123;<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(target.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, ...list);<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">import</span> &#123; mixins &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./mixins&quot;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Test</span> = &#123;<br>  <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;这是测试&quot;</span>);<br>  &#125;,<br>&#125;;<br><br>@<span class="hljs-title function_">mixins</span>(<span class="hljs-title class_">Test</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Myclass</span> &#123;&#125;<br><br><span class="hljs-keyword">const</span> newMyclass = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Myclass</span>();<br>newMyclass.<span class="hljs-title function_">test</span>(); <span class="hljs-comment">//这是测试</span><br></code></pre></td></tr></table></figure><h3 id="使用装饰器修饰类的成员"><a href="#使用装饰器修饰类的成员" class="headerlink" title="使用装饰器修饰类的成员"></a>使用装饰器修饰类的成员</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js">@fn<br>@<span class="hljs-title function_">fn2</span>(<span class="hljs-number">5</span>)<br>@fn3<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  @readonly message = <span class="hljs-string">&quot;hello&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">target</span>) &#123;<br>  target.<span class="hljs-property">test</span> = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn2</span>(<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">target</span>) &#123;<br>    target.<span class="hljs-property">count</span> = value;<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn3</span>(<span class="hljs-params">target</span>) &#123;<br>  target.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">foo</span> = <span class="hljs-string">&quot;hhh&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">readonly</span>(<span class="hljs-params">target, name, descriptor</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target); <span class="hljs-comment">//目标类的原型对象 xxx.prototype</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name); <span class="hljs-comment">// 被修饰的类的成员名称</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(descriptor);<br>  <span class="hljs-comment">/*被修饰的类的成员的描述对象：</span><br><span class="hljs-comment">    configurable: 能否使用delete、能否需改属性特性、或能否修改访问器属性、，false为不可重新定义，默认值为true</span><br><span class="hljs-comment">    enumerable: 是否被遍历，对象属性是否可通过for-in循环，flase为不可循环，默认值为true</span><br><span class="hljs-comment">    initializer: 对象属性的默认值，默认值为undefined</span><br><span class="hljs-comment">    writable: 对象属性是否可修改,flase为不可修改，默认值为true</span><br><span class="hljs-comment">  */</span><br><br>  descriptor.<span class="hljs-property">writable</span> = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> test1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>test1.<span class="hljs-property">message</span> = <span class="hljs-string">&quot;你好&quot;</span>;<br></code></pre></td></tr></table></figure><p>它接收三个参数，具体看以上代码注释</p><p><img src="https://upload-images.jianshu.io/upload_images/13931286-4f66e2ca9e5b7c34.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="输出结果"></p>]]></content>
    
    
    <categories>
      
      <category>技术类-前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React随笔</title>
    <link href="/20211218/React%E9%9A%8F%E7%AC%94/"/>
    <url>/20211218/React%E9%9A%8F%E7%AC%94/</url>
    
    <content type="html"><![CDATA[<h2 id="React-中的this"><a href="#React-中的this" class="headerlink" title="React 中的this"></a>React 中的<code>this</code></h2><p>React 的官方文档里写的自定义的方法都需要用 bind 方法绑定一下才能使用，否则 this 会出现指向问题，那究竟是为什么呢？</p><h3 id="探讨一"><a href="#探讨一" class="headerlink" title="探讨一"></a>探讨一</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<br>            ......<br>        &#125;<br>    &#125;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;demo&#125;</span>&gt;</span>你好，DexterHwang<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">demo</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>)   <span class="hljs-comment">// 会报错，注意此处的this</span><br>&#125;<br><br><span class="hljs-title class_">ReactDom</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Person</span> /&gt;</span></span>,<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;app&#x27;</span>))<br></code></pre></td></tr></table></figure><p><code>React</code> 中的 <code>Babel</code> 使用了严格模式，所以写的全局的 <code>this</code>指向的是<code>undefined</code></p><p>而且 <code>demo</code> 方法并不写在 <code>Person</code> 类中，所以这个 <code>this</code> 也不会指向 <code>Person</code> 的实例对象</p><h3 id="探讨二"><a href="#探讨二" class="headerlink" title="探讨二"></a>探讨二</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<br>            ......<br>        &#125;<br>    &#125;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;demo&#125;</span>&gt;</span>你好，DexterHwang<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span> <span class="hljs-comment">// 会报错，报错信息为：`demo is not defined`。`onClick=&#123;demo&#125;`是找不到 `demo` 方法的</span><br>        <span class="hljs-comment">// return &lt;div onClick=&#123;this.demo&#125;&gt;你好，DexterHwang&lt;/div&gt; // 这样写也会报错，因为并不是通过实例对象去调用demo方法。由于demo是作为onClick的回调，不是通过实例调用的，是直接调用。类中的方法默认开启了局部的严格模式，所以this值是undefined</span><br>    &#125;<br>    <span class="hljs-comment">// demo方法在Person的原型对象(prototype)上，也就是在Person的实例对象的原型链上(_proto_)</span><br>    <span class="hljs-comment">// 只有通过Person实例对象调用demo方法时，demo里面的this指向的就是Person的实例对象</span><br>    <span class="hljs-title function_">demo</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-title class_">ReactDom</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Person</span> /&gt;</span></span>,<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;app&#x27;</span>))<br></code></pre></td></tr></table></figure><p>我们看下面的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  &#125;<br>  <span class="hljs-title function_">study</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;DexterHwang&quot;</span>, <span class="hljs-number">18</span>);<br><br>p1.<span class="hljs-title function_">study</span>(); <span class="hljs-comment">//&#123;name:&#x27;DexterHwang&#x27;,age:18&#125;</span><br><span class="hljs-keyword">const</span> x = p1.<span class="hljs-property">study</span>;<br><span class="hljs-title function_">x</span>(); <span class="hljs-comment">// 输出undefined</span><br></code></pre></td></tr></table></figure><p>p1 的原型链上是可以找到 study 方法的，然后把 study 方法赋值给了 x。也就相当于在栈上多了一个指针指向了 study 方法，这下 x 就彻底和 p1 没有关系了</p><p>另外，再明确一点：_类中自定义的方法，都会启用局部严格模式_。也就是说 this 的值是 undefined</p><p>也就是说 x 执行后 this 值就是 undefined</p><p>验证：<em>类中自定义的方法，都会启用局部严格模式</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test2</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-string">&quot;use strict&quot;</span>;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>&#125;<br><br><span class="hljs-title function_">test</span>(); <span class="hljs-comment">// window</span><br><span class="hljs-title function_">test2</span>(); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><h3 id="分析-this-demo-this-demo-bind-this"><a href="#分析-this-demo-this-demo-bind-this" class="headerlink" title="分析 this.demo = this.demo.bind(this)"></a>分析 <code>this.demo = this.demo.bind(this)</code></h3><p>为什么用 bind()就可以解决 this 指向问题呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<br>            ......<br>        &#125;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">demo</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">demo</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>)<br>    &#125;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.demo&#125;</span>&gt;</span>你好，DexterHwang<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    &#125;<br><br>    <span class="hljs-title function_">demo</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-title class_">ReactDom</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Person</span> /&gt;</span></span>,<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;app&#x27;</span>))<br><br><span class="hljs-comment">// 点击后会输出：Person&#123;...&#125;</span><br></code></pre></td></tr></table></figure><p>分析<code>this.demo = this.demo.bind(this)</code></p><p>等号右侧的第一个 this 指向的是实例对象，这个实例对象上有 demo 方法吗？有，但是实在原型链上的。</p><p>bind 方法做两件事：</p><ol><li>将 this 牢牢的绑定到传入的参数上</li><li>返回一个新的函数</li></ol><p>等号右边第二个 this，也就是传入的参数，这个 this 指的就是实例对象</p><p>这样的话返回了一个新的函数，而且这个函数牢牢的绑定到了实例对象上，并不需要去原型链上找了</p><p>再看等号左侧，将返回的新函数赋值给了 this，这个 this 也是 Person 实例对象，用相同的方法名接收一下</p><p>这样就可以使用了</p><p>我们这样再去看<code>onClick=&#123;this.demo&#125;</code>,这下再点击后执行的就是实例自身上的 demo 方法了。</p><hr><h2 id="2021-12-25-更新——-React17-对比新旧生命周期"><a href="#2021-12-25-更新——-React17-对比新旧生命周期" class="headerlink" title="2021-12-25 更新—— React17 对比新旧生命周期"></a>2021-12-25 更新—— React17 对比新旧生命周期</h2><p>新的生命周期和旧的生命周期相比，即将废弃三个钩子：<code>componentWillMount</code>、<code>componentWillUpdate</code>、<code>componentWillReceiveProps</code></p><p>新增了两个新的钩子：<code>getDerivedStateFromProps</code>、<code>getSnapshotBeforeUpdate</code></p><p>剩下的都和之前的一样的</p><h2 id="2021-12-16-更新——-React-配置代理"><a href="#2021-12-16-更新——-React-配置代理" class="headerlink" title="2021-12-16 更新—— React 配置代理"></a>2021-12-16 更新—— React 配置代理</h2><p>单个代理可以直接在<code>package.json</code>文件中配置<code>proxy</code></p><p>多个代理则需要新建一个<code>setupProxy.js</code>文件，配置如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> proxy = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http-proxy-middleware&quot;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">app</span>) &#123;<br>  app.<span class="hljs-title function_">use</span>(<br>    <span class="hljs-title function_">proxy</span>(<span class="hljs-string">&quot;/api1&quot;</span>, &#123;<br>      <span class="hljs-comment">//遇见api1前缀的请求，就会触发这个代理配置</span><br>      <span class="hljs-attr">target</span>: <span class="hljs-string">&quot;http://localhost:5000&quot;</span>, <span class="hljs-comment">// 请求转发给谁，也就是服务器地址</span><br>      <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 控制服务器收到的请求头中Host的值，这里是localhost:5000</span><br>      <span class="hljs-attr">pathRewrite</span>: &#123; <span class="hljs-string">&quot;^/api1&quot;</span>: <span class="hljs-string">&quot;&quot;</span> &#125;, <span class="hljs-comment">// 重写请求路径</span><br>    &#125;),<br>    <span class="hljs-title function_">proxy</span>(<span class="hljs-string">&quot;/api2&quot;</span>, &#123;<br>      <span class="hljs-attr">target</span>: <span class="hljs-string">&quot;http://localhost:5001&quot;</span>,<br>      <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">pathRewrite</span>: &#123; <span class="hljs-string">&quot;^/api2&quot;</span>: <span class="hljs-string">&quot;&quot;</span> &#125;,<br>    &#125;)<br>  );<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>create-react-app</code>脚手架会自动找到<code>setupProxy.js</code>文件，并将配置加入到 webpack 中</p><h2 id="2021-12-27-更新——-React-路由原理"><a href="#2021-12-27-更新——-React-路由原理" class="headerlink" title="2021-12-27 更新—— React 路由原理"></a>2021-12-27 更新—— React 路由原理</h2><p>靠的是 H5 推出的 history 上的 API</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//路由跳转</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">push</span>(<span class="hljs-params">path</span>) &#123;<br>  history.<span class="hljs-title function_">push</span>(path);<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 路由替换</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">replace</span>(<span class="hljs-params">path</span>) &#123;<br>  history.<span class="hljs-title function_">replace</span>(path);<br>&#125;<br><br><span class="hljs-comment">// 路由回退</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">back</span>(<span class="hljs-params"></span>) &#123;<br>  history.<span class="hljs-title function_">goBack</span>();<br>&#125;<br><br><span class="hljs-comment">// 路由前进</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">forword</span>(<span class="hljs-params"></span>) &#123;<br>  history.<span class="hljs-title function_">goForward</span>();<br>&#125;<br><br><span class="hljs-comment">// 监听路由变化</span><br>history.<span class="hljs-title function_">listen</span>(<span class="hljs-function">(<span class="hljs-params">location</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;监听路由变化&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="2021-12-28-更新——-全局事件总线"><a href="#2021-12-28-更新——-全局事件总线" class="headerlink" title="2021-12-28 更新—— 全局事件总线"></a>2021-12-28 更新—— 全局事件总线</h2><p>用第三方库<code>mitt</code>或者<code>pubsub</code>，可以实现多层级的组件之间的通信</p><h2 id="2021-12-30-更新——-React-的-setState"><a href="#2021-12-30-更新——-React-的-setState" class="headerlink" title="2021-12-30 更新—— React 的 setState()"></a>2021-12-30 更新—— React 的 setState()</h2><p>异步执行</p><ol><li><p>多个 setState()会推到一个任务队列里面，将多次执行合并为一个来执行。</p></li><li><p>setState()的几种写法</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//常规写法，这种写法会将多次setState()方法合并</span><br><span class="hljs-comment">// counter的初始值为1</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>  <span class="hljs-attr">counter</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">counter</span> + <span class="hljs-number">1</span>,<br>&#125;);<br><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>  <span class="hljs-attr">counter</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">counter</span> + <span class="hljs-number">1</span>,<br>&#125;);<br><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>  <span class="hljs-attr">counter</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">counter</span> + <span class="hljs-number">1</span>,<br>&#125;);<br><span class="hljs-comment">// counter的值是2</span><br><span class="hljs-comment">// ----------------------------------------</span><br><span class="hljs-comment">// 这种写法和上面执行结果不同，preState拿到的是最新的设置后的值（上一个setState设置的值）</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<span class="hljs-function">(<span class="hljs-params">preState</span>) =&gt;</span> (&#123;<br>  <span class="hljs-attr">counter</span>: preState.<span class="hljs-property">counter</span> + <span class="hljs-number">1</span>,<br>&#125;));<br><br><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<span class="hljs-function">(<span class="hljs-params">preState</span>) =&gt;</span> (&#123;<br>  <span class="hljs-attr">counter</span>: preState.<span class="hljs-property">counter</span> + <span class="hljs-number">1</span>,<br>&#125;));<br><br><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<span class="hljs-function">(<span class="hljs-params">preState</span>) =&gt;</span> (&#123;<br>  <span class="hljs-attr">counter</span>: preState.<span class="hljs-property">counter</span> + <span class="hljs-number">1</span>,<br>&#125;));<br><span class="hljs-comment">// counter的值是4</span><br></code></pre></td></tr></table></figure><p>setState()方法里的第二个参数是一个回调函数，该函数能拿到设置之后的值</p><h2 id="2021-12-31-更新——-无副作用"><a href="#2021-12-31-更新——-无副作用" class="headerlink" title="2021-12-31 更新—— 无副作用"></a>2021-12-31 更新—— 无副作用</h2><p>在 React 里经常看到<code>无副作用</code>这个词，它表示它只对自身有影响对自身以外的无影响，所有的输出都是由我的输入来决定的。</p><p>发一个请求，设置了 localstorage，对外部进行了操作这都叫做<strong>副作用</strong></p><h2 id="React-生命周期"><a href="#React-生命周期" class="headerlink" title="React 生命周期"></a>React 生命周期</h2><ol><li>组件初始化阶段 initialization, 比如 constructor</li><li>组件挂载阶段 mount<ol><li>componentWillMount 组件挂载到 DOM 前调用,只会被调用一次, 这里写 setState 不会引起组件重新渲染</li><li>render 返回一个 react 元素, react 根据此函数的返回值渲染 DOM. 不能在这里 setState</li><li>componentDidMount 组件挂载到 DOM 后调用, 且只会被调用一次</li></ol></li><li>组件的更新阶段 update<ol><li>componentWillReceiveProps(nextProps) 触发于 props 引起的组件更新过程中</li><li>shouldComponentUpdate(nextProps, nextState) 比较之前和当前的 props state 是否有变化</li><li>componentWillUpdate(nextProps, nextState) render 方法前执行</li><li>render</li><li>componentDidUpdate(preProps, preState)</li></ol></li><li>组件的卸载阶段 unmount<ol><li>componentWillUnmount 卸载前调用, 在这里可以清理一些定时器</li></ol></li></ol><p><code>componentWillMount</code>,<code>componentWillReceiveProps</code>,<code>componentWillUnmount</code>在 React17 不建议使用，即将被废弃</p><h2 id="2022-06-30-更新-React-的虚拟-DOM"><a href="#2022-06-30-更新-React-的虚拟-DOM" class="headerlink" title="2022-06-30 更新 React 的虚拟 DOM"></a>2022-06-30 更新 React 的虚拟 DOM</h2><p>在 React，我们操作的元素被称为 React 元素，并不是真正的原生 DOM 元素。</p><p>React 通过虚拟 DOM，将 React 元素和原生 DOM，进行映射，虽然操作的是 React 元素，但是这些操作最终都会在真实的 DOM 中体现。</p><p>虚拟 DOM 的好处：</p><ul><li>降低 api 复杂度（远离原生的复杂的 dom 操作）</li><li>解决兼容性问题</li><li>提升性能（减少 DOM 的不必要操作）</li></ul><p>每当我们调用 root.render()时，页面就会发生重新渲染</p><p>React 会通过 diffing 算法，将新的元素和旧的元素进行比较</p><p>通过比较找到发生变化的元素，并且只对变化的元素进行修改，没有发生的变化不予处理。</p><p>比较两次数据时，React 会先比较父元素，父元素如果不同，直接所有元素全部替换。父元素一致，再去逐个比较子元素，直到找到所有发生变化的元素为止。</p><p>在 JSX 中显示数组时，数组中的每一个元素都需要设置一个唯一的 key，否则控制台会报警告。</p><p>重新渲染页面时，React 会按照顺序依次比较对应的元素，当渲染一个列表时如果不指定 key，同样也会按照顺序进行比较。如果列表的顺序永远不会发生变化，不加 key 没有问题。但是如果列表的顺序会发生变化，这可能会导致性能问题。</p><ul><li>尽量用元素的 id 来做 key</li><li>用遍历的 索引 index 来做 key，没有意义，仍然会全部更新</li><li>当元素的顺序不会发生变化时，用索引 index 做 key，没有问题</li></ul>]]></content>
    
    
    <categories>
      
      <category>技术类-React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript的同步与异步</title>
    <link href="/20211214/JavaScript%E7%9A%84%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/"/>
    <url>/20211214/JavaScript%E7%9A%84%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Asynchronous/Introducing">更详细的可以点这里</a></p><h2 id="异步JavaScript"><a href="#异步JavaScript" class="headerlink" title="异步JavaScript"></a><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Asynchronous">异步JavaScript</a></h2><p><strong>异步</strong>指两个或两个以上的对象或事件<strong>不</strong>同时存在或发生（或多个相关事物的发生<strong>无需</strong>等待其前一事物的完成）</p><h2 id="同步JavaScript"><a href="#同步JavaScript" class="headerlink" title="同步JavaScript"></a><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Synchronous">同步JavaScript</a></h2><p>各方都实时（或者尽可能实时）地收取（而且必要的话也处理或者回复）信息的即时沟通方式，即为<strong>同步</strong>。</p><p>电话即为一个日常的例子：人们都倾向于在使用电话时即时地作出回应。</p><p>许多程序指令也是实时的：例如当输入一个算式时，除非编程人员有意为止，否则环境都会立即将结果反馈回来。</p><h2 id="事件队列"><a href="#事件队列" class="headerlink" title="事件队列"></a>事件队列</h2><p>像<code>promise</code>这样的异步操作被放入事件队列中，事件队列在主线程完成处理后运行，这样它们就不会阻止后续JavaScript代码的运行。排队操作将尽快完成，然后将结果返回到JavaScript环境。</p><h2 id="Promises-对比-callbacks"><a href="#Promises-对比-callbacks" class="headerlink" title="Promises 对比 callbacks"></a>Promises 对比 callbacks</h2><p>promises与旧式callbacks有一些相似之处。它们本质上是一个返回的对象，您可以将回调函数附加到该对象上，而不必将回调作为参数传递给另一个函数。</p><p>然而，Promise是专门为异步操作而设计的，与旧式回调相比具有许多优点:</p><ul><li>您可以使用多个then()操作将多个异步操作链接在一起，并将其中一个操作的结果作为输入传递给下一个操作。这种链接方式对回调来说要难得多，会使回调以混乱的“末日金字塔”告终。 (也称为回调地狱)。</li><li>Promise总是严格按照它们放置在事件队列中的顺序调用。</li><li>错误处理要好得多——所有的错误都由块末尾的一个.catch()块处理，而不是在“金字塔”的每一层单独处理。</li></ul><h2 id="异步代码的本质"><a href="#异步代码的本质" class="headerlink" title="异步代码的本质"></a>异步代码的本质</h2><p>让我们研究一个示例，它进一步说明了异步代码的本质，展示了当我们不完全了解代码执行顺序以及将异步代码视为同步代码时可能发生的问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span> (<span class="hljs-string">&#x27;Starting&#x27;</span>);<br><span class="hljs-keyword">let</span> image;<br><br><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;coffee.jpg&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;It worked :)&#x27;</span>)<br>  <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">blob</span>();<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">myBlob</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> objectURL = <span class="hljs-variable constant_">URL</span>.<span class="hljs-title function_">createObjectURL</span>(myBlob);<br>  image = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;img&#x27;</span>);<br>  image.<span class="hljs-property">src</span> = objectURL;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(image);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;There has been a problem with your fetch operation: &#x27;</span> + error.<span class="hljs-property">message</span>);<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span> (<span class="hljs-string">&#x27;All done!&#x27;</span>);<br></code></pre></td></tr></table></figure><p>浏览器将会执行代码，看见第一个<code>console.log()</code> 输出<code>Starting</code> ，然后创建<code>image</code>变量。</p><p>然后，它将移动到下一行并开始执行<code>fetch()</code>块，但是，因为<code>fetch()</code>是异步执行的，没有阻塞，所以在<code>promise</code>相关代码之后程序继续执行，从而到达最后的<code>console.log()</code>语句<code>All done!</code>并将其输出到控制台。</p><p>只有当<code>fetch()</code> 块完成运行返回结果给<code>.then()</code>，我们才最后看到第二个<code>console.log()</code>消息 <code>It worked ;)</code>。所以 这些消息可能以和你预期不同的顺序出现：</p><ul><li>Starting</li><li>All done!</li><li>It worked :)</li></ul><p>如果你感到疑惑，考虑下面这个小例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;registering click handler&quot;</span>);<br><br>button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;get click&quot;</span>);<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;all done&quot;</span>);<br></code></pre></td></tr></table></figure><p>这在行为上非常相似——第一个和第三个<code>console.log()</code>消息将立即显示，但是第二个消息将被阻塞，直到有人单击鼠标按钮。前面的示例以相同的方式工作，只是在这种情况下，第二个消息在<code>promise</code>链上被阻塞，直到获取资源后再显示在屏幕上，而不是单击。</p><p>要查看实际情况，并将第三个<code>console.log()</code>调用更改为以下命令：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span> (<span class="hljs-string">&#x27;All done! &#x27;</span> + image.<span class="hljs-property">src</span> + <span class="hljs-string">&#x27;displayed.&#x27;</span>);<br></code></pre></td></tr></table></figure><p>此时控制台将会报错，而不会显示第三个 console.log 的信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">TypeError</span>: image is <span class="hljs-literal">undefined</span>; can<span class="hljs-string">&#x27;t access its &quot;src&quot; property</span><br></code></pre></td></tr></table></figure><p>这是因为：浏览器运行第三个console.log()的时候，fetch() 语句块还没有完成，因此image还没有赋值。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>JavaScript</code>是一种同步的、阻塞的、单线程的语言，在这种语言中，一次只能执行一个操作。</p><p>但web浏览器定义了函数和API，允许我们当某些事件发生时不是按照同步方式，而是异步地调用函数(比如，时间的推移，用户通过鼠标的交互，或者获取网络数据)。</p><p>这意味着您的代码可以同时做几件事情，而不需要停止或阻塞主线程。</p><h3 id="异步还是同步执行代码，取决于我们要做什么"><a href="#异步还是同步执行代码，取决于我们要做什么" class="headerlink" title="异步还是同步执行代码，取决于我们要做什么"></a>异步还是同步执行代码，取决于我们要做什么</h3><ul><li><p>同步-如果我们希望事情能够立即加载并发生。例如，当将一些用户定义的样式应用到一个页面时，您希望这些样式能够尽快被应用。</p></li><li><p>异步-如果我们正在运行一个需要时间的操作，比如查询数据库并使用结果填充模板，那么最好将该操作从主线程中移开使用异步完成任务。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术类-前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git rebase 用法</title>
    <link href="/20211202/git-rebase-%E7%94%A8%E6%B3%95/"/>
    <url>/20211202/git-rebase-%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p><a href="https://zhuanlan.zhihu.com/p/34197548">参考自此文章</a></p><p>以前提交代码一直是用命令行提交的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-comment">// 一把梭</span><br>git pull<br>git add .<br>git commit -m <span class="hljs-string">&#x27;xxxxxx&#x27;</span><br>git push<br></code></pre></td></tr></table></figure><p>在多人开发项目下，这样提交的话会有如下效果:</p><p><img src="https://upload-images.jianshu.io/upload_images/13931286-3d42d72b334fc7c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/594/format/webp" alt="显示效果"></p><p><img src="https://upload-images.jianshu.io/upload_images/13931286-d0fb965ce204e6f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/222/format/webp" alt="显示效果"></p><p>当很多人都把自己的分支合到主分支的时候，这样会显得主线很乱而且还会有自动生成的提交信息</p><p><strong>所以提倡用<code>git rebase</code></strong></p><h2 id="使用-rebase-和-merge-的基本原则"><a href="#使用-rebase-和-merge-的基本原则" class="headerlink" title="使用 rebase 和 merge 的基本原则"></a>使用 rebase 和 merge 的基本原则</h2><ol><li>下游分支更新上游分支内容的时候使用 rebase</li><li>上游分支合并下游分支内容的时候使用 merge</li><li>更新当前分支的内容时一定要使用 –rebase 参数</li></ol><p>例如现有上游分支 master，基于 master 分支拉出来一个开发分支 dev，在 dev 上开发了一段时间后要把 master 分支提交的新内容更新到 dev 分支，此时切换到 dev 分支，使用 <code>git rebase master</code></p><p>等 dev 分支开发完成了之后，要合并到上游分支 master 上的时候，切换到 master 分支，使用 <code>git merge dev</code></p><h2 id="实际开发中遇到操作"><a href="#实际开发中遇到操作" class="headerlink" title="实际开发中遇到操作"></a>实际开发中遇到操作</h2><p>当你和其他人在同一个分支开发时，在你提交的时候发现有人已经提交了一些东西上去了，你可以这样操作：</p><ol><li><p><code>git pull --rebase</code></p></li><li><p><code>git push</code></p></li></ol><p>你也可以使用vscode上下载的git插件来操作：</p><p><img src="https://upload-images.jianshu.io/upload_images/13931286-ecca9bb5bd96dc14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="vscode操作"></p><p>然后再push上去。</p>]]></content>
    
    
    <categories>
      
      <category>技术类-前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>create-react-app 搭建项目踩坑记录</title>
    <link href="/20211129/create-react-app-%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <url>/20211129/create-react-app-%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="中文说明"><a href="#中文说明" class="headerlink" title="中文说明"></a>中文说明</h1><h2 id="搭建前端开发环境笔记"><a href="#搭建前端开发环境笔记" class="headerlink" title="搭建前端开发环境笔记"></a>搭建前端开发环境笔记</h2><p>由<code>npx create-react-app articles_published_system</code>创建的项目</p><p>后来漏掉了<code>typescript</code>支持，原本可以由命令<code>npx create-react-app articles_published_system --template typescript</code>可以直接创建支持ts的应用</p><p>后续要将ts添加到已有项目中，用以下命令：</p><p><code>npm install --save typescript @types/node @types/react @types/react-dom @types/jest</code></p><p>项目中配置<code>sass</code>:</p><ol><li><p>执行<code>yarn add node-sass</code>下载包（按理说执行<code>npm install node-sass --save</code>也应该有用，但是我这边报错了）。</p><p> 报错如下：</p><p> <img src="https://upload-images.jianshu.io/upload_images/13931286-44bf5ea859ce44fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/672/format/webp" alt="npm安装sass报错"></p><p> 我的vscode和node版本都是最新的</p><p> 建议大家用<code>yarn</code>来安装项目</p><p> <strong>发现启动后sass会报错</strong></p><p> 解决办法：sass指定版本为<code>^1.43.5</code>，postcss-pxtorem为<code>^5.1.1</code>，不要安装node-sass了</p><p> 前端生态配置仍然复杂</p></li><li><p>将样式文件后缀改为<code>.scss</code>并在tsx或者js文件中引入，项目会自动编译。</p></li></ol><p>为了实现自适应，给项目配置postcss-pxtorem</p><ol><li><p>执行<code>yarn add lib-flexible postcss-pxtorem</code></p></li><li><p>在应用入口引入<code>import &#39;lib-flexible&#39;</code></p></li><li><p>执行<code>npm run eject</code>可以打开<code>create-react-app</code>应用的配置文件</p></li><li><p>在<code>config/webpack.config.js</code>文件中配置postcss，位置及方法如下图：</p></li></ol><p><img src="https://upload-images.jianshu.io/upload_images/13931286-da7732a5f0bf175d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="引入postcss"></p><p><img src="https://upload-images.jianshu.io/upload_images/13931286-7f538e5227508fa5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/630/format/webp" alt="配置postcss"></p><p>UI库使用antdesign</p><ol><li><p>安装antd，<code>yarn add antd</code></p></li><li><p>在App.css 中导入样式<code>@import &#39;~antd/dist/antd.css&#39;</code>，然后在组件中引入相应的ui组件就可以用了。</p></li></ol><hr><p>完~</p>]]></content>
    
    
    <categories>
      
      <category>技术类-React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>call,apply和bind</title>
    <link href="/20211021/call-apply%E5%92%8Cbind/"/>
    <url>/20211021/call-apply%E5%92%8Cbind/</url>
    
    <content type="html"><![CDATA[<p><code>call</code>，<code>apply</code>和<code>bind</code>都是用来改变this的指向，但是他们在使用和功能上各有区别。</p><h1 id="call-方法"><a href="#call-方法" class="headerlink" title="call() 方法"></a>call() 方法</h1><h2 id="call-方法的作用"><a href="#call-方法的作用" class="headerlink" title="call() 方法的作用"></a>call() 方法的作用</h2><p>call() 方法的作用：可以<strong>调用</strong>一个函数，与此同时，它还可以改变这个函数内部的 this 指向。</p><p>call() 方法的另一个应用：<strong>可以实现继承</strong>。之所以能实现继承，其实是利用了上面的作用。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">fn1.<span class="hljs-title function_">call</span>(想要将<span class="hljs-variable language_">this</span>指向哪里, 函数实参<span class="hljs-number">1</span>, 函数实参<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>备注：第一个参数中，如果不需要改变 this 指向，则传 null。</p><h2 id="call-方法举例"><a href="#call-方法举例" class="headerlink" title="call() 方法举例"></a>call() 方法举例</h2><p>举例 1、通过 call() 调用函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj1 = &#123;<br>    <span class="hljs-attr">nickName</span>: <span class="hljs-string">&#x27;走花鹿&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">26</span>,<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn1</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">nickName</span>);<br>&#125;<br><br>fn1.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// this的指向并没有被改变，此时相当于 fn1();</span><br></code></pre></td></tr></table></figure><p>上方代码的打印结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span><br><span class="hljs-literal">undefined</span><br></code></pre></td></tr></table></figure><p>上面的代码，跟普通的函数调用 <code>fn1()</code> 没有区别。</p><p>举例 2、通过 call() 改变 this 指向：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj1 = &#123;<br>    <span class="hljs-attr">nickName</span>: <span class="hljs-string">&#x27;走花鹿&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">26</span>,<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn1</span>(<span class="hljs-params">a, b</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">nickName</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a + b);<br>&#125;<br><br>fn1.<span class="hljs-title function_">call</span>(obj1, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// 先将 this 指向 obj1，然后执行 fn1() 函数</span><br></code></pre></td></tr></table></figure><p>上方代码的打印结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">obj1<br>走花鹿<br><span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>举例 3、通过 call() 实现继承：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 给 Father 增加 name 和 age 属性</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Father</span>(<span class="hljs-params">myName, myAge</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = myName;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = myAge;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Son</span>(<span class="hljs-params">myName, myAge</span>) &#123;<br>    <span class="hljs-comment">// 【下面这一行，重要代码】</span><br>    <span class="hljs-comment">// 通过这一步，将 father 里面的 this 修改为 Son 里面的 this；另外，给 Son 加上相应的参数，让 Son 自动拥有 Father 里的属性。最终实现继承</span><br>    <span class="hljs-title class_">Father</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, myName, myAge);<br>&#125;<br><br><span class="hljs-keyword">const</span> son1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>(<span class="hljs-string">&#x27;走花鹿&#x27;</span>, <span class="hljs-number">26</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(son1));<br></code></pre></td></tr></table></figure><p>上方代码中，通过 call() 方法，让 Son 继承了 Father 里面的 name 和 age 属性。</p><p>打印结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;myName&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;走花鹿&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;myAge&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">26</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h1 id="apply-方法"><a href="#apply-方法" class="headerlink" title="apply() 方法"></a>apply() 方法</h1><h2 id="apply-方法的作用"><a href="#apply-方法的作用" class="headerlink" title="apply() 方法的作用"></a>apply() 方法的作用</h2><p>apply() 方法的作用：可以<strong>调用</strong>一个函数，与此同时，它还可以改变这个函数内部的 this 指向。这一点，和 call()类似。</p><p>apply() 方法的应用： 由于 apply()需要传递数组，所以它有一些巧妙应用，稍后看接下来的应用举例就知道了。</p><h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">fn1.<span class="hljs-title function_">apply</span>(想要将<span class="hljs-variable language_">this</span>指向哪里, [函数实参<span class="hljs-number">1</span>, 函数实参<span class="hljs-number">2</span>]);<br></code></pre></td></tr></table></figure><p>备注：第一个参数中，如果不需要改变 this 指向，则传 null。</p><p>到这里可以看出， <strong>call() 和 apply() 方法的作用是相同的。唯一的区别在于，apply() 里面传入的实参，必须是数组（或者维数组）。</strong></p><h2 id="apply-方法举例"><a href="#apply-方法举例" class="headerlink" title="apply() 方法举例"></a>apply() 方法举例</h2><p>举例、通过 apply() 改变 this 指向：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj1 = &#123;<br>    <span class="hljs-attr">nickName</span>: <span class="hljs-string">&#x27;走花鹿&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">26</span>,<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn1</span>(<span class="hljs-params">a</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">nickName</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<br>&#125;<br><br>fn1.<span class="hljs-title function_">apply</span>(obj1, [<span class="hljs-string">&#x27;hello&#x27;</span>]); <span class="hljs-comment">// 先将 this 指向 obj1，然后执行 fn1() 函数</span><br></code></pre></td></tr></table></figure><p>注意，上方代码中，call() 里面传实参时，需要以数组的形式。即便是传一个实参，也需要传数组。</p><p>打印结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">obj1<br>走花鹿<br>hello<br></code></pre></td></tr></table></figure><h2 id="apply-方法的巧妙应用：求数组的最大值"><a href="#apply-方法的巧妙应用：求数组的最大值" class="headerlink" title="apply() 方法的巧妙应用：求数组的最大值"></a>apply() 方法的巧妙应用：求数组的最大值</h2><p>我们知道，如果想要求数组中元素的最大值的时候，数组本身是没有自带方法的。那怎么办呢？</p><p>虽然数组里没有获取最大值的方法，但是数值里面有 <code>Math.max(数字1，数字2，数字3)</code> 方法，可以获取多个数值中的最大值。 另外，由于<br>apply() 方法在传递实参时，必须要以数组的形式，所以我们可以 通过 Math.max() 和 apply() 曲线救国。</p><p>举例：求数组中多个元素的最大值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">10</span>, <span class="hljs-number">8</span>];<br><br><span class="hljs-comment">// 下面这一行代码的目的，无需改变 this 指向，所以：第一个参数填 null，或者填 Math，或者填 this 都可以。严格模式中，不让填null。</span><br><span class="hljs-keyword">const</span> maxValue = <span class="hljs-title class_">Math</span>.<span class="hljs-property">max</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-title class_">Math</span>, arr1); <span class="hljs-comment">// 求数组 arr1 中元素的最大值</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(maxValue);<br><br><span class="hljs-keyword">const</span> minValue = <span class="hljs-title class_">Math</span>.<span class="hljs-property">min</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-title class_">Math</span>, arr1); <span class="hljs-comment">// 求数组 arr1 中元素的最小值</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(minValue);<br></code></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">10</span><br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h1 id="bind-方法"><a href="#bind-方法" class="headerlink" title="bind() 方法"></a>bind() 方法</h1><h2 id="bind-方法的作用"><a href="#bind-方法的作用" class="headerlink" title="bind() 方法的作用"></a>bind() 方法的作用</h2><p>bind() 方法<strong>不会调用函数</strong>，但是可以改变函数内部的 this 指向。</p><p>把call()、apply()、bind()这三个方法做一下对比，你会发现：实际开发中， bind()<br>方法使用得最为频繁。如果有些函数，我们不需要立即调用，但是又想改变这个函数内部的this指向，此时用 bind() 是最为合适的。</p><p>语法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">新函数 = fn1.<span class="hljs-title function_">bind</span>(想要将<span class="hljs-variable language_">this</span>指向哪里, 函数实参<span class="hljs-number">1</span>, 函数实参<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>参数：</p><ul><li><p>第一个参数：在 fn1 函数运行时，指定 fn1 函数的this 指向。如果不需要改变 this 指向，则传 null。</p></li><li><p>其他参数：fn1 函数的实参。</p></li></ul><p>解释：它不会调用 fn1 函数，但会返回 由指定this 和指定实参的原函数拷贝。可以看出， bind() 方法是有返回值的。</p>]]></content>
    
    
    <categories>
      
      <category>技术类-前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Array数组的一些发现</title>
    <link href="/20211020/Array%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8F%91%E7%8E%B0/"/>
    <url>/20211020/Array%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8F%91%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>今天对一些元素都是纯数字的数组做<code>forEach</code>遍历操作，发现无法改变原数组，查找了一些资料发现，<code>forEach</code>只能处理数组中的引用类型，元素为基础类型的需要另外的写法。如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><span class="hljs-keyword">let</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><span class="hljs-keyword">let</span> arr2 = [&#123;<span class="hljs-attr">a</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">b</span>:<span class="hljs-number">2</span>&#125;]<br><br><span class="hljs-comment">// 元素为基础类型number，原数组不变</span><br>arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>    item += <span class="hljs-number">1</span><br>&#125;)<br><br><span class="hljs-comment">// 这种写法可行</span><br>arr1.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;<br>    arr1[index] += <span class="hljs-number">1</span><br>&#125;)<br><br><span class="hljs-comment">// 元素为引用类型的，原数组会改变</span><br>arr2.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>    item.<span class="hljs-property">a</span> = <span class="hljs-number">66</span><br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr1);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr2);<br></code></pre></td></tr></table></figure><p>这主要是和计算机的堆栈有关。基础类型是存储在栈中，<code>forEach</code>中得到item也是存储于栈中，所以它就和数组中的元素毫无关系了；而对象是存储于堆中，遍历的时候item虽然在栈中但是它的指针会指向堆中的位置，所以可以直接修改原数组。</p>]]></content>
    
    
    <categories>
      
      <category>技术类-前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript事件循环</title>
    <link href="/20211014/JavaScript%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    <url>/20211014/JavaScript%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>这一篇讲的也特别清楚，建议看看：<a href="https://juejin.cn/post/6844903512845860872">这一次，彻底弄懂 JavaScript 执行机制</a></p><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p><code>JavaScript</code> 在设计之初便是单线程，即指程序运行时，只有一个线程存在，同一时间只能做一件事</p><p>为什么要这么设计，跟<code>JavaScript</code>的应用场景有关</p><p><code>JavaScript</code> 初期作为一门浏览器脚本语言，通常用于操作 <code>DOM</code> ，如果是多线程，一个线程进行了删除 <code>DOM</code> ，另一个添加 <code>DOM</code>，此时浏览器该如何处理？</p><p>为了解决单线程运行阻塞问题，<code>JavaScript</code>用到了计算机系统的一种运行机制，这种机制就叫做事件循环（Event Loop）</p><h4 id="事件循环（Event-Loop）"><a href="#事件循环（Event-Loop）" class="headerlink" title="事件循环（Event Loop）"></a>事件循环（Event Loop）</h4><p>在<code>JavaScript</code>中，所有的任务都可以分为</p><ul><li>同步任务：立即执行的任务，同步任务一般会直接进入到主线程中执行</li><li>异步任务：异步执行的任务，比如<code>ajax</code>网络请求，<code>setTimeout</code>定时函数等</li></ul><p>同步任务与异步任务的运行流程图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/13931286-a4cefb0d8aa74774?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>从上面我们可以看到，同步任务进入主线程，即主执行栈，异步任务进入任务队列，主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行。上述过程的不断重复就是事件循环</p><h2 id="二、宏任务与微任务"><a href="#二、宏任务与微任务" class="headerlink" title="二、宏任务与微任务"></a>二、宏任务与微任务</h2><p>如果将任务划分为同步任务和异步任务并不是那么的准确，举个例子：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>)<br><br>setTimeout(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>)<br>&#125;, <span class="hljs-number">0</span>)<br><br><span class="hljs-keyword">new</span> Promise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;new Promise&#x27;</span>)<br>    resolve()<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;then&#x27;</span>)<br>&#125;)<br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>如果按照上面流程图来分析代码，我们会得到下面的执行步骤：</p><ul><li><code>console.log(1)</code>，同步任务，主线程中执行</li><li><code>setTimeout()</code> ，异步任务，放到 <code>Event Table</code>，0 毫秒后<code>console.log(2)</code>回调推入 <code>Event Queue</code> 中</li><li><code>new Promise</code> ，同步任务，主线程直接执行</li><li><code>.then</code> ，异步任务，放到 <code>Event Table</code></li><li><code>console.log(3)</code>，同步任务，主线程执行</li></ul><p>所以按照分析，它的结果应该是 <code>1</code> =&gt; <code>&#39;new Promise&#39;</code> =&gt; <code>3</code> =&gt; <code>2</code> =&gt; <code>&#39;then&#39;</code></p><p>但是实际结果是：<code>1</code>=&gt;<code>&#39;new Promise&#39;</code>=&gt; <code>3</code> =&gt; <code>&#39;then&#39;</code> =&gt; <code>2</code></p><p>出现分歧的原因在于异步任务执行顺序，事件队列其实是一个“先进先出”的数据结构，排在前面的事件会优先被主线程读取</p><p>例子中 <code>setTimeout</code>回调事件是先进入队列中的，按理说应该先于 <code>.then</code> 中的执行，但是结果却偏偏相反</p><p>原因在于异步任务还可以细分为微任务与宏任务</p><h3 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h3><p>一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前</p><p>常见的微任务有：</p><ul><li>Promise.then</li><li>MutaionObserver</li><li>Object.observe（已废弃；Proxy 对象替代）</li><li>process.nextTick（Node.js）</li></ul><h3 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h3><p>宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合</p><p>常见的宏任务有：</p><ul><li>script (可以理解为外层同步代码)</li><li>setTimeout/setInterval</li><li>UI rendering/UI事件</li><li>postMessage、MessageChannel</li><li>setImmediate、I/O（Node.js）</li></ul><p>这时候，事件循环，宏任务，微任务的关系如图所示</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/gH31uF9VIibSNwS2EBDtHnxMysjAib2yvIh75NUHZic4J4n5mPSe5jcMcWtsO0LuhRDuqdHVWicqejmPAI8NLLjuKw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>按照这个流程，它的执行机制是：</p><ul><li>执行一个宏任务，如果遇到微任务就将它放到微任务的事件队列中</li><li>当前宏任务执行完成后，会查看微任务的事件队列，然后将里面的所有微任务依次执行完</li></ul><p>回到上面的题目</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>)<br>setTimeout(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>)<br>&#125;, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">new</span> Promise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;new Promise&#x27;</span>)<br>    resolve()<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;then&#x27;</span>)<br>&#125;)<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>流程如下</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 遇到 console.log(<span class="hljs-number">1</span>) ，直接打印 <span class="hljs-number">1</span><br><span class="hljs-regexp">//</span> 遇到定时器，属于新的宏任务，留着后面执行<br><span class="hljs-regexp">//</span> 遇到 new Promise，这个是直接执行的，打印 <span class="hljs-string">&#x27;new Promise&#x27;</span><br><span class="hljs-regexp">//</span> .then 属于微任务，放入微任务队列，后面再执行<br><span class="hljs-regexp">//</span> 遇到 console.log(<span class="hljs-number">3</span>) 直接打印 <span class="hljs-number">3</span><br><span class="hljs-regexp">//</span> 好了本轮宏任务执行完毕，现在去微任务列表查看是否有微任务，发现 .then 的回调，执行它，打印 <span class="hljs-string">&#x27;then&#x27;</span><br><span class="hljs-regexp">//</span> 当一次宏任务执行完，再去执行新的宏任务，这里就剩一个定时器的宏任务了，执行它，打印 <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="三、async与await"><a href="#三、async与await" class="headerlink" title="三、async与await"></a>三、async与await</h2><p><code>async</code> 是异步的意思，<code>await</code>则可以理解为等待</p><p>放到一起可以理解<code>async</code>就是用来声明一个异步方法，而 <code>await</code>是用来等待异步方法执行</p><h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><p><code>async</code>函数返回一个<code>promise</code>对象，下面两种方法是等效的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;TEST&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">// asyncF is equivalent to f!</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncF</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;TEST&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="await"><a href="#await" class="headerlink" title="await"></a>await</h3><p>正常情况下，<code>await</code>命令后面是一个 <code>Promise</code>对象，返回该对象的结果。如果不是 <code>Promise</code>对象，就直接返回对应的值</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade">async <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-comment">// 等同于</span><br>    <span class="hljs-comment">// return 123</span><br>    <span class="hljs-keyword">return</span> await <span class="hljs-number">123</span><br>&#125;<br>f().then(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(v)) <span class="hljs-comment">// 123</span><br></code></pre></td></tr></table></figure><p>不管<code>await</code>后面跟着的是什么，<code>await</code>都会阻塞后面的代码</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arcade">async <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn1</span> (<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>)<br>    await fn2()<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">// 阻塞</span><br>&#125;<br><br>async <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn2</span> (<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;fn2&#x27;</span>)<br>&#125;<br><br>fn1()<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>上面的例子中，<code>await</code> 会阻塞下面的代码（即加入微任务队列），先执行 <code>async</code>外面的同步代码，同步代码执行完，再回到 <code>async</code> 函数中，再执行之前阻塞的代码</p><p>所以上述输出结果为：<code>1</code>，<code>fn2</code>，<code>3</code>，<code>2</code></p><h2 id="四、流程分析"><a href="#四、流程分析" class="headerlink" title="四、流程分析"></a>四、流程分析</h2><p>通过对上面的了解，我们对<code>JavaScript</code>对各种场景的执行顺序有了大致的了解</p><p>这里直接上代码：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs arcade">async <span class="hljs-keyword">function</span> <span class="hljs-title function_">async1</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;async1 start&#x27;</span>)<br>    await async2()<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;async1 end&#x27;</span>)<br>&#125;<br>async <span class="hljs-keyword">function</span> <span class="hljs-title function_">async2</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;async2&#x27;</span>)<br>&#125;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;script start&#x27;</span>)<br>setTimeout(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;settimeout&#x27;</span>)<br>&#125;)<br>async1()<br><span class="hljs-keyword">new</span> Promise(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;promise1&#x27;</span>)<br>    resolve()<br>&#125;).then(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;promise2&#x27;</span>)<br>&#125;)<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>)<br></code></pre></td></tr></table></figure><p>分析过程：</p><ol><li>执行整段代码，遇到 <code>console.log(&#39;script start&#39;)</code> 直接打印结果，输出 <code>script start</code></li><li>遇到定时器了，它是宏任务，先放着不执行</li><li>遇到 <code>async1()</code>，执行 <code>async1</code> 函数，先打印 <code>async1 start</code>，下面遇到<code>await</code>怎么办？先执行 <code>async2</code>，打印 <code>async2</code>，然后阻塞下面代码（即加入微任务列表），跳出去执行同步代码</li><li>跳到 <code>new Promise</code> 这里，直接执行，打印 <code>promise1</code>，下面遇到 <code>.then()</code>，它是微任务，放到微任务列表等待执行</li><li>最后一行直接打印 <code>script end</code>，现在同步代码执行完了，开始执行微任务，即 <code>await</code>下面的代码，打印 <code>async1 end</code></li><li>继续执行下一个微任务，即执行 <code>then</code> 的回调，打印 <code>promise2</code></li><li>上一个宏任务所有事都做完了，开始下一个宏任务，就是定时器，打印 <code>settimeout</code></li></ol><p>所以最后的结果是：<code>script start</code>、<code>async1 start</code>、<code>async2</code>、<code>promise1</code>、<code>script end</code>、<code>async1 end</code>、<code>promise2</code>、<code>settimeout</code></p>]]></content>
    
    
    <categories>
      
      <category>技术类-前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解javascript之typeof和instanceof</title>
    <link href="/20211013/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript%E4%B9%8Btypeof%E5%92%8Cinstanceof/"/>
    <url>/20211013/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript%E4%B9%8Btypeof%E5%92%8Cinstanceof/</url>
    
    <content type="html"><![CDATA[<h1 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h1><p>typeof方法<strong>返回一个字符串</strong>，来表示<strong>数据的类型</strong>。</p><p>各个数据类型对应typeof的值：</p><table><thead><tr><th><strong>数据类型</strong></th><th><strong>Type</strong></th></tr></thead><tbody><tr><td>Undefined</td><td>“undefined”</td></tr><tr><td>Null</td><td>“object”</td></tr><tr><td>Boolean</td><td>“boolean”</td></tr><tr><td>Number</td><td>“number”</td></tr><tr><td>String</td><td>“string”</td></tr><tr><td>Symbol</td><td>“symbol”</td></tr><tr><td>宿主对象(JS环境提供的，比如浏览器)</td><td>Implementation-dependent</td></tr><tr><td>函数对象Function</td><td>“function”</td></tr><tr><td>任何其他对象Object</td><td>“object”</td></tr></tbody></table><p>下面是代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// Numbers</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-number">37</span> === <span class="hljs-string">&#x27;number&#x27;</span>;<br><span class="hljs-keyword">typeof</span> <span class="hljs-number">3.14</span> === <span class="hljs-string">&#x27;number&#x27;</span>;<br><span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Math</span>.<span class="hljs-property">LN2</span> === <span class="hljs-string">&#x27;number&#x27;</span>;<br><span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Infinity</span> === <span class="hljs-string">&#x27;number&#x27;</span>;<br><span class="hljs-keyword">typeof</span> <span class="hljs-title class_">NaN</span> === <span class="hljs-string">&#x27;number&#x27;</span>; <span class="hljs-comment">// 尽管NaN是&quot;Not-A-Number&quot;的缩写,意思是&quot;不是一个数字&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Number</span>(<span class="hljs-number">1</span>) === <span class="hljs-string">&#x27;number&#x27;</span>; <span class="hljs-comment">// 不要这样使用!</span><br><br><span class="hljs-comment">// Strings</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-string">&quot;&quot;</span> === <span class="hljs-string">&#x27;string&#x27;</span>;<br><span class="hljs-keyword">typeof</span> <span class="hljs-string">&quot;bla&quot;</span> === <span class="hljs-string">&#x27;string&#x27;</span>;<br><span class="hljs-title function_">typeof</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-number">1</span>) === <span class="hljs-string">&#x27;string&#x27;</span>; <span class="hljs-comment">// typeof返回的肯定是一个字符串</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;abc&quot;</span>) === <span class="hljs-string">&#x27;string&#x27;</span>; <span class="hljs-comment">// 不要这样使用!</span><br><br><span class="hljs-comment">// Booleans</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">true</span> === <span class="hljs-string">&#x27;boolean&#x27;</span>;<br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">false</span> === <span class="hljs-string">&#x27;boolean&#x27;</span>;<br><span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Boolean</span>(<span class="hljs-literal">true</span>) === <span class="hljs-string">&#x27;boolean&#x27;</span>; <span class="hljs-comment">// 不要这样使用!</span><br><br><span class="hljs-comment">// Symbols</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Symbol</span>() === <span class="hljs-string">&#x27;symbol&#x27;</span>;<br><span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;foo&#x27;</span>) === <span class="hljs-string">&#x27;symbol&#x27;</span>;<br><span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span> === <span class="hljs-string">&#x27;symbol&#x27;</span>;<br><br><span class="hljs-comment">// Undefined</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span> === <span class="hljs-string">&#x27;undefined&#x27;</span>;<br><span class="hljs-keyword">typeof</span> blabla === <span class="hljs-string">&#x27;undefined&#x27;</span>; <span class="hljs-comment">// 一个未定义的变量,或者一个定义了却未赋初值的变量</span><br><br><span class="hljs-comment">// Objects</span><br><span class="hljs-keyword">typeof</span> &#123;<span class="hljs-attr">a</span>:<span class="hljs-number">1</span>&#125; === <span class="hljs-string">&#x27;object&#x27;</span>;<br><br><span class="hljs-comment">// 使用Array.isArray或者Object.prototype.toString.call方法可以从基本的对象中区分出数组类型</span><br><span class="hljs-keyword">typeof</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>] === <span class="hljs-string">&#x27;object&#x27;</span>;<br><br><span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() === <span class="hljs-string">&#x27;object&#x27;</span>;<br><br><span class="hljs-comment">// 下面的容易令人迷惑，不要这样使用！</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Boolean</span>(<span class="hljs-literal">true</span>) === <span class="hljs-string">&#x27;object&#x27;</span>;<br><span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>(<span class="hljs-number">1</span>) ==== <span class="hljs-string">&#x27;object&#x27;</span>;<br><span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;abc&quot;</span>) === <span class="hljs-string">&#x27;object&#x27;</span>;<br><br><span class="hljs-comment">// 函数</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125; === <span class="hljs-string">&#x27;function&#x27;</span>;<br><span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Math</span>.<span class="hljs-property">sin</span> === <span class="hljs-string">&#x27;function&#x27;</span>;<br></code></pre></td></tr></table></figure><p>发现typeof来判断数据类型其实并不准确。比如数组、正则、日期、对象hj的typeof返回值都是object</p><h1 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h1><p>instanceof运算符可以用来判断某个构造函数的prototype属性<strong>是否存在于另外一个</strong>要检测对象<strong>的原型链上</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 定义构造函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">C</span>(<span class="hljs-params"></span>)&#123;&#125; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">D</span>(<span class="hljs-params"></span>)&#123;&#125; <br><br><span class="hljs-keyword">var</span> o = <span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>();<br><br><span class="hljs-comment">// true，因为 Object.getPrototypeOf(o) === C.prototype</span><br>o <span class="hljs-keyword">instanceof</span> C; <br><br><span class="hljs-comment">// false，因为 D.prototype不在o的原型链上</span><br>o <span class="hljs-keyword">instanceof</span> D; <br><br>o <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>; <span class="hljs-comment">// true,因为Object.prototype.isPrototypeOf(o)返回true</span><br>C.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span> <span class="hljs-comment">// true,同上</span><br><br>C.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;&#125;;<br><span class="hljs-keyword">var</span> o2 = <span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>();<br><br>o2 <span class="hljs-keyword">instanceof</span> C; <span class="hljs-comment">// true</span><br><br>o <span class="hljs-keyword">instanceof</span> C; <span class="hljs-comment">// false,C.prototype指向了一个空对象,这个空对象不在o的原型链上.</span><br><br>D.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>(); <span class="hljs-comment">// 继承</span><br><span class="hljs-keyword">var</span> o3 = <span class="hljs-keyword">new</span> <span class="hljs-title function_">D</span>();<br>o3 <span class="hljs-keyword">instanceof</span> D; <span class="hljs-comment">// true</span><br>o3 <span class="hljs-keyword">instanceof</span> C; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术类-前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>互联网是如何运作的</title>
    <link href="/20211007/%E4%BA%92%E8%81%94%E7%BD%91%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E4%BD%9C%E7%9A%84/"/>
    <url>/20211007/%E4%BA%92%E8%81%94%E7%BD%91%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E4%BD%9C%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://web.stanford.edu/class/msande91si/www-spr04/readings/week1/InternetWhitepaper.htm">互联网是如何运作的</a></p><p>以下是我的总结,更好的学习建议阅读原文。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>互联网所有的传输都通过TCP/IP协议族来传输，TCP/IP是<strong>面向连接</strong>的<strong>可靠</strong>字节流服务协议</p><h1 id="TCP-IP协议栈"><a href="#TCP-IP协议栈" class="headerlink" title="TCP/IP协议栈"></a>TCP/IP协议栈</h1><p>您的计算机已连接到 Internet 并具有唯一的地址。它如何与连接到 Internet 的其他计算机“交谈”？</p><p>这里应该有一个例子：假设您的 IP 地址是 1.2.3.4，并且您想向计算机 5.6.7.8 发送一条消息。您要发送的消息是“Hello computer 5.6.7.8!”。显然，消息必须通过将您的计算机连接到 Internet 的任何类型的线路传输。假设您已从家里拨入您的 ISP，并且消息必须通过电话线传输。必须将消息从字母文本翻译成电子信号，通过互联网传输，然后再翻译回字母文本。 这是如何实现的？<br><strong>通过使用协议栈</strong>。每台计算机都需要一台在 Internet 上进行通信，它通常内置于计算机的操作系统（即 Windows、Unix 等）中。由于使用了两种主要的通信协议，Internet 上使用的协议栈被称为 <strong>TCP/IP 协议栈</strong>。TCP/IP 堆栈如下所示：</p><ul><li>应用层：提供特定于应用程序的协议  HTTP   FTP   IMAP(邮件)</li><li>网络控制层(TCP)：发送数据包到计算机上使用特定的端口号的应用程序</li><li>网络层(IP)：使用IP地址将数据包发送到特定的计算</li><li>链路层：将二进制数据包与网络信号相互之间转换（例如以太网网卡、电话线调制解调器等）</li></ul><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>HTTP 是 Web 浏览器和 Web 服务器用于通过 Internet 相互通信的协议。它是一种应用程序级协议，因为它位于协议栈中 TCP 层的顶部，并被特定应用程序用于相互通信。在这种情况下，应用程序是 Web 浏览器和 Web 服务器。</p><p>HTTP是一种基于无连接文本的协议。客户端（Web 浏览器）向 Web 服务器发送对 Web 元素（例如网页和图像）的请求。请求被服务器服务后，客户端和服务器之间通过 Internet 的连接断开。必须为每个请求建立一个新连接。大多数协议都是面向连接的。这意味着相互通信的两台计算机通过 Internet 保持连接打开。然而，HTTP 没有。在客户端发出 HTTP 请求之前，必须建立到服务器的新连接。</p><p>当您在 Web 浏览器中键入 URL 时，会发生以下情况：</p><ol><li>如果 URL 包含域名，则浏览器首先连接到域名服务器并为 Web 服务器检索相应的 IP 地址。</li><li>Web 浏览器连接到 Web 服务器并为所需的网页发送 HTTP 请求（通过协议栈）。</li><li>Web 服务器接收请求并检查所需页面。如果页面存在，则 Web 服务器发送它。如果服务器找不到请求的页面，它将发送 HTTP 404 错误消息。（404 的意思是“找不到页面”，任何浏览过网络的人都可能知道。）</li><li>Web 浏览器接收回页面并关闭连接。</li><li>然后浏览器解析页面并查找完成网页所需的其他页面元素。这些通常包括图像、小程序等。</li><li>对于每个需要的元素，浏览器会为每个元素向服务器发出额外的连接和 HTTP 请求。</li><li>当浏览器加载完所有图像、小程序等后，页面将完全加载到浏览器窗口中。</li></ol><h1 id="TCP（传输控制协议）"><a href="#TCP（传输控制协议）" class="headerlink" title="TCP（传输控制协议）"></a>TCP（传输控制协议）</h1><p>在协议栈的应用层之下是TCP层。当应用程序打开与 Internet 上另一台计算机的连接时，它们发送的消息（使用特定的应用程序层协议）会沿堆栈向下传递到 TCP 层。<strong>TCP 负责将应用程序协议路由到目标计算机上的正确应用程序。</strong> 为此，使用端口号。端口可以​​被认为是每台计算机上的独立通道。例如，您可以在阅读电子邮件时上网。这是因为这两个应用程序（Web 浏览器和邮件客户端）使用了不同的端口号。当数据包到达计算机并沿协议栈向上时，TCP 层根据端口号决定哪个应用程序接收数据包。<br>TCP 是这样工作的：</p><ul><li>当 TCP 层从上面接收到应用层协议数据时，它会将其分段为可管理的“块”，然后将带有特定 TCP 信息的 TCP 标头添加到每个“块”。TCP 头中包含的信息包括数据需要发送到的应用程序的端口号。</li><li>当 TCP 层接收到来自其下方 IP 层的数据包时，TCP 层会从数据包中剥离 TCP 头数据，必要时进行一些数据重构，然后使用从 TCP 获取的端口号将数据发送到正确的应用程序标题。</li></ul><p>这就是 TCP 将通过协议栈移动的数据路由到正确应用程序的方式。</p><p>TCP 不是文本协议。<strong>TCP 是面向连接的、可靠的字节流服务。</strong>面向连接意味着两个使用 TCP 的应用程序在交换数据之前必须先建立连接。TCP 是可靠的，因为对于收到的每个数据包，都会向发送方发送确认以确认交付。TCP 还在其标头中包含一个校验和，用于对接收到的数据进行错误检查。<br>tcp在建立连接会进行三次握手，每个收到的数据包都会向发送方发送ack确认，已确保发送成功</p><h1 id="IP（互联网协议）"><a href="#IP（互联网协议）" class="headerlink" title="IP（互联网协议）"></a>IP（互联网协议）</h1><p>与 TCP 不同，<strong>IP 是一种不可靠的无连接协议。</strong>IP 不关心数据包是否到达目的地。IP 也不知道连接和端口号。 IP 的工作也是将数据包发送和路由到其他计算机。IP 数据包是独立的实体，可能无序到达或根本没有到达。TCP 的工作是确保数据包到达并以正确的顺序。IP 与 TCP 的唯一共同点是它接收数据并将其自己的 IP 标头信息添加到 TCP 数据。</p><p>IP是不可靠的无连接协议，它并不关心数据包是否到达目的地，也不关系连接和端口号，目的是连接到目标IP</p><p>Ip是一种协议  有两种标准  IPv4 2^32次方和IPv6  2^128</p><h1 id="TCP传输的质量和顺序"><a href="#TCP传输的质量和顺序" class="headerlink" title="TCP传输的质量和顺序"></a>TCP传输的质量和顺序</h1><p>当数据包过大，在网络层会进行分包，分包后传输的链路不一样，到达的时间不一样，TCP会根据数据包上携带序列号来进行排序重组，如果发送方在一个特定时间内（也就是重试时间）没有接受到接收方的ack确认，会再次重新发送</p><p>#网络传输</p><ol><li>个人电脑</li><li>猫（调制解调器）</li><li>local ISP   互联网服务提供商</li><li>regional ISP   经过多个主干网络</li><li>NSP   网络服务提供商  大型网络  卖带宽给ISP</li><li>NAP   每个NSP连接到至少三个网络访问点</li><li>ISP  NSP 所有网络提供都携带路由器，每个路由有当前子网络ip的路由表，当底层向上层发送数据时候，找不到会依次向上找，可能由一个主干网络跳到另外一个主干网络。</li></ol><h1 id="DNS服务"><a href="#DNS服务" class="headerlink" title="DNS服务"></a>DNS服务</h1><p>存在意义是IP别名，不让公司丢客户，也容易记，DNS是一个分布式数据库，存储了域名和IP的对应关系</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日常-最爱的电影</title>
    <link href="/20210925/%E6%B5%AE%E7%94%9F%E4%B8%80%E6%97%A5-%E6%9C%80%E7%88%B1%E7%9A%84%E7%94%B5%E5%BD%B1/"/>
    <url>/20210925/%E6%B5%AE%E7%94%9F%E4%B8%80%E6%97%A5-%E6%9C%80%E7%88%B1%E7%9A%84%E7%94%B5%E5%BD%B1/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p><img src="https://img9.doubanio.com/view/photo/l/public/p2220184425.webp" alt="第六感海报"><br>今天重温了电影《第六感》，一部披着灵异外皮的心灵治愈电影。</p><p>有些电影无论第几遍看还是让人感动<br><img src="https://img2.doubanio.com/view/photo/l/public/p2351243392.webp" alt="第六感剧照"><br><img src="https://img1.doubanio.com/view/photo/l/public/p2356175109.webp" alt="第六感剧照"></p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈与队列的理解以及应用场景</title>
    <link href="/20210923/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%9A%84%E7%90%86%E8%A7%A3%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <url>/20210923/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%9A%84%E7%90%86%E8%A7%A3%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="1-栈"><a href="#1-栈" class="headerlink" title="1.栈"></a>1.栈</h1><p><strong>栈（stack）</strong>又名堆栈，它是一种运算受限的线性表，<strong>限定仅在表尾进行插入和删除操作的线性表</strong>。</p><p>表尾这一端被称为栈顶，相反地另一端被称为栈底，向栈顶插入元素被称为进栈、入栈、压栈，从栈顶删除元素又称作出栈</p><p>所以其按照<strong>先进后出</strong>的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据，具有记忆作用</p><p>实现一个栈：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span> = [];<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 添加一个（或几个）新元素到栈顶</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; element 新元素</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title function_">push</span>(<span class="hljs-params">element</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-title function_">push</span>(element);<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 移除栈顶的元素，同时返回被移除的元素</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title function_">pop</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-title function_">pop</span>();<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 返回栈顶的元素，不对栈做任何修改（这个方法不会移除栈顶的元素，仅仅返回它）</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title function_">peek</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 如果栈里没有任何元素就返回true,否则返回false</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title function_">isEmpty</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 移除栈里的所有元素</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title function_">clear</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span> = [];<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 返回栈里的元素个数。这个方法和数组的length属性很类似</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title function_">size</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-property">length</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关于栈的操作主要的方法如下：</p><ul><li>push：入栈操作</li><li>pop：出栈操作</li></ul><h1 id="二-队列"><a href="#二-队列" class="headerlink" title="二.队列"></a>二.队列</h1><p>跟栈十分相似，队列是一种特殊的线性表，特殊之处在于<strong>它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作</strong>。</p><p>进行插入操作的端称为队尾，进行删除操作的端称为队头，当队列中没有元素时，称为空队列</p><p>在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为<strong>先进先出</strong></p><p>简单实现一个队列，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Queue</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span> = [];<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">frontIndex</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tailIndex</span> = <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-title function_">enqueue</span>(<span class="hljs-params">item</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">tailIndex</span>++] = item;<br>  &#125;<br>  <span class="hljs-title function_">unqueue</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> item = <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">frontIndex</span>];<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">frontIndex</span>++;<br>    <span class="hljs-keyword">return</span> item;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="三-应用场景"><a href="#三-应用场景" class="headerlink" title="三.应用场景"></a>三.应用场景</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>借助栈的先进后出的特性，可以简单实现一个逆序输出的功能，首先把所有元素依次入栈，然后把所有元素出栈并输出</p><p>包括编译器的在对输入的语法进行分析的时候，例如”()”、”{}”、”[]”这些成对出现的符号，借助栈的特性，凡是遇到括号的前半部分，即把这个元素入栈，凡是遇到括号的后半部分就比对栈顶元素是否该元素相匹配，如果匹配，则前半部分出栈，否则就是匹配出错</p><p>包括函数调用和递归的时候，每调用一个函数，底层都会进行入栈操作，出栈则返回函数的返回值</p><p>生活中的例子，可以把乒乓球盒比喻成一个堆栈，球一个一个放进去（入栈），最先放进去的要等其后面的全部拿出来后才能出来（出栈），这种就是典型的先进后出模型</p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>当我们需要按照一定的顺序来处理数据，而该数据的数据量在不断地变化的时候，则需要队列来帮助解题</p><p>队列的使用广泛应用在广度优先搜索中，例如层次遍历一个二叉树的节点值</p><p>生活中的例子，排队买票，排在队头的永远先处理，后面的必须等到前面的全部处理完毕再进行处理，这也是典型的先进先出模型</p><p>参考文献</p><ul><li><a href="https://baike.baidu.com/item/%E6%A0%88/12808149">https://baike.baidu.com/item/%E6%A0%88/12808149</a></li><li><a href="https://baike.baidu.com/item/%E9%98%9F%E5%88%97/14580481">https://baike.baidu.com/item/%E9%98%9F%E5%88%97/14580481</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nodejs中的事件循环</title>
    <link href="/20210920/Nodejs%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    <url>/20210920/Nodejs%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<p>nodejs 的执行场景和js的执行场景是不同的，nodejs 是在服务端运行的，而 js 是在浏览器中运行的。所以他们的事件循环也是不同的。</p><h2 id="各个阶段"><a href="#各个阶段" class="headerlink" title="各个阶段"></a>各个阶段</h2><ol><li>timers 定时器阶段<ul><li>执行 setTimeout 和 setInterval 中的回调函数。如果有到期的定时器，他们的回调函数会在这个阶段执行</li></ul></li><li>pending callbacks 阶段<ul><li>处理一些系统操作的回调函数，比如监听端口操作的回调函数</li></ul></li><li>idle, prepare 阶段<ul><li>内部使用，事件循环的一个内部状态，不对用户公开</li></ul></li><li>I/O poll 轮询阶段<ul><li>文件读取操作的回调函数</li><li>如果 Poll 队列为空，事件循环会检查是否有定时器到期，如果有，则跳转到 timers 阶段</li></ul></li><li>check 检查阶段<ul><li>执行 setImmediate 中的回调函数</li></ul></li><li>close 关闭阶段<ul><li>处理一些关闭中的事件，如关闭文件描述符、关闭网络连接等</li></ul></li></ol><h2 id="特殊阶段"><a href="#特殊阶段" class="headerlink" title="特殊阶段"></a>特殊阶段</h2><h3 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick"></a>process.nextTick</h3><p>每个阶段结束后，事件循环会检查是否有 process.nextTick 中的回调函数。如果有，会将这些回调函数添加到下一个事件循环的宏任务队列中</p>]]></content>
    
    
    <categories>
      
      <category>技术类-前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nodejs</tag>
      
      <tag>事件循环</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web设计模式解析与实战（一）</title>
    <link href="/20210912/web%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98/"/>
    <url>/20210912/web%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>有利于</p><ol><li><p>组织模块</p></li><li><p>设计沟通</p></li><li><p>代码质量</p></li></ol><h1 id="五大设计原则："><a href="#五大设计原则：" class="headerlink" title="五大设计原则："></a>五大设计原则：</h1><ol><li>开闭原则（OCP：open close principle）<ul><li>开-对拓展开放，对修改关闭</li></ul></li><li>单一职责原则（SRP）<ul><li>岗位职责单一，互不重叠</li></ul></li><li>依赖倒置原则（DIP）<ul><li>上层不应该依赖下层实现</li></ul></li><li>接口隔离原则（ISP）<ul><li>多个专业的接口比单个胖借口好用</li></ul></li><li>里氏替换原则（LSP：the Lxxxx substitution principle）<ul><li>子类能够覆盖父类</li><li>父类能够出现的地方子类就能出现</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>技术类-前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript中函数的理解</title>
    <link href="/20210910/TypeScript%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <url>/20210910/TypeScript%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><p>和JavaScript使用方式类似，可以通过<code>funciton</code>关键字、箭头函数等形式去定义，例如下面一个简单的加法函数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">add</span> = (<span class="hljs-params"><span class="hljs-attr">a</span>:<span class="hljs-built_in">number</span>,<span class="hljs-attr">b</span>:<span class="hljs-built_in">number</span></span>)=&gt; a+b<br></code></pre></td></tr></table></figure><p>上述只定义了函数的两个参数类型，这个时候整个函数虽然没有被显式定义，但是实际上TypeScript 编译器是能够通过类型推断到这个函数的类型，如下图所示：<br><img src="https://i.loli.net/2021/09/10/jzWf3SXsP4UqLpY.jpg" alt="TypeScript编译器的提示"><br>当鼠标放置在第三行 <code>add</code> 函数名的时候，会出现完整的函数定义类型，通过 <code>:</code> 的形式来定义参数类型，通过 <code>=&gt;</code> 连接参数和返回值类型</p><p>我们也可以显式地写上返回类型，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> add = (<span class="hljs-attr">a</span>:<span class="hljs-built_in">number</span>,<span class="hljs-attr">b</span>:<span class="hljs-built_in">number</span>):<span class="hljs-function"><span class="hljs-params">number</span>=&gt;</span> a+b<br></code></pre></td></tr></table></figure><p>当我们没有提供函数实现的情况下，有两种声明函数类型的方式，如下所示：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 方式一</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">LongHand</span> = &#123;<br>  (<span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;<br>&#125;;<br><br><span class="hljs-comment">// 方式二</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">ShortHand</span> = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span>;<br><br></code></pre></td></tr></table></figure><p>当存在函数重载时，只能使用方式一的形式</p><h2 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h2><p>当函数的参数可能是不存在的，只需要在参数后面加上 <code>?</code> 代表参数可能不存在，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">add</span> = (<span class="hljs-params"><span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>?: <span class="hljs-built_in">number</span></span>) =&gt; a + (b ? b : <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>这时候参数<code>b</code>可以是<code>number类型</code>或者<code>undefined类型</code>，即可以传一个<code>number类型</code>或者不传都可以</p><h2 id="剩余类型"><a href="#剩余类型" class="headerlink" title="剩余类型"></a>剩余类型</h2><p>剩余参数与JavaScript的语法类似，需要用 <code>...</code> 来表示剩余参数</p><p>如果剩余参数 rest 是一个由number类型组成的数组，则如下表示：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">add</span> = (<span class="hljs-params"><span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>, ...<span class="hljs-attr">rest</span>: <span class="hljs-built_in">number</span>[]</span>) =&gt; rest.<span class="hljs-title function_">reduce</span>((<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b), a)<br></code></pre></td></tr></table></figure><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>允许创建数项名称相同但输入输出类型或个数不同的子程序，它可以简单地称为一个单独功能可以执行多项任务的能力</p><p>关于typescript函数重载，必须要把精确的定义放在前面，最后函数实现时，需要使用 <code>|操作符</code>或者<code>?操作符</code>，把所有可能的输入类型全部包含进去，用于具体实现</p><p>这里的函数重载也只是多个函数的声明，具体的逻辑还需要自己去写，typescript并不会真的将你的多个重名 function的函数体进行合并</p><p>例如我们有一个add函数，它可以接收 string类型的参数进行拼接，也可以接收 number 类型的参数进行相加，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 上边是声明</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span> (<span class="hljs-params"><span class="hljs-attr">arg1</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">arg2</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">string</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span> (<span class="hljs-params"><span class="hljs-attr">arg1</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">arg2</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span><br><span class="hljs-comment">// 因为我们在下边有具体函数的实现，所以这里并不需要添加 declare 关键字</span><br><br><span class="hljs-comment">// 下边是实现</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span> (<span class="hljs-params"><span class="hljs-attr">arg1</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>, <span class="hljs-attr">arg2</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>) &#123;<br>  <span class="hljs-comment">// 在实现上我们要注意严格判断两个参数的类型是否相等，而不能简单的写一个 arg1 + arg2</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> arg1 === <span class="hljs-string">&#x27;string&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> arg2 === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> arg1 + arg2<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> arg1 === <span class="hljs-string">&#x27;number&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> arg2 === <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> arg1 + arg2<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>从上面可以看到：</p><ul><li>从定义的方式而言，typescript 声明函数需要定义参数类型或者声明返回值类型</li><li>typescript 在参数中，添加可选参数供使用者选择</li><li>typescript 增添函数重载功能，使用者只需要通过查看函数声明的方式，即可知道函数传递的参数个数以及类型<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1></li><li><a href="https://www.tslang.cn/docs/handbook/functions.html">https://www.tslang.cn/docs/handbook/functions.html</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD">https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD</a></li><li><a href="https://jkchao.github.io/typescript-book-chinese/typings/functions.html#%E9%87%8D%E8%BD%BD">https://jkchao.github.io/typescript-book-chinese/typings/functions.html#%E9%87%8D%E8%BD%BD</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术类-TypeScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hi there!</title>
    <link href="/20210907/about-me/"/>
    <url>/20210907/about-me/</url>
    
    <content type="html"><![CDATA[<blockquote><p>逆水行舟，不进则退</p></blockquote><p><a href="https://github.com/anuraghazra/github-readme-stats"><img src="https://github-readme-stats.vercel.app/api?username=zouHuaLu&count_private=true&show_icons=true&theme=radical" alt="Anurag&#39;s GitHub stats"></a></p><p>我的 github 仓库：<a href="https://github.com/zouHuaLu">https://github.com/zouHuaLu</a></p>]]></content>
    
    
    <categories>
      
      <category>个人简介</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人简介</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript中类的理解</title>
    <link href="/20210906/TypeScript%E4%B8%AD%E7%B1%BB%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <url>/20210906/TypeScript%E4%B8%AD%E7%B1%BB%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h1><p>类（Class）是面向对象程序设计（OOP，Object-Oriented Programming）实现信息封装的基础</p><blockquote><p>❝类是一种用户定义的引用数据类型，也称类类型❞</p></blockquote><p>传统的面向对象语言基本都是基于类的，<code>JavaScript</code> 基于原型的方式让开发者多了很多理解成本<br>在 <code>ES6</code> 之后，<code>JavaScript</code> 拥有了 <code>class</code> 关键字，虽然本质依然是构造函数，但是使用起来已经方便了许多<br>但是<code>JavaScript</code> 的<code>class</code>依然有一些特性还没有加入，比如修饰符和抽象类<br><code>TypeScript</code> 的 <code>class</code>  支持面向对象的所有特性，比如 类、接口等</p><h1 id="二、使用方式"><a href="#二、使用方式" class="headerlink" title="二、使用方式"></a>二、使用方式</h1><p>定义类的关键字为 <code>class</code>，后面紧跟类名，类可以包含以下几个模块(类的数据成员)：</p><p>「字段」：字段是类里面声明的变量。字段表示对象的有关数据。</p><p>「构造函数」：类实例化时调用，可以为类的对象分配内存。</p><p>「方法」：方法为对象要执行的操作<br>如下例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123; <br>    <span class="hljs-comment">// 字段 </span><br>    <span class="hljs-attr">engine</span>:<span class="hljs-built_in">string</span>; <br> <br>    <span class="hljs-comment">// 构造函数 </span><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">engine</span>:<span class="hljs-built_in">string</span></span>) &#123; <br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">engine</span> = engine <br>    &#125;  <br> <br>    <span class="hljs-comment">// 方法 </span><br>    <span class="hljs-title function_">disp</span>():<span class="hljs-built_in">void</span> &#123; <br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;发动机为 :   &quot;</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">engine</span>) <br>    &#125; <br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>类的继承使用过<code>extends</code>的关键字</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-title function_">move</span>(<span class="hljs-params"><span class="hljs-attr">distanceInMeters</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Animal moved <span class="hljs-subst">$&#123;distanceInMeters&#125;</span>m.`</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;<br>    <span class="hljs-title function_">bark</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Woof! Woof!&#x27;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> dog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>dog.<span class="hljs-title function_">bark</span>();<br>dog.<span class="hljs-title function_">move</span>(<span class="hljs-number">10</span>);<br>dog.<span class="hljs-title function_">bark</span>();<br><br></code></pre></td></tr></table></figure><p><code>Dog</code>是一个 派生类，它派生自 <code>Animal</code> 基类，派生类通常被称作子类，基类通常被称作 <strong>超类</strong>。</p><p><code>Dog</code>类继承了<code>Animal</code>类，因此实例<code>dog</code>也能够使用<code>Animal</code>类<code>move</code>方法。<br>同样，类继承后，子类可以对父类的方法重新定义，这个过程称之为方法的重写。</p><p>通过super关键字是对父类的直接引用，该关键字可以引用父类的属性和方法，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PrinterClass</span> &#123; <br>   <span class="hljs-title function_">doPrint</span>():<span class="hljs-built_in">void</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;父类的 doPrint() 方法。&quot;</span>) <br>   &#125; <br>&#125; <br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StringPrinter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">PrinterClass</span> &#123; <br>   <span class="hljs-title function_">doPrint</span>():<span class="hljs-built_in">void</span> &#123; <br>      <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">doPrint</span>() <span class="hljs-comment">// 调用父类的函数</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;子类的 doPrint()方法。&quot;</span>)<br>   &#125; <br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><p>可以看到，上述的形式跟ES6十分的相似，typescript在此基础上添加了三种修饰符：</p><ul><li>公共 public：可以自由的访问类程序里定义的成员</li><li>私有 private：只能够在该类的内部进行访问</li><li>受保护 protect：除了在该类的内部可以访问，还可以在子类中仍然可以访问</li></ul><h3 id="私有修饰符"><a href="#私有修饰符" class="headerlink" title="私有修饰符"></a>私有修饰符</h3><p>只能够在该类的内部进行访问，实例对象并不能够访问</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-attr">name</span>:<span class="hljs-title class_">String</span><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">name</span>:<span class="hljs-title class_">String</span></span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>    &#125;<br>&#125;<br><span class="hljs-keyword">const</span> father = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Father</span>(<span class="hljs-string">&#x27;zouHuaLu&#x27;</span>)<br>father.<span class="hljs-property">name</span> <span class="hljs-comment">//会报错，提示 &quot;属性name为私有属性，只能在Father类中访问&quot;</span><br></code></pre></td></tr></table></figure><p>并且继承该类的子类并不能访问，如下图所示：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-attr">name</span>:<span class="hljs-title class_">String</span><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">name</span>:<span class="hljs-title class_">String</span></span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Father</span>&#123;<br>    <span class="hljs-title function_">say</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`my name is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>)  <span class="hljs-comment">//会报错，提示 &quot;属性name为私有属性，只能在Father类中访问&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="受保护修饰符"><a href="#受保护修饰符" class="headerlink" title="受保护修饰符"></a>受保护修饰符</h3><p>跟私有修饰符很相似，实例对象同样不能访问受保护的属性，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-attr">name</span>:<span class="hljs-title class_">String</span><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">name</span>:<span class="hljs-title class_">String</span></span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>    &#125;<br>&#125;<br><span class="hljs-keyword">const</span> father = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Father</span>(<span class="hljs-string">&#x27;zouHuaLu&#x27;</span>)<br>father.<span class="hljs-property">name</span> <span class="hljs-comment">//会报错，提示 &quot;属性name受保护，只能在类Father及其子类中访问&quot;</span><br></code></pre></td></tr></table></figure><p>有一点不同的是 <code>protected</code> 成员在子类中仍然可以访问</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-attr">name</span>:<span class="hljs-title class_">String</span><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">name</span>:<span class="hljs-title class_">String</span></span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Father</span>&#123;<br>    <span class="hljs-title function_">say</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`my name is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="只读修饰符"><a href="#只读修饰符" class="headerlink" title="只读修饰符"></a>只读修饰符</h3><p>通过<code>readonly</code>关键字进行声明，只读属性必须在声明时或构造函数里被初始化，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span>&#123;<br>    <span class="hljs-keyword">readonly</span> <span class="hljs-attr">name</span>:<span class="hljs-title class_">String</span><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">name</span>:<span class="hljs-title class_">String</span></span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>    &#125;<br>&#125;<br><span class="hljs-keyword">const</span> father = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Father</span>(<span class="hljs-string">&#x27;zouHuaLu&#x27;</span>)<br>father.<span class="hljs-property">name</span> <span class="hljs-comment">//会报错,提示&quot;无法分配到name，因为它是只读属性&quot;</span><br></code></pre></td></tr></table></figure><h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><p>这些属性存在于类本身上面而不是类的实例上，通过<code>static</code>进行定义，访问这些属性需要通过 <code>类型.静态属性</code> 的这种形式访问，如下所示：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span> &#123;<br>    <span class="hljs-keyword">static</span> width = <span class="hljs-string">&#x27;100px&#x27;</span><br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Square</span>.<span class="hljs-property">width</span>) <span class="hljs-comment">// 100px</span><br></code></pre></td></tr></table></figure><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类做为其它派生类的基类使用，它们一般不会直接被实例化，不同于接口，抽象类可以包含成员的实现细节<br><code>abstract</code>关键字是用于定义抽象类和在抽象类内部定义抽象方法，如下所示：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">makeSound</span>(): <span class="hljs-built_in">void</span>;<br>    <span class="hljs-title function_">move</span>(): <span class="hljs-built_in">void</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;roaming the earch...&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种类并不能被实例化，通常需要我们创建子类去继承，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;<br><br>    <span class="hljs-title function_">makeSound</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;miao miao&#x27;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> cat = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>()<br><br>cat.<span class="hljs-title function_">makeSound</span>() <span class="hljs-comment">// miao miao</span><br>cat.<span class="hljs-title function_">move</span>() <span class="hljs-comment">// roaming the earch...</span><br></code></pre></td></tr></table></figure><h1 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h1><p>除了日常借助类的特性完成日常业务代码，还可以将类（class）也可以作为接口，尤其在<code>React</code> 工程中是很常用的，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Carousel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>&lt;<span class="hljs-title class_">Props</span>, <span class="hljs-title class_">State</span>&gt; &#123;&#125;<br></code></pre></td></tr></table></figure><p>由于组件需要传入 props 的类型 Props ，同时有需要设置默认 props 即 defaultProps，这时候更加适合使用class作为接口。</p><p>先声明一个类，这个类包含组件 props 所需的类型和初始值：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// props的类型</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Props</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-attr">children</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">React</span>.<span class="hljs-property">ReactElement</span>&lt;<span class="hljs-built_in">any</span>&gt;&gt; | <span class="hljs-title class_">React</span>.<span class="hljs-property">ReactElement</span>&lt;<span class="hljs-built_in">any</span>&gt; | <span class="hljs-built_in">never</span>[] = []<br>  <span class="hljs-keyword">public</span> <span class="hljs-attr">speed</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">500</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">160</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-attr">animation</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;easeInOutQuad&#x27;</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-attr">isAuto</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">true</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-attr">autoPlayInterval</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">4500</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-attr">afterChange</span>: <span class="hljs-function">() =&gt;</span> &#123;&#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-attr">beforeChange</span>: <span class="hljs-function">() =&gt;</span> &#123;&#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-attr">selesctedColor</span>: <span class="hljs-built_in">string</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-attr">showDots</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当我们需要传入 <code>props</code> 类型的时候直接将 <code>Props</code> 作为接口传入，此时 <code>Props</code> 的作用就是接口，而当需要我们设置<code>defaultProps</code>初始值的时候，我们只需要:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> defaultProps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Props</span>()<br></code></pre></td></tr></table></figure><p><code>Props</code> 的实例就是 <code>defaultProps</code> 的初始值，这就是 <code>class</code>作为接口的实际应用，我们用一个 <code>class</code> 起到了接口和设置初始值两个作用，方便统一管理，减少了代码量</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="https://www.tslang.cn/docs/handbook/classes.html">https://www.tslang.cn/docs/handbook/classes.html</a></li><li><a href="https://www.runoob.com/typescript/ts-class.html">https://www.runoob.com/typescript/ts-class.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术类-TypeScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>export与export default的区别</title>
    <link href="/20210701/export%E4%B8%8Eexport-default%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/20210701/export%E4%B8%8Eexport-default%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>node中导入模块：var 名称 = require(‘模块标识符’)</p><p>node中向外暴露成员的形式：module.exports = {}</p><p>在ES6中，也通过规范的形式，规定了ES6中如何导入和导出模块</p><p>ES6中导入模块，使用 import 模块名称 from ‘模块标识符’    import ‘表示路径’</p><p>import * from * 是ES6中导入模块的方式</p><h3 id="在ES6中，使用export-default-和-export-向外暴露成员"><a href="#在ES6中，使用export-default-和-export-向外暴露成员" class="headerlink" title="在ES6中，使用export default 和 export 向外暴露成员"></a>在ES6中，使用export default 和 export 向外暴露成员</h3><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// test.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zs&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">20</span><br>&#125;<br></code></pre></td></tr></table></figure><p>或是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// test.js</span><br><span class="hljs-keyword">var</span> info = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zs&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">20</span><br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> info<br></code></pre></td></tr></table></figure><p>在main.js中接收，test.js使用export default 向外暴露的成员</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> person <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./test.js&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person);<br></code></pre></td></tr></table></figure><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>1、export default 向外暴露的成员，可以使用任意变量来接收</p><p>2、在一个模块中，export default 只允许向外暴露一次</p><p>3、在一个模块中，可以同时使用export default 和export 向外暴露成员</p><p>4、使用export向外暴露的成员，只能使用{  }的形式来接收，这种形式，叫做【按需导出】</p><p>5、export可以向外暴露多个成员，同时，如果某些成员，在import导入时，不需要，可以不在{ }中定义</p><p>6、使用export导出的成员，必须严格按照导出时候的名称，来使用{ }按需接收</p><p>7、使用export导出的成员，如果想换个变量名称接收，可以使用as来起别名</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// test.js</span><br><span class="hljs-keyword">var</span> info = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zs&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">20</span><br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> info<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> title = <span class="hljs-string">&#x27;小星星&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> content = <span class="hljs-string">&#x27;哈哈哈&#x27;</span><br></code></pre></td></tr></table></figure><p>在main.js中接收，test.js使用export default 和 export 向外暴露的成员</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> person, &#123;title, content <span class="hljs-keyword">as</span> content1&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./test.js&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(title + <span class="hljs-string">&#x27;=======&#x27;</span> + content1);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术类-前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>new操作符的实现</title>
    <link href="/20210619/new%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/20210619/new%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="JavaScript中的new操作符的原理"><a href="#JavaScript中的new操作符的原理" class="headerlink" title="JavaScript中的new操作符的原理"></a>JavaScript中的new操作符的原理</h1><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span> (<span class="hljs-params">name, age</span>) &#123;<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age<br>&#125;<br><span class="hljs-keyword">const</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;走花路的长颈鹿&#x27;</span>, <span class="hljs-number">26</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1) <span class="hljs-comment">//Person&#123;name:&#x27;走花路的长颈鹿&#x27;,age:26&#125;</span><br></code></pre></td></tr></table></figure><p>先定义了一个构造函数<code>Person</code>，然后通过<code>new</code>操作符生成Person构造函数的一个实例并将其引用赋值给变量<code>person1</code>。然后控制台打印出<code>person1</code>的内容，可以看到该实例对象具有<code>name</code>和<code>age</code>属性，它们的值就是我们在调用构造函数时传入的值。</p><h2 id="new关键字进行的操作"><a href="#new关键字进行的操作" class="headerlink" title="new关键字进行的操作"></a>new关键字进行的操作</h2><ol><li><p> 先创建一个空对象<code>obj=&#123;&#125;</code></p></li><li><p> 将obj的<code>__proto__</code>原型指向构造函数Person的<code>prototype</code>原型对象，即<code>obj.__proto__ = Person.prototype</code></p></li><li><p> 将构造函数Person内部的this指向obj，然后执行构造函数<code>Person()</code>（也就是跟调用普通函数一样，只是此时函数的this为新创建的对象<code>obj</code>而已，就好像执行<code>obj.Person()</code>一样）</p></li><li><p> 若构造函数没有返回非原始值（即不是引用类型的值），则返回该新建的对象<code>obj</code>（默认会添加<code>return this</code>）。否则，返回引用类型的值。</p></li></ol><p><img src="https://upload-images.jianshu.io/upload_images/13931286-2638e8196f6e699b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="new操作符的执行过程"> </p><h2 id="自己实现一个new操作符"><a href="#自己实现一个new操作符" class="headerlink" title="自己实现一个new操作符"></a>自己实现一个new操作符</h2><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myNew</span> <span class="hljs-params">(constr, <span class="hljs-rest_arg">...args</span>)</span> &#123;<br> <span class="hljs-comment">// 1,2 创建一个对象obj，将obj的__proto__属性指向构造函数的原型对象</span><br> <span class="hljs-comment">// 即实现：obj.__proto__ === constructor.prototype</span><br> <span class="hljs-keyword">var</span> obj = Object.create(constr.prototype)<br> <span class="hljs-comment">// 3.将constrc内部的this（即执行上下文）指向obj，并执行</span><br> <span class="hljs-keyword">var</span> result = constr.apply(obj, args)<br> <span class="hljs-comment">// 4\. 如果构造函数返回的是对象，则使用构造函数执行的结果。否则，返回新创建的对象</span><br> <span class="hljs-keyword">return</span> result <span class="hljs-keyword">instanceof</span> Object ? result : obj<br>&#125;<br><br><span class="hljs-comment">// 使用的例子：</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(name, age)</span>&#123;<br> <span class="hljs-keyword">this</span>.name = name;<br> <span class="hljs-keyword">this</span>.age = age;<br>&#125;<br><span class="hljs-keyword">const</span> person1 = myNew(Person, <span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-number">20</span>)<br>console.log(person1)  <span class="hljs-comment">// Person &#123;name: &quot;Tom&quot;, age: 20&#125;</span><br></code></pre></td></tr></table></figure><h2 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h2><ol><li><p> 将新创建对象的原型链设置正确，这样我们才能使用原型链上的方法。</p></li><li><p> 将新创建的对象作为构造函数执行的上下文，这样我们才能正确地进行一些初始化操作。</p></li></ol><hr><h2 id="2021年7月1日补充"><a href="#2021年7月1日补充" class="headerlink" title="2021年7月1日补充"></a>2021年7月1日补充</h2><p>看一个例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Player</span>(<span class="hljs-params">color</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span> = color<br>&#125;<br><span class="hljs-title class_">Player</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">start</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br><span class="hljs-keyword">const</span> white = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Player</span>(<span class="hljs-string">&#x27;white&#x27;</span>)<br><span class="hljs-keyword">const</span> black = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Player</span>(<span class="hljs-string">&#x27;black&#x27;</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(black.<span class="hljs-property">__proto__</span>)  <span class="hljs-comment">// start()</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(black)) <span class="hljs-comment">// start()</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Player</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <span class="hljs-comment">// start()</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Player</span>.<span class="hljs-property">__proto__</span>) <span class="hljs-comment">// &#123;&#125;</span><br></code></pre></td></tr></table></figure><p>根据反推可以写一下思路</p><ol><li>一个继承自<code>Player.prototype</code>的新对象 p1/p2被创建</li><li><code>p1.__proto__ === Player.prototype</code>，<code>p1.__proto__</code>指向<code>Player.prototype</code></li><li>将this指向新创建的对象p1/p2</li><li>返回一个新对象：<ol><li>如果构造函数没有显示的返回值，那么返回this</li><li>如果有显式的返回值，是基本类型，那么还是返回this</li><li>如果构造函数有显式的返回值，是对象类型，比如是{a:1}，那么就返回{a:1}<br>现在我们再来实现一个new指令的功能<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Player</span>(<span class="hljs-params">name</span>)&#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">objectFactory</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> o = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>()<br>  <span class="hljs-keyword">let</span> <span class="hljs-title class_">FunctionConstructor</span> = [].<span class="hljs-property">shift</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>)<br>  o.<span class="hljs-property">__proto__</span> = <span class="hljs-title class_">FunctionConstructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br>  <span class="hljs-keyword">let</span> resultObj = <span class="hljs-title class_">FunctionConstructor</span>.<span class="hljs-title function_">apply</span>(o, <span class="hljs-variable language_">arguments</span>) <br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> resultObj === <span class="hljs-string">&#x27;object&#x27;</span> ? resultObj : o<br>&#125;<br><span class="hljs-keyword">const</span> p1 = <span class="hljs-title function_">objectFactory</span>(<span class="hljs-title class_">Player</span>, <span class="hljs-string">&#x27;花鹿&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1) <span class="hljs-comment">// 花鹿</span><br></code></pre></td></tr></table></figure><h2 id="完"><a href="#完" class="headerlink" title="完~"></a>完~</h2></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>技术类-前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原型与原型链与constructor</title>
    <link href="/20210618/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%8Econstructor/"/>
    <url>/20210618/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%8Econstructor/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="原型与原型链与constructor"><a href="#原型与原型链与constructor" class="headerlink" title="原型与原型链与constructor"></a>原型与原型链与constructor</h1><p>本文参考自：<a href="https://blog.csdn.net/cc18868876837/article/details/81211729">https://blog.csdn.net/cc18868876837/article/details/81211729</a></p><h2 id="先来个总结："><a href="#先来个总结：" class="headerlink" title="先来个总结："></a>先来个总结：</h2><ol><li><p> 我们需要牢记两点：①<code>__proto__</code>和<code>constructor</code>属性是对象所独有的；② <code>prototype</code>属性是函数所独有的，因为函数也是一种对象，所以函数也拥有<code>__proto__</code>和<code>constructor</code>属性。</p></li><li><p> __<code>proto__</code>属性的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的<code>__proto__</code>属性所指向的那个对象（父对象）里找，一直找，直到<code>__proto__</code>属性的终点null，再往上找就相当于在null上取值，会报错。通过<code>__proto__</code>属性将对象连接起来的这条链路即我们所谓的原型链。</p></li><li><p> <code>prototype</code>属性的作用就是让该函数所实例化的对象们都可以找到公用的属性和方法，即<code>f1.__proto__ === Foo.prototype</code>。</p></li><li><p> <code>constructor</code>属性的含义就是指向该对象的构造函数，所有函数（此时看成对象了）最终的构造函数都指向<code>Function</code>。</p></li></ol><p><img src="https://upload-images.jianshu.io/upload_images/13931286-5467dbdb42fd91ef?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="整体的联系"> </p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p><code>__proto__</code>翻译为<strong>原型</strong>，多个<code>__proto__</code>串连起来的叫做<strong>原型链</strong>。</p><p><code>prototype</code>翻译为<strong>原型对象</strong>。</p><h2 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h2><p><code>Object.getPrototypeOf()</code> 方法返回指定对象的原型（内部<code>[[Prototype]]</code>属性的值）。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">const</span> prototype1 = &#123;&#125;;<br><span class="hljs-title">const</span> object1 = <span class="hljs-type">Object</span>.create(prototype1);<br><br><span class="hljs-title">console</span>.log(<span class="hljs-type">Object</span>.getPrototypeOf(object1) === prototype1);<br>// expected output: true<br><span class="hljs-type">Object</span>.getPrototypeOf(object1) === object1.__proto__<br></code></pre></td></tr></table></figure><h2 id="正式开始"><a href="#正式开始" class="headerlink" title="正式开始"></a>正式开始</h2><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nim">function <span class="hljs-type">Foo</span>() <span class="hljs-meta">&#123;...&#125;</span>;<br><span class="hljs-keyword">let</span> f1 = new <span class="hljs-type">Foo</span>();<br></code></pre></td></tr></table></figure><p>以上代码表示创建一个构造函数Foo()，并用new关键字实例化该构造函数得到一个实例化对象f1。这里稍微补充一下new操作符将函数作为构造器进行调用时的过程：<strong>函数被调用，然后新创建一个对象，并且成了函数的上下文（也就是此时函数内部的this是指向该新创建的对象，这意味着我们可以在构造器函数内部通过this参数初始化值），最后返回该新对象的引用。</strong></p><h2 id="proto-属性"><a href="#proto-属性" class="headerlink" title="__proto__属性"></a><code>__proto__</code>属性</h2><p>首先要记住两点：</p><ol><li><p> <code>__proto__</code>和<code>constructor</code>是对象才有的属性，在JavaScript中函数也是一种对象。</p></li><li><p> <code>prototype</code>是函数才有的属性。</p></li></ol><p><img src="https://upload-images.jianshu.io/upload_images/13931286-9355e730b53d1879?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="__proto__"> </p><p>这里我们仅留下 <code>__proto__</code> 属性，它是对象所独有的，可以看到<code>__proto__</code>属性都是由<strong>一个对象指向一个对象</strong>，即指向它们构造函数的<strong>原型对象</strong>（也可以理解为父对象），那么这个属性的作用是什么呢？它的<strong>作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的<code>__proto__</code>属性所指向的那个对象（可以理解为父对象）里找，如果父对象也不存在这个属性，则继续往父对象的<code>__proto__</code>属性所指向的那个对象（可以理解为爷爷对象）里找，如果还没找到，则继续往上找…直到原型链顶端null（可以理解为原始人。。。），再往上找就相当于在null上取值，会报错（可以理解为，再往上就已经不是“人”的范畴了，找不到了，到此结束，null为原型链的终点）</strong>，由以上这种通过<code>__proto__</code>属性来连接对象直到null的一条链即为我们所谓的原型链。    其实我们平时调用的字符串方法、数组方法、对象方法、函数方法等都是靠<code>__proto__</code>继承而来的。</p><h2 id="prototype属性"><a href="#prototype属性" class="headerlink" title="prototype属性"></a><code>prototype</code>属性</h2><p><img src="https://upload-images.jianshu.io/upload_images/13931286-a68d7e7851adf580?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="prototype属性"> </p><p><code>prototype</code>属性是函数独有的。他是从一个函数指向一个对象，他的含义是函数的原型对象</p><p><code>f1.__proto__ === Foo.prototype</code>，它们两个完全一样。那prototype属性的作用又是什么呢？<strong>它的作用就是包含可以由特定类型的所有实例共享的属性和方法，也就是让该函数所实例化的对象们都可以找到公用的属性和方法。</strong>任何函数在创建的时候，其实会默认同时创建该函数的prototype对象。</p><h2 id="constructor属性"><a href="#constructor属性" class="headerlink" title="constructor属性"></a>constructor属性</h2><p><img src="https://upload-images.jianshu.io/upload_images/13931286-8de481f4fbc04fee?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="constructor属性"> </p><p><code>constructor</code>属性也是对象才拥有的，它是从一个对象指向一个函数，含义就是指向该对象的构造函数，每个对象都有构造函数（本身拥有或继承而来，继承而来的要结合<code>__proto__</code>属性查看会更清楚点，如下图所示），从上图中可以看出<code>Function</code>这个对象比较特殊，它的构造函数就是它自己（因为<code>Function</code>可以看成是一个函数，也可以是一个对象），所有函数和对象最终都是由<code>Function</code>构造函数得来，所以<code>constructor</code>属性的终点就是<code>Function</code>这个函数。</p><p><code>函数创建的对象.__proto__ === 该函数.prototype，该函数.prototype.constructor===该函数本身</code></p><h2 id="完"><a href="#完" class="headerlink" title="完~"></a>完~</h2>]]></content>
    
    
    <categories>
      
      <category>技术类-前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue自定义全局组件</title>
    <link href="/20210618/Vue%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%A8%E5%B1%80%E7%BB%84%E4%BB%B6/"/>
    <url>/20210618/Vue%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%A8%E5%B1%80%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="vue自定义全局弹框组件"><a href="#vue自定义全局弹框组件" class="headerlink" title="vue自定义全局弹框组件"></a>vue自定义全局弹框组件</h1><ol><li><p>在components文件夹下新增一个组件文件夹Dialog，新建一个模板组件Dialog.vue</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;u_dialog_panel&quot; @touchmove.stop=&quot;noop&quot;&gt;<br>    &lt;div class=&quot;mask&quot; v-if=&quot;visible&quot; @click=&quot;handleClose&quot;&gt;&lt;/div&gt;<br>    &lt;transition name=&quot;open&quot;&gt;<br>      &lt;div v-if=&quot;visible&quot; class=&quot;dialog_body&quot;&gt;<br>        &lt;slot&gt;&lt;/slot&gt;<br>        &lt;div class=&quot;btns&quot; v-if=&quot;confirmText || cancleText&quot;&gt;<br>          &lt;div class=&quot;cancle btn&quot; v-if=&quot;cancleText&quot; @click=&quot;handleCancle&quot;&gt;&#123;&#123;cancleText&#125;&#125;&lt;/div&gt;<br>          &lt;div class=&quot;confirm btn&quot; :style=&quot;confirmStyle&quot; v-if=&quot;confirmText&quot; @click=&quot;handleConfirm&quot;&gt;&#123;&#123;confirmText&#125;&#125;&lt;/div&gt;<br>        &lt;/div&gt;<br>      &lt;/div&gt;<br>    &lt;/transition&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>export default &#123;<br>  name: &#x27;UDialog&#x27;,<br>  props: &#123;<br>    visible: &#123; type: Boolean, default: false, required: true &#125;,<br>    // 确定按钮的文案<br>    confirmText: &#123; type: String, default: &#x27;确定&#x27; &#125;,<br>    confirmStyle: &#123; type: String, default: &#x27;&#x27; &#125;,<br>    // 取消按钮的文案<br>    cancleText: &#123; type: String, default: &#x27;取消&#x27; &#125;,<br>    cancleStyle: &#123; type: String, default: &#x27;&#x27; &#125;,<br>  &#125;,<br>  created () &#123;<br>    this.$nextTick(() =&gt; &#123;<br>      document.body.insertBefore(this.$el, document.body.lastChild)<br>    &#125;)<br>  &#125;,<br>  beforeDestroy () &#123;<br>    document.body.removeChild(this.$el)<br>  &#125;,<br>  methods: &#123;<br>    // 关闭弹窗<br>    handleClose () &#123; this.$emit(&#x27;close&#x27;) &#125;,<br>    // 确定按钮<br>    handleConfirm () &#123; this.$emit(&#x27;confirm&#x27;) &#125;,<br>    // 取消按钮<br>    handleCancle () &#123; this.$emit(&#x27;cancle&#x27;) &#125;,<br>    noop () &#123;&#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br><br>&lt;style lang=&quot;less&quot; scoped&gt;<br>.u_dialog_panel &#123;<br>  .mask &#123;<br>    width: 100vw;<br>    height: 100vh;<br>    background-color: rgba(0, 0, 0, 0.5);<br>    position: fixed;<br>    left: 0;<br>    top: 0;<br>    z-index: 100;<br>    backdrop-filter: blur(5px);<br>  &#125;<br>  .dialog_body&#123;<br>    width: 80vw;<br>    background-color: #fff;<br>    position: fixed;<br>    left: 50vw;<br>    top: 50vh;<br>    z-index: 100;<br>    transform: translate(-50%, -50%);<br>    transform-origin: 0 0;<br>    border-radius: .875rem;<br>    &amp;.open-enter &#123;<br>      opacity: 0;<br>      transform: scale(0.7) translate(-50%, -50%);<br>      transition: all 0.3s;<br>    &#125;<br>    &amp;.open-enter-to &#123;<br>      opacity: 1;<br>      transform: scale(1) translate(-50%, -50%);<br>      transition: all 0.3s;<br>    &#125;<br>    .btns &#123;<br>      display: flex;<br>      justify-content: space-between;<br>      align-items: center;<br>      .btn &#123;<br>        display: flex;<br>        justify-content: center;<br>        align-items: center;<br>        flex-grow: 1;<br>        width: 50%;<br>        height: 2.875rem;<br>        border-top: 1px solid #ddd;<br>        box-sizing: border-box;<br>        display: flex;<br>        justify-content: center;<br>        align-items: center;<br>        font-size: .875rem;<br>        &amp; + .btn &#123;<br>          border-left: 1px solid #ddd;<br>        &#125;<br>        &amp;.cancle &#123;<br>          color: #666666;<br>        &#125;<br>        &amp;.confirm &#123;<br>          color: #FF5883;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/style&gt;<br><br></code></pre></td></tr></table></figure></li><li><p>在此文件夹再新建一个index.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vue">import Dialog from &#x27;./Dialog&#x27;<br><br>Dialog.install = function (Vue, options) &#123;<br>  Vue.component(`$&#123;Dialog.name&#125;`, Dialog)<br>&#125;<br><br>export default Dialog<br><br></code></pre></td></tr></table></figure></li><li><p>最后再main.js里注册为全局组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">import Dialog from &#x27;./components/Dialog/index.js&#x27;<br><br>Vue.use(Dialog)<br></code></pre></td></tr></table></figure></li></ol><h2 id="这样就可以在其他组件里无需声明而使用此组件"><a href="#这样就可以在其他组件里无需声明而使用此组件" class="headerlink" title="这样就可以在其他组件里无需声明而使用此组件"></a>这样就可以在其他组件里无需声明而使用此组件</h2>]]></content>
    
    
    <categories>
      
      <category>技术类-Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript中的堆栈以及数据类型</title>
    <link href="/20210617/JavaScript%E4%B8%AD%E7%9A%84%E5%A0%86%E6%A0%88%E4%BB%A5%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/20210617/JavaScript%E4%B8%AD%E7%9A%84%E5%A0%86%E6%A0%88%E4%BB%A5%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="JavaScript-的堆栈以及数据类型"><a href="#JavaScript-的堆栈以及数据类型" class="headerlink" title="JavaScript 的堆栈以及数据类型"></a>JavaScript 的堆栈以及数据类型</h1><p><a href="https://www.jianshu.com/p/5e0e8d183102">本文参考此链接</a></p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><ul><li><p>是堆内存的简称。</p></li><li><p>需要程序员自己申请空间，内存大小不一，也不会自动释放。</p></li><li><p>堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大</p></li><li><p>堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片</p></li></ul><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ul><li><p>是栈内存的简称。</p></li><li><p>是自动分配相对固定大小的内存空间，并由系统自动释放，所以生命周期只在函数的运行过程中。</p></li><li><p>后进先出</p></li><li><p>栈是向低地址扩展的数据结构，是一块连续的内存的区域</p></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/4037795-707975f1f45a6a0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1136/format/webp" alt="栈"></p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><ul><li><p>是只允许在一端进行插入操作、而在另一端进行删除操作的线性表。特殊之处在于它只允许在表的前端进行删除操作，而在表的后端进行插入操作，和栈一样，队列是一种操作受限制的线性表。</p></li><li><p>先进先出</p></li></ul><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p><code>javascript</code>的<strong>基本类型</strong>就 5 种:<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>和<code>String</code>，它们都是直接按值存储在栈中的，每种类型的数据占用的内存空间的大小是<strong>确定</strong>的，并由系统自动分配和自动释放。这样带来的好处就是，内存可以及时得到回收，相对于堆来说，更加容易管理内存空间。</p><h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><p><code>javascript</code>中其他类型的数据被称为<strong>引用类型</strong>的数据 : 如对象(Object)、数组(Array)、函数(Function) …，它们是通过拷贝和 new 出来的，这样的数据存储于堆中。其实，说存储于堆中，也不太准确，因为，引用类型的数据的地址指针是存储于栈中的，当我们想要访问引用类型的值的时候，需要先从栈中获得对象的地址指针，然后，在通过地址指针找到堆中的所需要的数据。</p><h3 id="传值与传址"><a href="#传值与传址" class="headerlink" title="传值与传址"></a>传值与传址</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>];<br><span class="hljs-keyword">var</span> arr2 = arr1;<br><span class="hljs-keyword">var</span> str1 = arr1[<span class="hljs-number">2</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr2); <span class="hljs-comment">//1,2,5,8</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str1); <span class="hljs-comment">//5</span><br>arr2[<span class="hljs-number">4</span>] = <span class="hljs-number">99</span>;<br>str1 = <span class="hljs-number">6</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr1); <span class="hljs-comment">//1,2,5,8,99</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr1[<span class="hljs-number">2</span>]); <span class="hljs-comment">//5</span><br></code></pre></td></tr></table></figure><p>当我改变 arr2 中的数据时，arr1 中数据也发生了变化，当改变 str1 的数据值时，arr1 却没有发生改变。为什么？这就是<strong>传值与传址</strong>的区别。</p><p>因为 arr1 是数组，属于引用类型，所以它赋予给 arr2 的时候传的是栈中的地址（相当于新建了一个不同名“指针”），而不是堆内存中的对象的值。str1 得到的是一个基本类型的赋值，因此，str1 仅仅是从 arr1 堆内存中获取了一个数值，并直接保存在栈中。arr1、arr2 都指向同一块堆内存，arr2 修改的堆内存的时候，也就会影响到 arr1，str1 是直接在栈中修改，并且不能影响到 arr1 堆内存中的数据。</p><p><img src="https://images2018.cnblogs.com/blog/1402663/201808/1402663-20180802132101478-2092833591.png" alt="img"></p><h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><p>上边说到的赋值方式就是浅拷贝，那么什么叫作深拷贝呢？就是要将 arr1 的每个基本类型的数据都遍历一遍，依次的赋值给 arr2 的对应字段。避免产生因为地址引用带来的问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>];<br><span class="hljs-keyword">var</span> arr2 = [];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr1.<span class="hljs-property">length</span>; i++) &#123;<br>  arr2[i] = arr1[i];<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr2); <span class="hljs-comment">//1,2,5,8</span><br>arr2[<span class="hljs-number">4</span>] = <span class="hljs-number">99</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr2); <span class="hljs-comment">//1,2,5,8,99</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr1); <span class="hljs-comment">//1,2,5,8</span><br></code></pre></td></tr></table></figure><p>javascript 面向对象的语言本身在处理对象和非对象上就进行了划分，从数据结构的角度来讲，对象就是栈的指针和堆中的数值。</p><h1 id="完"><a href="#完" class="headerlink" title="完~"></a>完~</h1>]]></content>
    
    
    <categories>
      
      <category>技术类-前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
